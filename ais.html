<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<p><span> Министерство образования и науки Российской Федерации<br />
Федеральное государственное бюджетное образовательное<br />
учреждение высшего профессионального образования<br />
&lt;&lt;Иркутский государственный университет&gt;&gt;<br />
Институт математики, экономики и информатики </span><br />
<span>В четырех частях<br />
Часть 4</span><br />
to</p>
<p><span>Учебное пособие</span> <strong>Иркутск 2014</strong></p>
<p>УДК 681.3(075.8)<br />
ББК 32.97я73<br />
К63</p>
<p>Печатается по решению ученого совета ИМЭИ<br />
<strong>Издание выходит в рамках Программы<br />
стратегического развития ФГБОУ ВПО &lt;&lt;ИГУ&gt;&gt;<br />
на 2012–2016 гг., проект Р121-02-001</strong></p>
<p><strong>Рецензенты:</strong><br />
д-р физ.-мат. наук <span><em>В. И. Сажин</em></span>, канд. техн. наук <span><em>А. О. Шигаров</em></span><br />
</p>
<p><br />
К63</p>
<p>Компьютерные науки: учеб. пособие. В 4 ч. – Иркутск: Из-во ИГУ, 2014.</p>
<p>Ч. 4. Системы искусственного интеллекта / Е. А. Черкашин –  c.</p>
<p><span><strong>ISBN 978-5-9624-1255-9</strong></span> (ч. 4)</p>
<p><span><strong>ISBN 978-5-9624-1251-1</strong></span></p>
<p>Первая часть учебного пособия включает разделы: &lt;&lt;Информация и данные&gt;&gt;, &lt;&lt;Вычислительная система&gt;&gt;, &lt;&lt;Устройство персонального компьютера&gt;&gt;, &lt;&lt;Системное и прикладное программное обеспечение&gt;&gt;, &lt;&lt;Компьютерные сети&gt;&gt;; вторая – &lt;&lt;Программирование&gt;&gt;, третья – &lt;&lt;Базы данных и СУБД&gt;&gt;, четвёртая часть – &lt;&lt;Системы искусственного интеллекта&gt;&gt;.</p>
<p>Предназначено для студентов вузов, обучающихся по направлениям «Математика», «Прикладная математика и информатика», «Математическое обеспечение и администрирование информационных систем», «Информационная безопасность».</p>
<p>УДК 681.3 (075.8)<br />
ББК 32.97я73</p>
<p>ISBN 978-5-9624-1255-9 (ч. 4)<br />
ISBN 978-5-9624-1251-1<br />
</p>
<ul>
<li><p>Черкашин Е. А., 2014</p></li>
<li><p>ФГБОУ ВПО &lt;&lt;ИГУ&gt;&gt;, 2014</p></li>
</ul>
<section id="предисловие" class="level1 unnumbered">
<h1>Предисловие</h1>
<p>Интерес математиков к решению сложных задач при помощи вычислительной техники постоянно возрастает. Разрабатываются программные пакеты автоматизации выполнения математических операций и даже решения стандартных задач в автоматическом режиме. Алгоритмы, реализованные в таких пакетах, используют современные и классические методы поиска решения. Решение представляется в виде комбинации различных вариантов преобразования сложных структур данных, входных и выходных переменных различных методов. Для того чтобы продуктивно пользоваться этими пакетами, необходимо изучать, как они работают, как получают требуемое решение.</p>
<p>В учебном пособии в форме тренинга (<span><em></em></span>) представляются самые простые методики поиска решения дискретных задач, относящихся к различным классам искусственного интеллекта (ИИ): &lt;&lt;логическое программирование&gt;&gt;, &lt;&lt;планирование действий&gt;&gt;, &lt;&lt;решение задач в терминах ограничений&gt;&gt; и &lt;&lt;символьные вычисления&gt;&gt; (&lt;&lt;компьютерная алгебра&gt;&gt;). Основная задача пособия состоит в выработке навыков автоматизации некоторых аспектов творческой деятельности математика при помощи вычислительных машин и классических средств реализации программ из области ИИ. Навыки решения таких задач позволят в будущем создавать собственные программные системы, реализующие новые методы, для которых еще не было разработано соответствующего программного обеспечения.</p>
<p>Пособие разработано для студентов, обучающихся по специальности &lt;&lt;Математика&gt;&gt;, может быть использовано всеми заинтересованными программистами, желающими овладеть некоторыми методами искусственного интеллекта. Пособие включает подборку материала по курсам &lt;&lt;Рекурсивно&quot;=логическое программирование&gt;&gt;, &lt;&lt;Искусственный интеллект&gt;&gt;. Оно никоим образом не претендует на полноту излагаемого материала и базируется на личном опыте преподавания. Пособие следует воспринимать как путеводитель, и учащиеся в процессе обучения должны активно использовать литературу, на которую в тексте указаны ссылки. В цитируемом тексте в виде сносок автор позволяет себе высказывать свое отношение к изложенному.</p>
<p>Форма тренинга, примененная в пособии, позволяет рассматривать материал в процессе монолога с читателем. Ставится задача, обсуждаются возможные варианты ее решения. Затем рассматривается новый материал, необходимый для реализации выбранного решения. Если в процессе появляется необходимость в изучении дополнительного материала, то параллельно основному монологу создается новый. Если читатель знаком с излагаемым материалом, то его можно пропустить и перейти далее (по ссылке) к рассмотрению решения задачи. Форма изложения, принятая в пособии, предполагает, что материал осваивается с самого начала до самого конца. То есть эту книгу будет сложно использовать как справочник.</p>
<p>Практически все разделы пособия представляют собой авторскую разработку, за исключением вводной части, которая содержит компиляцию материала из различных книг и справочников. Во всем тексте, по возможности, указаны ссылки на оригинальные источники информации. Автор не преследует цели коммерческого использования учебного пособия. В электронной версии ссылки на литературу в списке литературы – активные и ведут к найденным в Интернете электронным версиям книг. Читатель должен решать самостоятельно: скачивать их из Интернета, покупать в магазинах или искать в библиотеках.</p>
<p>Данное учебное пособие является свободной книгой (так же как и свободное программное обеспечение), которую можно при определенных условиях читать, копировать и дополнять новым материалом. Адрес исходного кода методического пособия: <a href="https://github.com/eugeneai/ais/tree/ais-pure-math" class="uri">https://github.com/eugeneai/ais/tree/ais-pure-math</a>. Исходный код разрешено использовать в соответствии с лицензией , которая позволяет включать материал в свои произведения (необходимо указывать автора оригинальных материалов), запрещает коммерческое использование материалов (ввиду наличия заимствований в первой части) и требует распространение производных материалов производить по этой же самой лицензии (по указанной выше же причине). Адрес лицензии: <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" class="uri">http://creativecommons.org/licenses/by-nc-sa/4.0/</a>.</p>
<p>В тексте пособия использована следующая разметка:</p>
<ul>
<li><p>приводятся программы, фрагменты программ в основном тексте пособия, а также имена идентификаторов, т. е. все, что имеет какое&quot;=либо отношение к тексту программы;</p></li>
<li><p>выделяются новые термины, вводимые в текст и возникающие, например, в определениях, а также текст выделенных примеров;</p></li>
<li><p><span>при помощи &lt;&lt;кавычек&gt;&gt;</span> выделяются метафоры, значения, элементы текстов программ, цитаты, слова, использованные в переносном смысле, и т. д.</p></li>
</ul>
<p>Автор пособия надеется, что материал, представленный в данной книге, будет полезным при решении практических и научных задач, а также что он вызовет интерес студента к разработке программного обеспечения в области искусственного интеллекта.</p>
<p>to to</p>
<p><a href="http://eugeneai.github.io/ais/"><img src="QRickit.png" alt="image" /></a></p>
<p>Адрес сайта с методическим материалом:</p>
<p><a href="http://eugeneai.github.io/ais/" class="uri">http://eugeneai.github.io/ais/</a></p>
<p><span>P. S.</span> Автора искать по адресу <a href="mailto:eugeneai@icc.ru">eugeneai@icc.ru</a>, в поле &lt;&lt;<span>тема</span>&gt;&gt; просим указывать &lt;&lt;ИИ-2014&gt;&gt;.</p>
</section>
<section id="информатика-и-искусственный-интеллект" class="level1">
<h1><span class="header-section-number">1</span> Информатика и искусственный интеллект</h1>
<p>Среди задач, которые решают современные программисты, выделяются задачи создания программных систем математического моделирования и прогнозирования, проектирования и реализации информационных систем и баз данных, системного программного обеспечения. Все перечисленные задачи объединяет одно общее свойство – для широкого практического класса задач можно построить детерминированную процедуру (например, алгоритм) их решения. Существует большой класс задач, для которых такую процедуру построить достаточно сложно, а порой и невозможно. Например, разработать игровую систему, способную играть в шахматы с человеком на высоком профессиональном уровне. К таким задачам относятся также и задачи поиска решения (планирование действий, или Problem Solving), распознавание образов, экспертные консультации, интеллектуальное управление сложными динамическими объектами и т. д. В каждой такой задаче четко вырисовывается их первое общее свойство – необходимость <span><em>автоматизации принятия некоторого решения</em></span>. В других задачах четко вырисовывается еще одно свойство – <span><em>обработка символьной информации</em></span>. Примерами задач, обработка информации в которых основывается на преобразовании строк символов, выступают следующие задачи: автоматический перевод текста с одного естественного языка на другой, автоматическое доказательство теорем. В той или иной мере оба выделенных свойства присутствуют в каждой из задач.</p>
<p>Средства искусственного интеллекта<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>, в частности логическое программирование, позволяют представить решение таких задач, алгоритм, в рекурсивном виде или в виде некоторого переборного процесса. Такое представление обладает одним полезным свойством – оно компактно и достаточно близко к исходной математической модели задачи по сравнению с изученной ранее процедурной парадигмой программирования. Программисту не требуется определять все действия, необходимые для достижения результата. Как правило, достаточно рассказать транслятору, какие данные есть в наличии, объяснить, как они связаны друг с другом и постановкой задачи. Система постарается получить решение самостоятельно. Логическое программирование прежде всего направлено на решение задач ИИ, поэтому в данном учебном пособии необходимо ввести читателя в базовые концепции ИИ. Для начала рассмотрим, как можно определить, относится ли ваша задача к задачам ИИ.</p>
<p>Рассмотрим задачи планирования действий. Что есть решение в этих задачах? Это ответ на вопрос &lt;&lt;Какие действия необходимо выполнить и в каком порядке их надо выполнять, чтобы достичь цели из некоторого начального состояния?&gt;&gt;. Получается, что ответ на этот вопрос есть некоторая конечная последовательность действий. Эта последовательность представляется в памяти компьютера в виде некоторого ряда чисел, кодирующего эту последовательность. Построить (найти) эту последовательность, выбрать последовательность из возможных альтернатив – это и есть принятие решения.</p>
<p>Есть еще один интересный аспект алгоритма – массовость, т. е. алгоритмы должны строиться для некоторого класса задач, а не для конкретных входных данных. Что это значит? На вход программы, реализующей алгоритм, подаются какие&quot;=либо входные данные, задающие конкретную задачу из класса решаемых алгоритмом задач. Теперь представим такую ситуацию, что на вход алгоритма невозможно подать все необходимые данные, т. е. имеет место <em>неполнота информации</em>. Или другой вариант: имеется два эксперимента с разными результатами, но с одинаковым набором исходных данных. Какие данные следует передавать на вход алгоритма? Этот случай связан с <em>противоречивой информацией</em>. Разрабатывая программное обеспечение, позволяющее функционировать в таких условиях, приходится создавать подпрограммы, принимающие решение, что следует делать. Например, во втором случае можно запустить алгоритм для каждого набора данных и проанализировать полученные результаты. Может получиться так, что эти результаты не будут сильно отличаться друг от друга, а может этого не получиться. В последнем случае одним из вариантов дальнейших действий является поиск нового атрибута (характеристики), который позволит различать варианты, находящиеся в противоречии.</p>
<p>Задачи, обладающие перечисленными свойствами, и методы их решения на ЭВМ в конечном счете составляют предмет исследования искусственного интеллекта – одного из разделов информатики (Computer Science).</p>
<section id="определения" class="level2">
<h2><span class="header-section-number">1.1</span> Определения</h2>
<p>В литературе можно найти целый спектр определений термина &lt;&lt;искусственный интеллект&gt;&gt;, однако, насколько известно авторам, ни один из них не принят как стандарт.</p>
<p>Среди многих точек зрения доминируют три <span class="citation" data-cites="AIDictionary"></span>. Согласно первой, исследования в области искусственного интеллекта являются фундаментальными исследованиями, в рамках которых разрабатываются модели и методы решения задач, традиционно считавшихся интеллектуальными и не поддававшихся ранее формализации и автоматизации. Согласно второй точке зрения, новое направление связано с новыми идеями решения задач на ЭВМ, с разработкой принципиально иной технологии программирования, с переходом к архитектуре ЭВМ, отвергающей классическую архитектуру, которая восходит еще к первым ЭВМ. Наконец, третья точка зрения, по&quot;=видимому, наиболее прагматическая, состоит в том, что в результате работ в области искусственного интеллекта рождается множество прикладных систем, решающих задачи, для которых ранее создаваемые системы были непригодны.</p>
<p>Достаточно простые определения <span><em>искусственного интеллекта</em></span> показаны в табл. [pic:determai] <span class="citation" data-cites="Russell"></span>. Выделяются несколько комбинаций двух пар ключевых терминов: &lt;&lt;размышлять&gt;&gt; и &lt;&lt;вести себя&gt;&gt;, &lt;&lt;как человек&gt;&gt; и &lt;&lt;рационально&gt;&gt;.</p>
<table>
<caption>Несколько определений искусственного интеллекта<span data-label="pic:determai"></span></caption>
<thead>
<tr class="header">
<th style="text-align: left;">Системы, которые размышляют, как люди</th>
<th style="text-align: left;">Системы, которые размышляют рационально</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Системы, которые ведут себя, как люди</td>
<td style="text-align: left;">Системы, которые ведут себя рационально</td>
</tr>
</tbody>
</table>
<p><span><em>Искусственный интеллект</em></span> как наука насчитывает уже около 60 лет. Задачей этой науки является воссоздание с помощью искусственных устройств (в основном с помощью ЭВМ) разумных рассуждений и действий <span class="citation" data-cites="Lauriere"></span>.</p>
<p><span><em>Искусственный интеллект</em></span> – раздел информатики, изучающий методы, способы и приемы моделирования и воспроизведения с помощью ЭВМ разумной деятельности человека, связанной с решением задач <span class="citation" data-cites="math_slov:88"></span>.</p>
<section id="тест-тьюринга" class="level3">
<h3><span class="header-section-number">1.1.1</span> Тест Тьюринга</h3>
<p>В книге <span class="citation" data-cites="Russell"></span> вводится понятие <span><em>агента</em></span>. <span><em>Агент</em></span> – субъект, находящийся в среде, имеющий цель своего существования, взаимодействующий со средой или другими агентами с помощью <span><em>рецепторов</em></span> и <span><em>эффекторов</em></span>. Рецепторы воспринимают информацию о среде, а эффекторы – это способ воздействия на среду, которое меняет среду, а следовательно, и информацию о среде. Агентом может являться как программа, так и человек. Вводится понятие <span><em>интеллектуального агента</em></span> – агента, обладающего интеллектом.</p>
<p>Агенты взаимодействуют друг с другом. Примером такого взаимодействия выступают, например, общение человека с человеком или работа человека с компьютерной программой.</p>
<p>Тест Тьюринга предложен Аланом Тьюрингом (1950) и был разработан, чтобы представить действующее определение интеллекта <span class="citation" data-cites="Russell"></span>. Тьюринг определял интеллектное поведение как возможность достижения человеческого уровня производительности во всех задачах, где возможно обмануть человека, задающего вопросы. Грубо говоря, предложенный им тест состоял в следующем. Компьютеру задает вопросы человек через удаленное устройство. Тест считается пройденным, если человек не может сказать, кто или что на другом конце устройства: компьютер или человек.</p>
<p>С точки зрения агентов, этот тест можно представить так: один интеллектуальный агент (человек) по информационному каналу, не позволяющему ему использовать иную информацию, кроме ответов на поставленные им вопросы, анализирует поступающую информацию (ответы собеседника) от другого агента (испытуемого). Если первый агент не в силах определить, кто на другом конце информационного канала – человек или устройство, тогда считается, что испытуемый агент обладает интеллектуальными свойствами.</p>
</section>
<section id="задачи-ии" class="level3">
<h3><span class="header-section-number">1.1.2</span> Задачи ИИ</h3>
<p>Всякая задача, для которой неизвестен алгоритм решения, априорно относится к ИИ. Перечислим некоторые направления (задачи) ИИ <span class="citation" data-cites="AIDictionary"></span>.</p>
<dl>
<dt>Восприятие и распознавание образов.</dt>
<dd><p>К таким задачам относятся распознавание текста (как печатного, так и рукописного), компьютерное зрение.</p>
</dd>
<dt>Автоматическое доказательство теорем.</dt>
<dd><p>В этом направлении решаются задачи автоматизации математических исследований, разработки формальных (математических) методов логического вывода для поддержки решения других задач ИИ. Это направление нашло применение в задачах верификации программного и аппаратного обеспечения.</p>
</dd>
<dt>Игры.</dt>
<dd><p>Автоматизация решения игровых задач, например игры в шахматы, калах, реверси, а также других игр.</p>
</dd>
<dt>Решение задач (Problem Solving), планирование действий.</dt>
<dd><p>В этих задачах предполагается наличие некоторого выбора из возможных путей решения, требуется найти первое, лучшее или оптимальное решение. Примеры: составление расписания работы учебного учреждения, планирование действий автономного необитаемого аппарата.</p>
</dd>
<dt>Понимание естественного языка.</dt>
<dd><p>Как правило, системы понимания естественного языка являются составляющими информационных систем различного назначения: от автоматических систем заказа билетов до систем ввода экспертного знания.</p>
</dd>
<dt>Логическое программирование.</dt>
<dd><p>Языки и системы программирования высокого выразительного уровня, построенные на основе результатов исследования формально&quot;=логических систем, теорий исчислений. Эта область ИИ носит, кроме прочего, инструментальный характер, т. е. логическое программирование является средством реализации систем ИИ.</p>
</dd>
<dt>Экспертные системы.</dt>
<dd><p>Экспертные системы (ЭС) позволяют заменять человека&quot;=эксперта в некоторой предметной области программной системой, способной проводить экспертные консультации пользователя. ЭС нашли широкое применение в индустрии.</p>
</dd>
<dt>Интеллектные информационные системы.</dt>
<dd><p>Эти cистемы объединяют разнородные интеллектные системы (например, системы речевого общения, решения задач) для организации интеллектного доступа, обработки информации. Они, как правило, предназначены для работы с конечным пользователем низкой квалификации. Пример: электронные переводчики и разговорники.=-1</p>
</dd>
<dt>Восприятие и усвоение знаний.</dt>
<dd><p>Одна из задач ИИ – это приобретение знаний<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> (обучение, наполнение базы знаний) от человека или самостоятельно из среды функционирования. Системы усвоения знаний используются как подсистемы других интеллектных систем.</p>
</dd>
<dt>Интеллектное управление <span class="citation" data-cites="Vass:2000"></span>.</dt>
<dd><p>Новое направление, появившееся на стыке ИИ и теории управления, в котором разрабатываются управляющие системы, основанные на тех или иных методах ИИ. В настоящее время наиболее развиты методы управления на основе нечеткой логики и искусственных нейронных сетей. В этом новом направлении ведутся научные разработки Института динамики систем и теории управления СО РАН (<a href="http://www.idstu.irk.ru" class="uri">http://www.idstu.irk.ru</a>).</p>
</dd>
<dt>Робототехника (Robotics).</dt>
<dd><p>Собирательное направление исследований, задачей которого является автоматизация функционирования роботов, вплоть до полной независимости их от человека.</p>
</dd>
</dl>
<section id="определение-задач-ии-в-контексте-пособия." class="level5">
<h5><span class="header-section-number">1.1.2.0.1</span> Определение задач ИИ в контексте пособия.</h5>
<p>К сфере искусственного интеллекта относятся задачи, обладающие следующими свойствами <span class="citation" data-cites="Lauriere"></span>:</p>
<ul>
<li><p>в них используется информация в символьной форме: буквы, слова, знаки, рисунки. Это отличает область ИИ от областей, в которых традиционно компьютерам доверяется обработка данных в числовой форме<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>;</p></li>
<li><p>в них предполагается наличие выбора; действительно, сказать, что не существует алгоритма<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a>, – это значит сказать, по сути дела, только то, что нужно сделать выбор между многими вариантами в условиях неопределенности, и этот недетерминизм, который носит фундаментальный характер, эта свобода действия являются существенной составляющей интеллекта.</p></li>
</ul>
<p>Излагаемый в пособии курс подразумевает непосредственное изучение технических аспектов применения методов ИИ, таких как применимость того или иного метода в конкретной задаче, реализация программных модулей конкретного метода. Поэтому в предлагаемом курсе мы будем использовать следующее определение искусственного интеллекта:</p>
<blockquote>
<p><span><em>Искусственный интеллект</em></span> – область информатики, в которой разрабатываются и исследуются методы построения программных систем и решения задач, так или иначе связанных с принятием решения и обработкой символьной информации<a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a>.</p>
</blockquote>
</section>
</section>
<section id="данные-и-знания" class="level3">
<h3><span class="header-section-number">1.1.3</span> Данные и знания</h3>
<p>Одним из фундаментальных терминов ИИ является термин <span><em>знание</em></span>. Данный термин также является сложным в смысле его конструктивного определения, понятного читателю. Как правило, авторы статей по ИИ сознательно уклоняются давать более или менее точные определения, предполагая, что читателю это уже известно.</p>
<p>Более формальный термин &lt;&lt;данные&gt;&gt; получил широкое распространение в научно“=техническом обиходе, в особенности в практике использования ЭВМ для решения самых разнообразных задач <span class="citation" data-cites="AIDictionary"></span>. При этом вся обрабатываемая информация называется данными: начальными, промежуточными или конечными, входными или выходными. Для предложений естественного языка более привычны термин &lt;&lt;знание&gt;&gt; и глагол &lt;&lt;знать&gt;&gt;. Ни у кого не вызывает возражений использование этого слова в предложениях вроде &lt;&lt;Я знаю, как решить задачу&gt;&gt; или &lt;&lt;Я знаю, что вчера Петя встречался с Наташей&gt;&gt;. Сомнению может подвергаться лишь истинность подобных утверждений, но никак не возможность сочетания слова &lt;&lt;знать&gt;&gt; с фрагментами предложения, обозначающими любую информацию, о которой говорится, что она кому”=то известна.</p>
<p>Вопрос о разделении информации на данные и знания возник при разработке систем ИИ, характеризуемых в последнее время как системы, основанные на знаниях<a href="#fn6" class="footnoteRef" id="fnref6"><sup>6</sup></a>. Был предложен ряд определений, отражающих различные аспекты этих понятий, но касающихся скорее форм (см. раздел [sec:knowlege_repr]) представления данных и знаний, правил их использования, чем их сути.</p>
<section id="два-подхода-к-разработке-методов-и-средств-ии" class="level4 unnumbered">
<h4>Два подхода к разработке методов и средств ИИ</h4>
<dl>
<dt>&lt;&lt;Снизу вверх&gt;&gt;.</dt>
<dd><p>Суть подхода выражена в фразе &lt;&lt;<span><em>Давайте создадим механическое (вычислительное) устройство, похожее на (моделирующее) мозг человека, а затем посмотрим, как оно будет решать задачи ИИ</em></span>&gt;&gt;.</p>
</dd>
<dt>&lt;&lt;Сверху вниз&gt;&gt;.</dt>
<dd><p>В основе этого подхода лежит <span><em>разработка методов моделирования процесса мышления человека (логических выводов, логических рассуждений)</em></span>.</p>
</dd>
</dl>
<p>Методы и системы ИИ, основанные на подходе &lt;&lt;Снизу вверх&gt;&gt;, как правило, представляют собой сложную сеть взаимосвязанных, простых по сути, элементарных агентов. Эта сеть агентов формирует агента высокого уровня, направленного на решение конкретной задачи ИИ. Элементарные агенты сети вносят небольшой персональный вклад в решение агента высокого уровня. Выделяют одно из достоинств этого подхода: <span><em>если задача &lt;&lt;не решается&gt;&gt; какими-то формальными методами, то ее &lt;&lt;хоть какое-то&gt;&gt; решение может быть получено методами &lt;&lt;Снизу вверх&gt;&gt;</em></span>. Как правило, схема применения описываемых методов и систем состоит из двух этапов: <span><em>обучение</em></span> на известном наборе &lt;&lt;данные – решения&gt;&gt; (данные и решения известны) и <span><em>решения</em></span> новых задач (данные известны, решения – нет).</p>
<p>Известным недостатком, присущим методам и системам &lt;&lt;Снизу вверх&gt;&gt;, является неопределенность характеристик с точки зрения их практического применения: трудно ответить, например, на вопросы: &lt;&lt;Сколько нужно агентов, чтобы решить конкретную задачу? Каковы должны быть связи между агентами?&gt;&gt;. В каждом конкретном случае требуются эмпирические исследования (&lt;&lt;сможет–не сможет&gt;&gt;). Типичным представителем подхода &lt;&lt;Снизу вверх&gt;&gt; являются нейронные сети.</p>
<p>Моделирование логических выводов и рассуждений – основа подхода &lt;&lt;Сверху вниз&gt;&gt;. В системах ИИ (агентах), основывающихся на этом подходе, как правило, <span><em>четко выделяют</em></span> функциональные блоки &lt;&lt;Хранилище базы знаний&gt;&gt;, &lt;&lt;Машина логического вывода&gt;&gt; и интерфейс &lt;&lt;Рецептор–Блок рассуждений–Эффектор&gt;&gt;. В задачу последнего блока входит преобразование информации в/из вид (-а), используемый (-ого) в первых двух блоках. Именно в этих методах и системах ИИ возникает задача представления знаний в некотором формализованном виде, удобном для осуществления их интерпретации и преобразований в блоке &lt;&lt;Машина логического вывода&gt;&gt;. Примерами систем &lt;&lt;Сверху вниз&gt;&gt; выступают язык программирования Пролог, экспертные системы, системы автоматического логического вывода.</p>
<p>Исходя из общих соображений, естественно определить данные как некоторые сведения об отдельных объектах, а знания – о мире в целом. В согласии с таким подходом будем считать, что:</p>
<blockquote>
<p><span><em>данные</em></span> представляют информацию о существовании объектов с определенными комбинациями свойств (значений признаков), а <span><em>знания</em></span> – информацию о существующих в мире закономерных связях между признаками, запрещающих некоторые другие сочетания свойств у объектов.</p>
</blockquote>
<p>Отсюда следует, что различие между данными и знаниями можно сформулировать так: <span><em>данные</em></span> – это информация о существовании объектов с некоторым набором свойств, а <span><em>знания</em></span> – информация о несуществовании объектов с некоторым набором свойств<a href="#fn7" class="footnoteRef" id="fnref7"><sup>7</sup></a>.</p>
<p>Используя логический формализм (см. далее) представления знаний, продемонстрируем эти понятия в формализованном виде. Пусть <span class="math inline">\(H(x)\)</span> обозначает высказывание &lt;&lt;<span class="math inline">\(x\)</span> является человеком&gt;&gt;, а <span class="math inline">\(M(x)\)</span> – &lt;&lt;<span class="math inline">\(x\)</span> – смертен&gt;&gt;. Теперь представим данные как утверждения с кванторами существования (&lt;&lt;существует <span class="math inline">\(x\)</span>, <span class="math inline">\(x\)</span> является человеком&gt;&gt;): <span class="math display">\[A_1=\exists x H(x),\]</span> знания – утверждения с отрицанием существования (&lt;&lt;не существует бессмертных людей&gt;&gt;): <span class="math display">\[A_2=\neg\exists x \big ( H(x) \&amp; \neg M(x) \big ),\]</span> легко преобразуемые в утверждения с квантором всеобщности (&lt;&lt;все люди смертны&gt;&gt;): <span class="math display">\[A_3=\forall x \big ( H(x)\to M(x)\big ).\]</span> Запись знаний с использованием логической связки отрицания перед квантором всеобщности (как в формуле <span class="math inline">\(A_2\)</span>) не применяется на практике. Удобней и понятней форма <span class="math inline">\(A_3\)</span>, т. е. форма с квантором всеобщности, утверждающим, что все объекты <span class="math inline">\(x\)</span>, обладающие свойством <span class="math inline">\(H\)</span>, будут обладать свойством <span class="math inline">\(M\)</span>.</p>
<p>В формулах некоторые объекты удобно задавать именами. Например, утверждение &lt;&lt;Сократ – человек&gt;&gt; представляется в виде формулы <span class="math inline">\(H(s)\)</span>, где <span class="math inline">\(s\)</span> обозначает Сократа. Теперь продемонстрируем процесс обработки информации с использованием формализованного знания <span class="math inline">\(A_3\)</span> и исходного данного <span class="math inline">\(H(s)\)</span>: <span class="math display">\[\Big (H(s) \&amp; \forall x \big ( H(x)\to M(x)\big ) \Big ) \to M(s).\]</span> Из того, что Сократ – человек и что все люди смертны, следует, что Сократ тоже смертен. Доказательство &lt;&lt;от противного&gt;&gt; предлагается построить читателю самостоятельно.</p>
<p>В конце книги <span class="citation" data-cites="DDWII"></span> данные и знания (совместно с &lt;&lt;умениями&gt;&gt;) охарактеризованы следующим образом.</p>
<p><span><em>Данные</em></span> должны прежде всего храниться, а затем в порядке убывания приоритетов для непосредственной применимости успешно находиться при нужде, проверяться, поддерживаться в порядке и обновляться при необходимости. Таким образом, они хранятся неизменными, пока не будут явно обновлены, и поэтому обычно внимание уделяют прежде всего сохранению, поддержанию их адекватности меняющемуся состоянию дел и целостности при необходимых изменениях.</p>
<p><span><em>Знания</em></span> должны прежде всего преобразовываться. Далее, их нужно хранить, как и данные, они должны быть доступными, они должны конкретизироваться применительно к данной ситуации и обобщаться для целого класса применений. Они, конечно же, должны при необходимости пересматриваться. И, наконец, они должны переводиться с одного языка на другой.</p>
<p><span><em>Умения</em></span> прежде всего применяются. Помимо этого, они преобразуются для обеспечения гибкости или приспособления к изменившимся условиям. Далее они обобщаются и пересматриваются.</p>
<p>В процессе исследований природных явлений ученые сначала накапливают информацию в виде данных, выделяя объекты и выявляя и измеряя их свойства. Знания – результат обработки данных и их обобщения. Классическим примером данных служат таблицы движения планет по небесному своду Тихо Браге, примером знаний – выведенные из них законы Иоганна Кеплера и затем, как обобщение результатов Кеплера, закон всемирного тяготения Исаака Ньютона.</p>
</section>
</section>
</section>
<section id="sec:knowlege_repr" class="level2">
<h2><span class="header-section-number">1.2</span> Формализмы представления знаний</h2>
<p>В интеллектуальных системах используются различные формализмы<a href="#fn8" class="footnoteRef" id="fnref8"><sup>8</sup></a> представления знаний – <span><em>логический</em></span>, <span><em>сетевой</em></span>, <span><em>продукционный</em></span> и <span><em>фреймовый</em></span>.</p>
<p>Логический формализм традиционно применяется для реализации систем автоматического доказательства теорем, логических языков и сред программирования и экспертных систем. Сетевой формализм удобен в решении задач поддержки диалога с пользователем на естественном языке, формализации концептуального уровня предметной области (онтологий). Сетевой формализм совместно с логическим формализмом в настоящее время используется для верификации онтологий и построения логического вывода новых знаний и данных из указанного концептуального уровня.</p>
<p>Основная область применения продукционного формализма – описание баз знаний экспертных систем, систем поддержки принятия решений. Знания в продукционной модели представляются в виде утверждений &lt;&lt;Если …, то …&gt;&gt;, база знаний – это множество таких утверждений. Отдельные утверждения в базе знаний можно удалять и добавлять новые, и если множество утверждений достаточно большое, то небольшие его изменения не влияют на общую работоспособность программной системы. То есть продукционный формализм удобен, если необходимо проводить эксперименты с логическим описанием предметной области <em>системы, основанной на знаниях</em>.</p>
<p>Фреймовый формализм в некоторой степени схож с объектами в прототипных объектноориентированных языках программирования, например JavaScript, Self. В основе формализма лежит идея декомпозиции предметной области на отдельные концепты и объекты, объединенные в иерархию, представления их в виде набора атрибутов. Каждый концепт и объект является набором слотов. Слоты состоят из описания и значения, значение должно соответствовать описанию или отсутствовать. Решение задачи распознавания на фреймовом формализме заключается в выявлении фрейма, лучшим образом соответствующего распознаваемому объекту.</p>
<p>Мы не будем далее подробно формально описывать формализмы в этом учебном пособии, познакомимся с их особенностями по мере необходимости и только в нужном объеме. Считается, что все формализмы эквивалентны, т. е. знания из одного формализма интерпретируются полноценно в другом формализме (тезис Черча).</p>
</section>
</section>
<section id="логические-модели-и-логическое-программирование" class="level1">
<h1><span class="header-section-number">2</span> Логические модели и логическое программирование</h1>
<p>Самой известной системой ИИ, использующей логический формализм, является язык логического программирования (Пролог) <span class="citation" data-cites="Bratko"></span>, который будет предметом нашего дальнейшего изучения. Название &lt;&lt;Пролог&gt;&gt; образовано из слияния терминов: &lt;&lt;ПРОграммирование в терминах ЛОГики&gt;&gt;. Пролог относится к классу языков, называемых <em>сентенциальными</em>. Классические реализации Пролога используются в вузах мира для обучения студентов методам автоматизации рассуждений. Специальные версии этого языка, например Prolog&quot;=III, являются дорогими коммерческими продуктами и предназначаются для решения комбинаторных задач с удовлетворением ограничений. К таким задачам относятся задачи раскроя материала, составление расписаний, задачи проектирования сетей изготовления и распространения продукции (задачи логистики).</p>
<p>Программа на языке Prolog представляет собой набор логических высказываний (утверждений), называемых <em>фразами</em> (<span><em></em></span>):</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">    h(s)<span class="kw">.</span>              <span class="co">% Сократ - человек.</span>
    m(<span class="dt">X</span>) <span class="kw">:-</span> h(<span class="dt">X</span>)<span class="kw">.</span>      <span class="co">% Все люди смертны.</span></code></pre></div>
<p>Каждая фраза завершается точкой<a href="#fn9" class="footnoteRef" id="fnref9"><sup>9</sup></a> &lt;&lt;<code>.</code>&gt;&gt;. В приведенном примере первое высказывание <code>h(s)</code> является <em>фактом</em>, которому интерпретатор языка &lt;&lt;верит&gt;&gt; по определению. Второе высказывание (&lt;&lt;Все люди смертны&gt;&gt;) – это <em>правило</em>. Правило состоит из <em>головы</em> <code>m(X)</code> и <em>тела</em> <code>h(X)</code>. Знак &lt;&lt;<code>:-</code>&gt;&gt; обозначает логическую связку &lt;&lt;<span class="math inline">\(\leftarrow\)</span>&gt;&gt; и читается как &lt;&lt;если&gt;&gt;. Правило связывает истинность высказывания, представленного в теле, с истинностью высказывания в голове: высказывание в голове правила истинно, если истинно высказывание в теле правила.</p>
<p>Идентификаторы в Prolog бывают двух видов. С маленькой буквы<a href="#fn10" class="footnoteRef" id="fnref10"><sup>10</sup></a> начинаются идентификаторы, обозначающие что&quot;=то конкретное. В нашем примере идентификатор <code>s</code> обозначает Сократа, т. е. конкретный объект; <code>h</code> и <code>m</code> обозначают свойства аргумента &lt;&lt;быть человеком&gt;&gt; и &lt;&lt;быть смертным&gt;&gt; соответственно. Эти обозначения не меняются в процессе исполнения программы и в языке Prolog называются <em>атомами</em><a href="#fn11" class="footnoteRef" id="fnref11"><sup>11</sup></a>. Атомы также можно задавать при помощи строк в одинарных кавычках, например <code>’Российская Федерация’</code>. Такая форма записи позволяет использовать в качестве атомов любые строки.</p>
<p>Голова правила и атомарные высказывания, составляющие тело правила, строятся при помощи идентификаторов, обозначающих высказывания и называемых <em>предикатами</em><a href="#fn12" class="footnoteRef" id="fnref12"><sup>12</sup></a>. Высказывания <code>m(s)</code> и <code>h(s)</code> построены на основе предикатов <span class="math inline">\(m(x)\)</span> и <span class="math inline">\(h(x)\)</span>. В Prolog при обозначении предикатов переменные <span class="math inline">\(x\)</span>, <span class="math inline">\(y\)</span> и т. п. не используются, указывается только количество аргументов при помощи символа &lt;&lt;<code>/</code>&gt;&gt; (слеш): <code>h/1</code>, <code>m/1</code>.</p>
<p>Идентификаторы, начинающиеся с большой (прописной) буквы, – <em>переменные</em>. Значения переменных в общем случае меняются: в переменную в процессе исполнения программы подставляются объекты, структуры и другие переменные. В нашей программе в правиле используется одна переменная <code>X</code>. Существует специальный случай – переменная &lt;&lt;<code>_</code>&gt;&gt; (подчерк), при помощи которой обозначают никому не нужные значения, мы их будем использовать позже. С подчерка также начинаются названия переменных, например <code>_language</code>.</p>
<p>Приводимые в методическом пособии примеры демонстрируются на платформе интерпретатора SWI-Prolog <span class="citation" data-cites="SWIP"></span>. Интерпретатор доступен в Интернете и является полностью свободным. Если интересно, то можно загрузить и изучить его исходный код. Домашняя страница находится по адресу: <a href="http://www.swi-prolog.org/" class="uri">http://www.swi-prolog.org/</a>. На одной из страниц сайта есть ссылка на версию SWISH&quot;=интерпретатора, функционирующую онлайн. Кроме того, на сайте размещена ссылка на обучающий материал по тематике логического программирования: <a href="http://www.learnprolognow.org/" class="uri">http://www.learnprolognow.org/</a>.</p>
<p>Чтобы запустить программу, необходимо ее загрузить в интерпретатор и сделать запрос:</p>
<p>?- [’socrates.pl’]. ?- m(s). true. ?- _</p>
<p>В приведенном примере &lt;&lt;<code>?-</code>&gt;&gt; обозначает приглашение к вводу пользователем запроса. Запросы – это тоже фразы языка, поэтому тоже заканчиваются точкой. Запрос специального вида <code>[’socrates.pl’]</code> загружает программу из файла <code>socrates.pl</code>, который должен находиться в той же папке, где был запущен интерпретатор. Фраза <code>m(s)</code> – это запрос к интерпретатору: &lt;&lt;Правда ли, что Сократ смертен?&gt;&gt; Ответ <code>true</code> или <code>yes</code> является результатом рассуждений интерпретатора над запросом, результатом доказательства его истинности. В последней строке примера подчерком показан курсор, т. е. интерпретатор находится в режиме ожидания ввода нового запроса. Запрос загрузки программы и последнюю строку с курсором далее не будем приводить в коде программы.</p>
<p>Интерпретатор Prolog не может вывести истинность некоторого запроса в двух случаях:</p>
<ul>
<li><p>в процессе поиска логического вывода невозможно найти подходящий факт, от которого зависит истинность нужного тела правила;</p></li>
<li><p>логический вывод уходит в бесконечную рекурсию.</p></li>
</ul>
<p>В первом случае Prolog выдает <code>false</code> или <code>no</code> и считает, что утверждение запроса ложно. Во втором случае необходимо прерывать работу интерпретатора при помощи комбинации клавиш</p>
<p>(key)</p>
<p> Ctrl&quot;=C </p>
<p>;</p>
<p>или</p>
<p>(key)</p>
<p> Ctrl&quot;=Break </p>
<p>;</p>
<p>в Windows&quot;=версии интерпретатора.</p>
<p>Процесс логического вывода запроса отслеживается средствами трассировки, встроенными в интерпретатор. Рассмотрим трассировку исполнения запроса к нашей программе:</p>
<p>?- trace. true.</p>
<p>[trace] ?- m(s). Call: (6) m(s) ? Call: (7) h(s) ? Exit: (7) h(s) ? Exit: (6) m(s) ? true.</p>
<p>[trace] ?- nodebug. true.</p>
<p>Предикаты <code>trace/0</code>, <code>notrace/0</code>, <code>debug/0</code> и <code>nodebug/0</code> управляют процессом трассировки и отладки. Текущий режим интерпретатора отображается строкой <code>[trace] ?-</code>. В режиме трассировки программа выполняется пошагово. Каждому шагу соответствует одна строка трассировки. В строке слова <code>Call:</code> и <code>Exit:</code> обозначают команды, выполняемые интерпретатором. Команда <code>Call:</code> показывает, истинность какого запроса (подзапроса) требуется доказать на очередном шаге; <code>Exit:</code> показывает, что соответствующий запрос успешно доказан.</p>
<p>Приведенный пример – это далеко не полный перечень возможностей языка программирования Prolog. Остальные его свойства будем рассматривать по мере необходимости при решении конкретных задач. Хорошим толковым учебником по языку является книга профессора Люблянского университета Ивана Братко <span class="citation" data-cites="Bratko"></span>. Следующий абзац посвящен вопросам редактирования и загрузки программы. Если вы уже умеете это делать, то переходите сразу на стр. . Далее будем обозначать такие переходы следующим образом:<span><span class="math inline">\(\,\hookrightarrow\)</span></span>.</p>
<section id="редактирование-и-загрузка-программы." class="level5">
<h5><span class="header-section-number">2.0.0.0.1</span> Редактирование и загрузка программы.</h5>
<p>Многие ISO&quot;=совместимые реализации интерпретатора языка Prolog имеют встроенные графические оконные интерфейсы. При помощи этих средств можно редактировать и загружать программы, используя манипулятор мышь. В применяемом в данном пособии интерпретаторе SWI-Prolog также есть эти средства. В версии Windows редактирование программ Пролога доступно через меню оконного приложения. Встроенный редактор представляет собой упрощенную реализацию системы EMACS. Редактор вызывается из командной строки интерпретатора запуском предиката <code>emacs</code>, в том числе и в реализации Linux.</p>
<p>В классических реализациях языка Пролог введение списка утверждений в Пролог&quot;=систему осуществляется при помощи встроенного предиката <span>consult/1</span>. Единственным аргументом этого предиката <span>consult/1</span> является атом, который интерпретируется системой как имя файла, содержащего текст программы на Прологе. Файл открывается, и его содержимое записывается<a href="#fn13" class="footnoteRef" id="fnref13"><sup>13</sup></a> в базу знаний. Если в файле встречаются управляющие команды, они сразу же выполняются. Возможен случай, когда файл не содержит ничего, кроме управляющих команд, например для загрузки других файлов. Для ускорения набора команды загрузки пользователи Пролога изобрели для себя следующую конструкцию, являющуюся синонимом предикату <span>consult/1</span>:</p>
<p>?- [’имя файла.pl’].</p>
<p>Работая с вышеупомянутым редактором, программу можно загрузить прямо из его окна при помощи комбинации клавиш</p>
<p>(key)</p>
<p> Ctrl-c </p>
<p>;</p>
<p>,</p>
<p>(key)</p>
<p> Ctrl-b </p>
<p>;</p>
<p>(). Выход из редактора и закрытие его окна осуществляется комбинацией</p>
<p>(key)</p>
<p> Ctrl-x </p>
<p>;</p>
<p>,</p>
<p>(key)</p>
<p> Ctrl-c </p>
<p>;</p>
<p>, запись редактируемого буфера –</p>
<p>(key)</p>
<p> Ctrl-x </p>
<p>;</p>
<p>,</p>
<p>(key)</p>
<p> Ctrl-s </p>
<p>;</p>
<p>.</p>
</section>
</section>
<section id="sec:tasksolving" class="level1">
<h1><span class="header-section-number">3</span> Планирование действий</h1>
<p>Рассмотрим задачу поиска выхода из лабиринта, точнее задачу прокладки пути между двумя разными комнатами в лабиринте. В качестве примера будем использовать карту лабиринта, изображенную на рис. [fig:labyrinth], <em>a</em>.</p>
<p><em></em></p>
<p>(1,0.37144355) (0,0)<span><embed src="maze.pdf" title="fig:" /></span> (0.40963855,0.10638325)<span>(0,0)[b]</span> (0.5060241,0.10638325)<span>(0,0)[b]</span> (0.60240964,0.10638325)<span>(0,0)[b]</span> (0.40963855,0.20276879)<span>(0,0)[b]</span> (0.5060241,0.20276879)<span>(0,0)[b]</span> (0.60240964,0.20276879)<span>(0,0)[b]</span> (0.40963855,0.29915434)<span>(0,0)[b]</span> (0.5060241,0.29915434)<span>(0,0)[b]</span> (0.60240964,0.29915434)<span>(0,0)[b]</span> (0,0)<span><embed src="maze.pdf" title="fig:" /></span> (0.74698795,0.11120254)<span>(0,0)[b]</span> (0.74698795,0.20758808)<span>(0,0)[b]</span> (0.74698795,0.30397362)<span>(0,0)[b]</span> (0.84337349,0.11120254)<span>(0,0)[b]</span> (0.84337349,0.20758808)<span>(0,0)[b]</span> (0.84337349,0.30397362)<span>(0,0)[b]</span> (0.93975904,0.11120254)<span>(0,0)[b]</span> (0.93975904,0.20758808)<span>(0,0)[b]</span> (0.93975904,0.30397362)<span>(0,0)[b]</span> (0,0)<span><embed src="maze.pdf" title="fig:" /></span> (0.17034886,0.00571819)<span>(0,0)[b]</span> (0.5060241,0.00571819)<span>(0,0)[b]</span> (0.84337349,0.00571819)<span>(0,0)[b]</span></p>
<p>Формализуем задачу. Сначала каждую комнату каким&quot;=нибудь образом обозначим. Первый вариант обозначения состоит в использовании двоек <span class="math inline">\(\langle x,y\rangle\)</span>, <span class="math inline">\(x\)</span> и <span class="math inline">\(y\)</span> – координаты комнаты (рис. [fig:labyrinth], <em>b</em>). В Prolog двойки удобно обозначать в форме <code>X/Y</code>, так как запятая используется в перечислении аргументов предикатов. Если факт наличия проема или двери (перехода) между двумя комнатами <code>A</code> и <code>B</code> обозначить предикатом <code>e(A,B)</code>, то следующая программа, набор фактов, будет представлять структуру нашего лабиринта:</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">e(<span class="dv">1</span><span class="fu">/</span><span class="dv">3</span><span class="kw">,</span><span class="dv">1</span><span class="fu">/</span><span class="dv">2</span>)<span class="kw">.</span> e(<span class="dv">1</span><span class="fu">/</span><span class="dv">2</span><span class="kw">,</span><span class="dv">1</span><span class="fu">/</span><span class="dv">1</span>)<span class="kw">.</span> e(<span class="dv">1</span><span class="fu">/</span><span class="dv">1</span><span class="kw">,</span><span class="dv">2</span><span class="fu">/</span><span class="dv">1</span>)<span class="kw">.</span>
e(<span class="dv">2</span><span class="fu">/</span><span class="dv">1</span><span class="kw">,</span><span class="dv">2</span><span class="fu">/</span><span class="dv">2</span>)<span class="kw">.</span> e(<span class="dv">2</span><span class="fu">/</span><span class="dv">2</span><span class="kw">,</span><span class="dv">2</span><span class="fu">/</span><span class="dv">3</span>)<span class="kw">.</span> e(<span class="dv">2</span><span class="fu">/</span><span class="dv">3</span><span class="kw">,</span><span class="dv">3</span><span class="fu">/</span><span class="dv">3</span>)<span class="kw">.</span>
e(<span class="dv">2</span><span class="fu">/</span><span class="dv">1</span><span class="kw">,</span><span class="dv">3</span><span class="fu">/</span><span class="dv">1</span>)<span class="kw">.</span> e(<span class="dv">3</span><span class="fu">/</span><span class="dv">1</span><span class="kw">,</span><span class="dv">3</span><span class="fu">/</span><span class="dv">2</span>)<span class="kw">.</span> e(<span class="dv">3</span><span class="fu">/</span><span class="dv">2</span><span class="kw">,</span><span class="dv">3</span><span class="fu">/</span><span class="dv">3</span>)<span class="kw">.</span></code></pre></div>
<p>Другим вариантом обозначения комнат является использование имен (&lt;&lt;гостиная&gt;&gt;, &lt;&lt;логово дракона&gt;&gt;) или просто букв <em>a</em>, <em>b</em>, <em>c</em> и т. д. (рис. [fig:labyrinth], <em>c</em>). Тогда набор фактов приобретет более лаконичный вид, но в этом случае теряется часть информации об относительном расположении комнат. Хорошо, что она нам не понадобится.</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">e(a<span class="kw">,</span>b)<span class="kw">.</span> e(b<span class="kw">,</span>c)<span class="kw">.</span> e(c<span class="kw">,</span>f)<span class="kw">.</span>
e(f<span class="kw">,</span>e)<span class="kw">.</span> e(e<span class="kw">,</span>d)<span class="kw">.</span> e(d<span class="kw">,</span>h)<span class="kw">.</span>
e(f<span class="kw">,</span>g)<span class="kw">.</span> e(g<span class="kw">,</span>i)<span class="kw">.</span> e(i<span class="kw">,</span>h)<span class="kw">.</span></code></pre></div>
<p>Теперь надо системе Prolog объяснить, как прокладывать пути между комнатами, точнее что такое путь между двумя комнатами.</p>
<ol>
<li><p>Между двумя комнатами существует путь, если между этими комнатами есть переход.</p></li>
<li><p>Между двумя комнатами <code>A</code> и <code>B</code> существует путь, если из комнаты <code>A</code> можно перейти в еще одну комнату <code>C</code>, а из нее построить путь в <code>B</code>.</p></li>
</ol>
<p>Запишем это на языке Prolog, дополнив одну из предыдущих формализаций лабиринта:</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">path(<span class="dt">A</span><span class="kw">,</span><span class="dt">B</span>) <span class="kw">:-</span> e(<span class="dt">A</span><span class="kw">,</span><span class="dt">B</span>)<span class="kw">.</span>
path(<span class="dt">A</span><span class="kw">,</span><span class="dt">B</span>) <span class="kw">:-</span> e(<span class="dt">A</span><span class="kw">,</span><span class="dt">C</span>)<span class="kw">,</span> path(<span class="dt">C</span><span class="kw">,</span><span class="dt">B</span>)<span class="kw">.</span></code></pre></div>
<p>Запрос, соответствующий решению задачи прокладки пути, будет следующим:</p>
<p>?- path(a,h). true ; true ; false.</p>
<p>Программа выдала два положительных ответа и один <code>false</code>. Структура нашего лабиринта допускает наличие двух путей от входа к выходу. На каждый положительный ответ интерпретатор ожидает команды пользователя: требуется ли ему еще один ответ (</p>
<p>(key)</p>
<p> ; </p>
<p>;</p>
<p>,</p>
<p>(key)</p>
<p> Enter </p>
<p>;</p>
<p>) или нет (</p>
<p>(key)</p>
<p> Enter </p>
<p>;</p>
<p>). В системе <code>gprolog</code> (GNU Prolog) <span class="citation" data-cites="GNUP"></span> есть вариант</p>
<p>(key)</p>
<p> a </p>
<p>;</p>
<p>, который выдает на экран все решения. Использовать его надо с осторожностью, так как программа может порождать бесконечное количество вариантов решения задачи.</p>
<p>В программе появились новые синтаксические конструкции. Истинность высказывания в голове второго правила теперь зависит от двух предикатов <code>e/2</code> и <code>path/2</code>, соединенных запятой &lt;&lt;<code>,</code>&gt;&gt;, которая обозначает конъюнкцию: надо, чтобы одновременно и <code>e(A,C)</code>, и <code>path(C,B)</code> были истинны. Далее, истинность <code>path(a,h)</code> выводится из двух разных правил. Пролог просматривает правила последовательно сверху вниз справа налево по тексту программы. Сначала будет осуществлена попытка вывести <code>path(a,h)</code> из первого короткого правила, что невозможно, так как <code>e(a,h)</code> отсутствует в наборе фактов. Затем Prolog попытается вывести <code>path(a,h)</code> из второго правила, что приведет к необходимости решать две связанные <em>подзадачи</em>, достигать две <em>подцели</em>, исполнять два <em>подзапроса</em>: <code>e(a,C)</code> и <code>path(C,h)</code>. Задача <code>e(a,C)</code> решается, если <code>C = b</code>, и тогда остается решить подзадачу <code>path(C,h)</code> при <code>C = b</code>, т. е. <code>path(b,h)</code>. Подзапрос <code>path(b,h)</code> доказывается аналогично запросу <code>path(a,h)</code>: интерпретатор рекурсивно строит решение задачи.</p>
<p>Рассмотрим трассировку задачи <code>path(a,c)</code>, решаемой за два перехода:</p>
<p>?- trace,path(a,c). Call: (7) path(a, c) ? Call: (8) e(a, c) ? Fail: (8) e(a, c) ? Redo: (7) path(a, c) ? Call: (8) e(a, _G1450) ? Exit: (8) e(a, b) ? Call: (8) path(b, c) ? Call: (9) e(b, c) ? Exit: (9) e(b, c) ? Exit: (8) path(b, c) ? Exit: (7) path(a, c) ? true ; Redo: (8) path(b, c) ? Call: (9) e(b, _G1450) ? Exit: (9) e(b, c) ? Call: (9) path(c, c) ? Call: (10) e(c, c) ? Fail: (10) e(c, c) ? Redo: (9) path(c, c) ? . . . . .</p>
<p>В этом примере появились две новые команды <code>Redo:</code> и <code>Fail:</code>, соответственно обозначающие попытку вывести истинность запроса из следующего по списку правила и неудачное завершение поиска доказательства запроса. В точке (1) <code>Fail:</code> показывает, что утверждение <code>e(a,c)</code> отсутствует в списке фактов. Это приводит к необходимости (2) перейти к следующему правилу <code>Redo:</code>. Задача <code>e(a, _G1450)</code> то же самое, что и <code>e(a,C)</code>, только переменная <code>C</code> переименована в <code>_G1450</code>: каждый &lt;&lt;запуск&gt;&gt; правила требует разыменования используемых в нем переменных. В строке (4) Prolog выдает первый положительный ответ, а пользователь просит предоставить еще один. Далее происходит достаточно длинный перебор вариантов переменной <code>_G1450</code>, который не приводит к новому решению, и интерпретатор выдает <code>false</code>.</p>
<section id="специальные-запросы." class="level5">
<h5><span class="header-section-number">3.0.0.0.1</span> Специальные запросы.</h5>
<p>В английском языке выделяются пять видов вопросов: общие (Do You …?), разделительные (You are …, ain’t You?), специальные (What do You do?), к подлежащему (Who is …?) и &lt;&lt;или&gt;&gt;-вопрос (Do you like coffe or tea?). Первые два класса вопросов в Прологе представляются запросами, где в параметрах не используются переменные, например <code>path(a,h)</code> и <code>e(a,b)</code>. Специальные вопросы и вопросы к подлежащему, помимо ответа на вопрос &lt;&lt;Так это или нет?&gt;&gt;, нацелены на получение дополнительной информации: &lt;&lt;Кто?&gt;&gt;, &lt;&lt;Когда?&gt;&gt; и т. д. В Прологе такие вопросы формулируются в виде запросов с использованием переменных:</p>
<p>?- path(a,X). X = b ; X = c ; X = f ; X = e ; X = g ; . . . . false.</p>
<p>Запрос соответствует вопросу &lt;&lt;Куда можно попасть, войдя в лабиринт?&gt;&gt;. Дополнительная информация, получаемая пользователем, – значения переменной <code>X</code>, при которых запрос, ограничение на значение <code>X</code>, истинен. &lt;&lt;Или&gt;&gt;-вопросы в Prolog задавать и неестественно, и не принято <code>;-)</code> .</p>
<p>Программа работает правильно, но нам мало, чтобы программа просто показывала, существует ли путь между двумя комнатами лабиринта. Хотелось бы, чтобы программа также показывала сам путь. Для того чтобы представить путь как последовательность комнат лабиринта, нужно к нашим знаниям добавить еще одну структуру данных – <em>список</em>. <span><span class="math inline">\(\,\hookrightarrow\)</span></span></p>
</section>
<section id="списки" class="level2">
<h2><span class="header-section-number">3.1</span> Списки</h2>
<p>Задачи, связанные с обработкой списков, на практике встречаются очень часто. Скажем, нам понадобилось составить список студентов, находящихся в аудитории. В Prolog список определяется как последовательность <em>термов</em><a href="#fn14" class="footnoteRef" id="fnref14"><sup>14</sup></a>, заключенных в квадратные скобки. Приведем примеры списков Пролога:</p>
<p>[jack, john, fred, jill, john] [name(john, smith), age(jack, 24), X] [Х, У, date(12, january, 1986), Х] []</p>
<p>Запись специального вида определяет новый список, где <span>Н</span> – первый (левый) элемент нового списка, а <span>Т</span> – его остальные элементы. Говорят, что <span>Н</span> – голова, а <span>Т</span> – хвост списка .</p>
<p>На запрос</p>
<p>?- L=[a | [b, c, d]].</p>
<p>будет получен ответ</p>
<p>L=[a, b, c, d],</p>
<p>а на запрос</p>
<p>?- T=[a, b, c, d], L=[2 | T].</p>
<p>получим ответ</p>
<p>T=[a, b, c, d], L=[2, a, b, c, d].</p>
<p>Запись используется и в обратную сторону, для того чтобы определить голову и хвост списка. Так, запрос</p>
<p>[H | T]=[a, b, c].</p>
<p>дает ответ</p>
<p>H = а, T = [b, c].</p>
<p>Заметим, что употребление только имен переменных <span>Н</span> и <span>Т</span> необязательно. Кроме записи вида , для выборки термов используются переменные. Запрос</p>
<p>?- [a, X, Y]=[a, b, c].</p>
<p>определит значения</p>
<p>X=b, Y=c,</p>
<p>запрос</p>
<p>?- [person(Х) | Т]=[person(john), а, b].</p>
<p>значения</p>
<p>Х=john, Т=[а, b].</p>
<p>Можно отделять в голове списка несколько элементов, соответствующая запись выглядит так: <span>L=[H1, H2, H3 | T]</span>. Пустой список задается так: &lt;&lt;<code>[]</code>&gt;&gt;.</p>
<section id="par:mazelist" class="level5">
<h5><span class="header-section-number">3.1.0.0.1</span> Возвращаемся к лабиринту.</h5>
<p>Далее будем использовать списки для хранения пути в лабиринте. Для этого введем третий параметр в предикат <code>path/2</code>:</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">path(<span class="dt">A</span><span class="kw">,</span><span class="dt">B</span><span class="kw">,</span> [<span class="dt">A</span><span class="fu">-</span><span class="dt">B</span>]) <span class="kw">:-</span> e(<span class="dt">A</span><span class="kw">,</span><span class="dt">B</span>)<span class="kw">.</span>
path(<span class="dt">A</span><span class="kw">,</span><span class="dt">B</span><span class="kw">,</span> [<span class="dt">A</span><span class="fu">-</span><span class="dt">C</span><span class="fu">|</span><span class="dt">T</span>]) <span class="kw">:-</span> e(<span class="dt">A</span><span class="kw">,</span><span class="dt">C</span>)<span class="kw">,</span> path(<span class="dt">C</span><span class="kw">,</span><span class="dt">B</span><span class="kw">,</span><span class="dt">T</span>)<span class="kw">.</span></code></pre></div>
<p>Новые правила можно добавлять к предыдущей программе, так как Prolog воспринимает одноименные предикаты с разным количеством аргументов как самостоятельные. Предикаты <code>path/2</code> и <code>path/3</code> формируют в данной программе свои независимые множества правил. Выполним запрос на поиск путей, соединяющих вход и выход лабиринта:</p>
<p>?- path(a,h,L). L = [a-b, b-c, c-f, f-e, e-d, d-h] ; L = [a-b, b-c, c-f, f-g, g-i, i-h] ; false.</p>
<p>Результат совпадает с ожидаемым (рис. [fig:labyrinth], <em>a</em>) и представляется списком переходов, формирующих путь. Каждый переход обозначен структурой вида <code>A-B</code>, где <code>A</code> и <code>B</code> – вершины графа структуры лабиринта, соединенные дугой. Можно представить результат просто списком вершин:</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">path2(<span class="dt">A</span><span class="kw">,</span><span class="dt">B</span><span class="kw">,</span> [<span class="dt">A</span>,<span class="dt">B</span>]) <span class="kw">:-</span> e(<span class="dt">A</span><span class="kw">,</span><span class="dt">B</span>)<span class="kw">.</span>
path2(<span class="dt">A</span><span class="kw">,</span><span class="dt">B</span><span class="kw">,</span> [<span class="dt">A</span><span class="fu">|</span><span class="dt">T</span>]) <span class="kw">:-</span> e(<span class="dt">A</span><span class="kw">,</span><span class="dt">C</span>)<span class="kw">,</span> path2(<span class="dt">C</span><span class="kw">,</span><span class="dt">B</span><span class="kw">,</span><span class="dt">T</span>)<span class="kw">.</span></code></pre></div>
<p>Выполним запрос к новому предикату <code>path2/3</code>:</p>
<p>?- path2(a,h,L). L = [a, b, c, f, e, d, h] ; L = [a, b, c, f, g, i, h] ; false.</p>
</section>
<section id="коллекционирование-решений." class="level5">
<h5><span class="header-section-number">3.1.0.0.2</span> Коллекционирование решений.</h5>
<p>Если есть необходимость собрать коллекцию всех решений, обладающих некоторым свойством, используются предикаты <code>bagof/3</code>, <code>setof/3</code> и <code>findall/3</code>. Спецификации интерфейсов этих предикатов схожи, рассмотрим их, как обычно, на примере:</p>
<p>?- findall(X, path2(a,h,X), L). L = [[a, b, c, f, e, d, h], [a, b, c, f, g, i, h]].</p>
<p>Предикат формирует список <code>L</code> путей&quot;=решений, т. е. список <code>L</code> таких <code>X</code>, что справедлив запрос <code>path2(a,h,X)</code>. Предикат <code>findall/3</code> истинен всегда, даже если нет ни одного <code>X</code>, такого, что <code>path2(a,h,X)</code> истинен. В последнем случае <code>findall/3</code> выдает <code>L=[]</code> (пустой список), а вот <code>bagof/3</code> и <code>setof/3</code> потерпят неудачу (будут ложными). Предикат <code>setof/3</code> отличается от других еще и тем, что из выходного списка будут удалены повторения.</p>
</section>
</section>
<section id="sec:problemsolving" class="level2">
<h2><span class="header-section-number">3.2</span> Алгоритмы планирования действий</h2>
<p>Задача поиска пути в лабиринте – простейший пример класса задач <em>планирования действий</em>. В общих словах задача относится к этому классу, если выполняются следующие условия:</p>
<ol>
<li><p>выделяется не обязательно конечный набор <em>допустимых состояний</em>, т. е. состояний, не противоречащих природе и условиям задачи;</p></li>
<li><p>состояния соединяются <em>переходами</em> (не обязательно двунаправленными). Эти переходы задаются набором правил, не противоречащих условиям задачи;</p></li>
<li><p>задается <em>логическое условие</em> <span class="math inline">\(P(x)\)</span>, <em>распознающее целевые состояния</em> <span class="math inline">\(x\)</span>;</p></li>
<li><p>среди допустимых состояний выделяется одно, в котором система находится в начальный момент, т. е. <em>исходное состояние</em>.</p></li>
</ol>
<p>Решением задачи планирования действий является построение последовательности логически связанных действий, которые необходимо выполнить, чтобы перевести систему из начального состояния в одно из целевых.</p>
<p>Математическая структура, позволяющая формализовать этот класс задач, строится на основе графа, называемого <em>графом пространства состояний</em> (<span><em></em></span>): <span class="math display">\[G=\langle V,E, P(x), s\rangle,\]</span> где <span class="math inline">\(V\)</span> – множество допустимых состояний (вершины графа), <span class="math inline">\(E\)</span> – переходы (дуги графа, соединяющие вершины), а <span class="math inline">\(s\)</span> – начальное состояние (стартовая вершина графа). В такой формализации решением задачи планирования действий является <em>путь</em>, соединяющий исходное состояние в один из целевых. При этом, как правило, интересует не просто поиск решения, а поиск лучшего или оптимального решения, характеризующегося, например, минимальным количеством переходов между смежными вершинами.=-1</p>
<p>Алгоритмы поиска пути в графе с заданными свойствами определяются <em>стратегиями перебора</em> неизвестных вершин, видимых из области графа с уже известными вершинами (рис. [fig:searchdescr], <em>a</em>).</p>
<p><em></em></p>
<p>(1,0.33775965) (0,0)<span><embed src="searchdescr.pdf" title="fig:" /></span> (0.06490497,0.37943621)</p>
<p>(0,0)[lt]</p>
<p> </p>
<p>(0,0)<span><embed src="searchdescr.pdf" title="fig:" /></span> (0.18877256,0.30004067)<span>(0,0)[b]</span> (0.13527088,0.30921598)<span>(0,0)[b]</span> (0.17759572,0.26561606)<span>(0,0)[b]</span> (0.1216675,0.24170146)<span>(0,0)[b]</span> (0.05659325,0.27101046)<span>(0,0)[b]</span> (0.05273905,0.2143093)<span>(0,0)[b]</span> (0.12099953,0.16114573)<span>(0,0)[b]</span> (0.18096482,0.1942112)<span>(0,0)[b]</span> (0.23082879,0.22322713)<span>(0,0)[b]</span> (0.24014891,0.16114573)<span>(0,0)[b]</span> (0.28721892,0.18041359)<span>(0,0)[b]</span> (0.18949001,0.12648137)<span>(0,0)[b]</span> (0.02834908,0.13520675)<span>(0,0)[b]</span> (0.02514602,0.0660601)<span>(0,0)[b]</span> (0.18453998,0.0594778)<span>(0,0)[b]</span> (0.26332279,0.08721982)<span>(0,0)[b]</span> (0.11683765,0.09347714)<span>(0,0)[b]</span> (0,0)<span><embed src="searchdescr.pdf" title="fig:" /></span> (0.48489282,0.30921598)<span>(0,0)[b]</span> (0.52721766,0.26561606)<span>(0,0)[b]</span> (0.47128944,0.24170146)<span>(0,0)[b]</span> (0.40621521,0.27101046)<span>(0,0)[b]</span> (0.40236101,0.2143093)<span>(0,0)[b]</span> (0.47062147,0.16114573)<span>(0,0)[b]</span> (0.53058679,0.1942112)<span>(0,0)[b]</span> (0.58045073,0.22322713)<span>(0,0)[b]</span> (0.58977085,0.16114573)<span>(0,0)[b]</span> (0.63684087,0.18041359)<span>(0,0)[b]</span> (0.53911198,0.12648137)<span>(0,0)[b]</span> (0.37797105,0.13520675)<span>(0,0)[b]</span> (0.37476798,0.0660601)<span>(0,0)[b]</span> (0.53416192,0.0594778)<span>(0,0)[b]</span> (0.61294473,0.08721982)<span>(0,0)[b]</span> (0.46645959,0.09347714)<span>(0,0)[b]</span> (0,0)<span><embed src="searchdescr.pdf" title="fig:" /></span> (0.83451479,0.30921598)<span>(0,0)[b]</span> (0.87683969,0.26561606)<span>(0,0)[b]</span> (0.82091142,0.24170146)<span>(0,0)[b]</span> (0.75583718,0.27101046)<span>(0,0)[b]</span> (0.75198298,0.2143093)<span>(0,0)[b]</span> (0.8202435,0.16114573)<span>(0,0)[b]</span> (0.88020882,0.1942112)<span>(0,0)[b]</span> (0.93007276,0.22322713)<span>(0,0)[b]</span> (0.93939287,0.16114573)<span>(0,0)[b]</span> (0.98646289,0.18041359)<span>(0,0)[b]</span> (0.88873395,0.12648137)<span>(0,0)[b]</span> (0.72759303,0.13520675)<span>(0,0)[b]</span> (0.72438995,0.0660601)<span>(0,0)[b]</span> (0.88378389,0.0594778)<span>(0,0)[b]</span> (0.96256671,0.08721982)<span>(0,0)[b]</span> (0.81608162,0.09347714)<span>(0,0)[b]</span> (0.15114264,0.00576334)<span>(0,0)[b]</span> (0.50582473,0.00576334)<span>(0,0)[b]</span> (0.8554467,0.00576334)<span>(0,0)[b]</span></p>
<p>Область <span class="math inline">\(D\)</span> графа пространства состояний (ГПС) содержит вершины, которые к какому&quot;=то моменту уже были исследованы и информация о которых сохранена в оперативной памяти. Из этой области видны вершины <span class="math inline">\(f\)</span>, <span class="math inline">\(h\)</span>, <span class="math inline">\(g\)</span> и <span class="math inline">\(i\)</span>. <em>Стратегия перебора</em> определяет, какую из этих четырех вершин надо исследовать на очередном шаге. Выделим несколько основных стратегий:</p>
<ol>
<li><p>случайный выбор вершины;</p></li>
<li><p>выбор вершины, максимально удаленной от стартового узла;</p></li>
<li><p>выбор вершины, ближайшей к стартовому узлу.</p></li>
</ol>
<p>Самой простой процедурой поиска решения в ГПС есть случайный перебор. Начиная со стартовой вершины, всякий раз переходим в одну из смежных вершин и проверяем, не является ли она целевой. Если она таковой не является, то повторяем процедуру. Очевидно, что такой дезорганизованный процесс не дает гарантии, что за приемлемое время будет получен приемлемый результат: в связном ГПС он находит решение (останавливается) в общем случае в потенциальной бесконечности. Тем не менее такая процедура (а не алгоритм) очень легко реализуема программно.</p>
<section id="sec:depthfirst" class="level3">
<h3><span class="header-section-number">3.2.1</span> Поиск в глубину</h3>
<p>Вторая стратегия реализуется в алгоритмах поиска <em>в глубину</em> (<span><em></em></span>) (рис. [fig:searchdescr], <em>b</em>). Примером такого поиска выступает рассмотренная ранее программа прокладки пути в лабиринте. Представим ее еще раз, только в более общем виде:</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">dfs(<span class="dt">V</span><span class="kw">,</span>[])<span class="kw">:-</span> p(<span class="dt">V</span>)<span class="kw">.</span>    <span class="co">% depth-first search</span>
dfs(<span class="dt">V</span><span class="kw">,</span>[<span class="dt">V</span><span class="fu">-</span><span class="dt">N</span><span class="fu">|</span><span class="dt">T</span>])<span class="kw">:-</span> <span class="kw">\+</span> p(<span class="dt">V</span>)<span class="kw">,</span> after(<span class="dt">V</span><span class="kw">,</span><span class="dt">N</span>)<span class="kw">,</span> dfs(<span class="dt">N</span><span class="kw">,</span><span class="dt">T</span>)<span class="kw">.</span>
p(h)<span class="kw">.</span>
after(<span class="dt">X</span><span class="kw">,</span><span class="dt">Y</span>)<span class="kw">:-</span> e(<span class="dt">X</span><span class="kw">,</span><span class="dt">Y</span>)<span class="kw">;</span> e(<span class="dt">Y</span><span class="kw">,</span><span class="dt">X</span>)<span class="kw">.</span></code></pre></div>
<p>Запрос к программе – неотъемлемая часть задачи:</p>
<p>?- dfs(a, S). S = [a-b, b-c, c-f, f-e, e-d, d-h] ; S = [a-b, b-c, c-f, f-e, e-d, d-e, e-d, d-h] ; S = [a-b, b-c, c-f, f-e, e-d, d-e, e-d, d-e, ...]</p>
<p>ГПС задан переходами <code>after(X,Y)</code>, где <code>X</code> и <code>Y</code> – допустимые состояния. Множество допустимых состояний не задано в явном виде, оно порождается предикатом <code>after</code> по мере необходимости. Условие распознавания целевого состояния – <code>p(h)</code>. Начальное состояние указано в запросе первым аргументом: <code>dfs(a, S).</code> В программе использованы две новые синтаксические конструкции: &lt;&lt;<code> +</code>&gt;&gt; – логическая связка отрицания &lt;&lt;<span class="math inline">\(\neg\)</span>&gt;&gt;; и &lt;&lt;<code>;</code>&gt;&gt; – логическая связка &lt;&lt;<span class="math inline">\(\vee\)</span>&gt;&gt; (&lt;&lt;или&gt;&gt;). Применение логической связки &lt;&lt;или&gt;&gt; позволяет в некоторых случаях сокращать текст программы за счет объединения нескольких правил с одним и тем же заголовком в одно.=-1</p>
<p>Результат запуска программы показывает, что количество порождаемых путей для нашего двунаправленного графа потенциально бесконечно. Действительно, если ГПС содержит циклы, то поиск в глубину может &lt;&lt;зацикливаться&gt;&gt;, т. е. соответствующий алгоритм неполон даже на конечных ГПС. Но все же у поиска в глубину есть два замечательных свойства: а) алгоритм прост в реализации, что видно из предыдущего примера; б) для хранения состояния перебора, границы подграфа <span class="math inline">\(D\)</span>, достаточно списка вершин, соединяющих стартовую вершину с текущей, т. е. оперативная память компьютера используется достаточно эффективно. Текст программы процедуры поиска в глубину, реализованной на языках общего назначения, также является лаконичным. В качестве хранилища состояния перебора, как правило, используется стек, организуемый непосредственно операционной системой:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">// Файл dfc.c. Компиляция: gcc -o dfs dfs.c</span>
<span class="pp">#include </span><span class="im">&quot;stdio.h&quot;</span>
<span class="dt">int</span> after[<span class="dv">9</span>][<span class="dv">9</span>]={                 <span class="co">// (1)</span>
<span class="co">// a b c d e f h i g</span>
  {<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>}, <span class="co">// a</span>
  {<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>}, <span class="co">// b</span>
  {<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>}, <span class="co">// c</span>
  {<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>}, <span class="co">// d</span>
  {<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>}, <span class="co">// e</span>
  {<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>}, <span class="co">// f</span>
  {<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>}, <span class="co">// h</span>
  {<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>}, <span class="co">// i</span>
  {<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>}};<span class="co">// g</span>
<span class="dt">int</span> dfs(<span class="dt">int</span> x) {
  <span class="dt">int</span> y=<span class="dv">0</span>;
  <span class="cf">if</span> (x==<span class="dv">6</span>) { <span class="co">// h==6             // (2)</span>
    <span class="cf">return</span> <span class="dv">1</span>;
  } <span class="cf">else</span> {
    <span class="cf">for</span> (y=<span class="dv">0</span>;y&lt;=<span class="dv">9</span>;y++) {          <span class="co">// (3)</span>
      <span class="cf">if</span> (after[x][y]) {          <span class="co">// (4)</span>
        <span class="cf">if</span> (dfs(y)) {             <span class="co">// (5)</span>
          printf (<span class="st">&quot;%i-%i</span><span class="sc">\n</span><span class="st">&quot;</span>,x,y);
          <span class="cf">break</span>;
        }}}}} <span class="co">// плохой стиль! Сэкономим пару строк в пособии.</span>
<span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> ** argv) {
  <span class="cf">if</span> (dfs(<span class="dv">0</span>)) <span class="cf">return</span> <span class="dv">0</span>; <span class="co">// a==0      (6)</span>
  printf (<span class="st">&quot;Нет решений</span><span class="sc">\n</span><span class="st">&quot;</span>);
  <span class="cf">return</span> <span class="dv">1</span>;
}</code></pre></div>
<p>В приведенном примере лабиринт представлен в виде матрицы смежности (1), перебор дочерних вершин реализован в цикле (3–5) по переменной <code>y</code>. Функция <code>dfs</code> возвращает &lt;&lt;истину&gt;&gt; <code>1</code>, если решение найдено (2) и часть пути из текущей вершины <code>x</code> до целевой уже выведена на экран. Начальная вершина указывается при первом вызове <code>dfs</code> (6). Программа лаконичная<a href="#fn15" class="footnoteRef" id="fnref15"><sup>15</sup></a>, только она не останавливается – &lt;&lt;зацикливается&gt;&gt;, бесконечно перемещаясь между вершинами <code>a (0)</code> и <code>b (1)</code>. Пример на языке сначала рассматривает все переходы &lt;&lt;вперед&gt;&gt;, только потом вводит в рассмотрение переходы в обратном направлении. Эта особенность реализации программы и структура лабиринта позволяет&quot;=таки находить первое решение. Несмотря на это, будем по-прежнему считать и эту реализацию &lt;&lt;ненадежной&gt;&gt;.</p>
<section id="ограничение-по-глубине." class="level5">
<h5><span class="header-section-number">3.2.1.0.1</span> Ограничение по глубине.</h5>
<p>Самый простой способ решения проблемы &lt;&lt;зацикливания&gt;&gt; – это ввести ограничение по глубине поиска. Всякий раз, когда алгоритм входит в рекурсию, будем отнимать единицу от специальной переменной. Если значение этой переменной станет равным нулю и решение не будет найдено, то вернуть &lt;&lt;ложь&gt;&gt; <code>0</code>. Рассмотрим модификацию программы на языке Prolog, а совершенствование C-программы оставляем в качестве простого упражнения:</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">dfsl(<span class="dt">V</span><span class="kw">,</span>[]<span class="kw">,</span><span class="dt">_</span>)<span class="kw">:-</span>p(<span class="dt">V</span>)<span class="kw">,!.</span>  <span class="co">% limited depth-first search</span>
dfsl(<span class="dt">V</span><span class="kw">,</span>[<span class="dt">V</span><span class="fu">-</span><span class="dt">N</span><span class="fu">|</span><span class="dt">T</span>]<span class="kw">,</span><span class="dt">D</span>)<span class="kw">:-</span> <span class="dt">D&gt;</span><span class="dv">0</span><span class="kw">,</span> after(<span class="dt">V</span><span class="kw">,</span><span class="dt">N</span>)<span class="kw">,</span>
                    <span class="dt">D1</span> <span class="dt">is</span> <span class="dt">D-</span><span class="dv">1</span><span class="kw">,</span> dfsl(<span class="dt">N</span><span class="kw">,</span><span class="dt">T</span><span class="kw">,</span><span class="dt">D1</span>)<span class="kw">.</span></code></pre></div>
<p>Новый предикат <code>dfsl</code> по сравнению с <code>dfs</code> содержит третий аргумент, переменную – счетчик глубины входа в рекурсию. В первом правиле счетчик не используется, так как там распознается решение. Во втором правиле сначала выполняется проверка условия, что глубина допустима <code>D&gt;0</code>, затем рассматривается дочерняя вершина, конструкция <code>D1 is D-1</code> вычисляет арифметическое выражение <code>D-1</code> и связывает результат с новой переменной <code>D1</code>. В конце правила осуществляется вход в рекурсию с новым значением глубины.</p>
<p>Первое правило использует анонимную переменную &lt;&lt;<code>_</code>&gt;&gt;, она нужна здесь, чтобы &lt;&lt;занимать место&gt;&gt; третьего неиспользуемого аргумента, ее значение нам не важно. Во втором правиле убрана проверка <code>\+p(V)</code>, в ней нет особого смысла: решающие пути, неоднократно попадающие в целевые вершины, остаются решающими. Приведем пример работы программы:</p>
<p>?- dfsl(a, L, 8). L = [a-b, b-c, c-f, f-e, e-d, d-h] ; L = [a-b, b-c, c-f, f-e, e-d, d-e, e-d, d-h] ; L = [a-b, b-c, c-f, f-e, e-f, f-e, e-d, d-h] ; L = [a-b, b-c, c-f, f-e, e-f, f-g, g-i, i-h]</p>
<p>Видно, что результат программы немного отличается от предыдущего. Дальнейшим совершенствованием подхода является управление ограничением по глубине. Сначала необходимо попробовать найти решения длиной в один шаг. Если попытка потерпела неудачу, перейти к решениями длиной в два шага, если опять неудача, то перейти к решениям, состоящим из трех шагов и т. д. Такой алгоритм имеет специальное название IDA (<span><em></em></span>). Алгоритм обладает важным очевидным свойством: первое найденное решение является оптимальным. Реализацию этого алгоритма оставляем читателю.</p>
</section>
<section id="распознавание-циклов." class="level5">
<h5><span class="header-section-number">3.2.1.0.2</span> Распознавание циклов.</h5>
<p>Другим популярным подходом к совершенствованию алгоритмов поиска решения в ГПС, основанных на стратегии &lt;&lt;в глубину&gt;&gt;, является распознавание циклов. Для реализации распознавания необходимо хранить перечень пройденных вершин. Как было сказано выше, этот перечень, путь из стартовой вершины в текущую, сохраняется в стеке. Но ни в Prolog, ни в С к этому списку нет прямого доступа, к сожалению. Поэтому будем &lt;&lt;тащить&gt;&gt; третий аргумент в спецификации процедуры поиска, указывающий на этот путь:</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">dfsr(<span class="dt">V</span><span class="kw">,</span>[]<span class="kw">,</span><span class="dt">_</span>)<span class="kw">:-</span>p(<span class="dt">V</span>)<span class="kw">.</span> <span class="co">% dfs with recognition</span>
dfsr(<span class="dt">V</span><span class="kw">,</span>[<span class="dt">V</span><span class="fu">-</span><span class="dt">N</span><span class="fu">|</span><span class="dt">T</span>]<span class="kw">,</span><span class="dt">Q</span>)<span class="kw">:-</span> after(<span class="dt">V</span><span class="kw">,</span><span class="dt">N</span>)<span class="kw">,</span> <span class="kw">\+</span> member(<span class="dt">N</span><span class="kw">,</span><span class="dt">Q</span>)<span class="kw">,</span>
                      dfsr(<span class="dt">N</span><span class="kw">,</span><span class="dt">T</span><span class="kw">,</span> [<span class="dt">N</span><span class="fu">|</span><span class="dt">Q</span>])<span class="kw">.</span></code></pre></div>
<p>Библиотечный предикат <code>member(X,L)</code> истинный, если <code>X</code> является элементом списка <code>L</code>. Его реализация следующая<a href="#fn16" class="footnoteRef" id="fnref16"><sup>16</sup></a>:</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">member(<span class="dt">X</span><span class="kw">,</span>[<span class="dt">X</span><span class="fu">|</span><span class="dt">_</span>])<span class="kw">.</span>
member(<span class="dt">X</span><span class="kw">,</span>[<span class="dt">_</span><span class="fu">|</span><span class="dt">T</span>])<span class="kw">:-</span>member(<span class="dt">X</span><span class="kw">,</span><span class="dt">T</span>)<span class="kw">.</span></code></pre></div>
<p>Предикат интерпретируется следующим образом: &lt;&lt;элемент списка находится либо в голове, либо в хвосте списка&gt;&gt;. Предикат демонстрирует, как применяются анонимные переменные. Тестировать работоспособность <code>member/2</code> можно запросами <code>member(b,[a,b,c])</code> и <code>member(X,[1,2,3])</code>. Но вернемся к нашей основной задаче и посмотрим, как программа строит решающие пути:</p>
<p>?- dfsr(a, L, []). L = [a-b, b-c, c-f, f-e, e-d, d-h] ; L = [a-b, b-c, c-f, f-g, g-i, i-h] ; false.</p>
<p>Программа находит всего два пути: а) решающие пути, б) пути без циклов. Распознавание циклов – процедура достаточно накладная, она имеет сложность <span class="math inline">\(O(n/2)\)</span> &lt;&lt;в среднем&gt;&gt;, где <span class="math inline">\(n\)</span> – длина пройденного пути. Но в сложных переборных задачах распознавание циклов и экономит объем использованной памяти, и отсекает заведомо худшие варианты решения.</p>
</section>
</section>
<section id="sec:breadthfirst" class="level3">
<h3><span class="header-section-number">3.2.2</span> Поиск в ширину</h3>
<p>Стратегия поиска <em>в ширину</em> (<span><em></em></span>) обладает таким же свойством, что и стратегия алгоритма IDA, т. е. первое найденное решение будет оптимальным. Вот только достигается это без повторного перебора исследованной области графа <span class="math inline">\(D\)</span> (рис. [fig:labyrinth], <em>a</em>, <em>с</em>). Процесс поиска хранит все так называемые <em>пути&quot;=кандидаты</em>, пути, претендующие на то, чтобы стать решением. Все пути“=кандидаты начинаются в исходном узле и заканчиваются текущей вершиной. Если текущая вершина – целевая, то такой путь”=кандидат становится решающим. Хранение списка путей&quot;=кандидатов не является лучшим решением по управлению оперативной памятью вычислительного процесса, но зато достаточно просто реализуем:</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">bfs([[<span class="dt">X</span><span class="fu">|</span><span class="dt">T</span>]<span class="fu">|</span><span class="dt">_</span>]<span class="kw">,</span>[<span class="dt">X</span><span class="fu">|</span><span class="dt">T</span>])<span class="kw">:-</span>p(<span class="dt">X</span>)<span class="kw">,!.</span>  <span class="co">% (1)</span>
bfs([[<span class="dt">X</span><span class="fu">|</span><span class="dt">T</span>]<span class="fu">|</span><span class="dt">Ways</span>]<span class="kw">,</span> <span class="dt">S</span>)<span class="kw">:-</span>
        findall([<span class="dt">Y</span>,<span class="dt">X</span><span class="fu">|</span><span class="dt">T</span>]<span class="kw">,</span>       <span class="co">% (2)</span>
          (after(<span class="dt">X</span><span class="kw">,</span><span class="dt">Y</span>)<span class="kw">,</span> <span class="kw">\+</span> member(<span class="dt">Y</span><span class="kw">,</span>[<span class="dt">X</span><span class="fu">|</span><span class="dt">T</span>]))<span class="kw">,</span> <span class="dt">L</span>)<span class="kw">,</span>
        append(<span class="dt">Ways</span><span class="kw">,</span><span class="dt">L</span><span class="kw">,</span> <span class="dt">NWays</span>)<span class="kw">,</span> <span class="co">% (3)</span>
        bfs(<span class="dt">NWays</span><span class="kw">,</span><span class="dt">S</span>)<span class="kw">.</span>  <span class="co">% Истина где-то рядом...</span></code></pre></div>
<p>Первый аргумент <code>bfs/2</code> – список путей“=кандидатов, второй – решающий путь. В обоих правилах <code>[X|T]</code> – путь”=кандидат, находящийся на рассмотрении на данном шаге. Его голова <code>X</code> соответствует текущей вершине, начальная вершина находится в самом конце хвоста пути <code>T</code>. Путь&quot;=кандидат хранит решение в обратном порядке: новые вершины добавляются в начало списка (2).</p>
<p>Во втором правиле второй аргумент <code>findall/3</code> является выражением (конъюнкцией) в скобках, порождающим переходы к дочерним вершинам, но только такие, которые не приводят к циклам. Библиотечный предикат <code>append(L1,L2,L3)</code> добавляет слева от <code>L2</code> список <code>L1</code> и порождает список <code>L3</code>. Вот его не самая эффективная реализация <span class="citation" data-cites="Bratko"></span>:</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">append([]<span class="kw">,</span><span class="dt">L</span><span class="kw">,</span><span class="dt">L</span>)<span class="kw">.</span>
append([<span class="dt">X</span><span class="fu">|</span><span class="dt">T1</span>]<span class="kw">,</span><span class="dt">L2</span><span class="kw">,</span>[<span class="dt">X</span><span class="fu">|</span><span class="dt">T3</span>])<span class="kw">:-</span>append(<span class="dt">T1</span><span class="kw">,</span><span class="dt">L2</span><span class="kw">,</span><span class="dt">T3</span>)<span class="kw">.</span></code></pre></div>
<p>В первом правиле, в строке (1), использовано отсечение &lt;&lt;<code>!</code>&gt;&gt;, в нашем случае запрещающее Prolog искать еще одно решение, если первое уже найдено. Запрос на поиск первого оптимального решения выглядит следующим образом:</p>
<p>?- bfs([[a]],S). S = [h, d, e, f, c, b, a].</p>
<p>В результате действия отсечения интерпретатор выдал решение и без лишних вопросов прекратил дальнейшие поиски. В <span class="citation" data-cites="Bratko"></span> приведен вариант алгоритма, где подграф <span class="math inline">\(D\)</span> представляется в виде дерева, что значительно эффективнее списка путей&quot;=кандидатов.</p>
<p>Теперь давайте займемся более сложными задачами, которые порождают большое (в том числе бесконечное) пространство поиска. Поиск решений в этих задачах занимает много ресурсов компьютера, если решать их простыми переборными алгоритмами. Необходимо сделать так, чтобы область <span class="math inline">\(D\)</span> была как можно меньше, а поиск пытаться вести где&quot;=то рядом с вероятным решающим путем.</p>
</section>
</section>
<section id="sec:informedsearch" class="level2">
<h2><span class="header-section-number">3.3</span> Использование дополнительной информации</h2>
<p>Обобщим задачу планирования действий: добавим третий аргумент <code>after/2</code> и получим <code>after(X,Y,V)</code>, где <code>V</code> – стоимость дуги, которая раньше была у всех дуг одинакова и равнялась <span class="math inline">\(1\)</span>. Теперь стоимость решающего пути будет складываться из стоимостей составляющих его индивидуальных переходов. Дальнейшие наши рассуждения также будут подразумевать использование поиска в ширину как базовой стратегии решения задач.</p>
<p>Практическая задача, обладающая в той или иной мере перечисленными свойствами, – это поиск маршрутов между городами. Граф дорожной сети состоит из вершин (городов), дуг (дорог, соединяющих два смежных города). Данные сети автомобильных дорог Российской Федерации в Интернете найти не удалось, зато в документе <span class="citation" data-cites="rzhddb"></span> содержится достаточно подробная, но не вполне корректная информация о расстояниях между станциями Российских железных дорог (РЖД). Все данные импортированы в базу данных SQLite <code>rzd.sqlite</code> и опубликованы на сервере по адресу: <a href="https://github.com/eugeneai/ais/tree/cs/code" class="uri">https://github.com/eugeneai/ais/tree/cs/code</a>. Импорт данных осуществлен при помощи сценария (<span><em></em></span>), реализованного на языке программирования Python <span class="citation" data-cites="pythondoc pythondl pythonbook"></span>. Для исполнения дальнейшего программного кода необходимо скачать все файлы с указанного адреса к себе в рабочую папку.</p>
<p>В документе <span class="citation" data-cites="rzhddb"></span> среди всего множества станций выделяются станции, называемые <em>транзитными пунктами</em> (ТП). Судя по структуре документа, расстояния от &lt;&lt;обычных&gt;&gt; станций указываются именно до транзитных пунктов. Примерами транзитных пунктов являются станции <code>’Иркутск&quot;=Пассажирский’</code>, <code>’Тайшет’</code>, <code>’Лена’</code> (г. Братск), <code>’Улан&quot;=Удэ’</code>. Решать задачу поиска кратчайшего расстояния будем между транзитными пунктами, а задачу поиска ближайшего транзитного пункта от обычных станций оставим в качестве упражнения. Дополнительную информацию будем вычислять, исходя из физических параметров карты – географических координат транзитных пунктов. Координаты будем запрашивать в Интернете на сервисе (OSM), а также сохранять их в базе данных для обеспечения быстрого доступа. Рассмотрим, как SWI&quot;=Prolog взаимодействует с SQL–базами данных. <span><span class="math inline">\(\,\hookrightarrow\)</span></span></p>
<section id="sec:dbms" class="level3">
<h3><span class="header-section-number">3.3.1</span> Доступ к базам данных</h3>
<p>Вообще говоря, следует уточнить, о какой поддержке баз данных в Prolog идет речь. В интерпретаторе доступны:</p>
<ul>
<li><p>встроенная база данных, реализуемая при помощи динамических предикатов, набора фактов, перечень которых меняется при помощи предикатов <code>assert/1</code> и <code>retract/1</code> <span class="citation" data-cites="Bratko"></span>;</p></li>
<li><p>внешние базы данных, в том числе SQL. Далее будем говорить именно об этом.</p></li>
</ul>
<p>Как любой другой полноценный язык программирования, Prolog поддерживает организацию подпрограмм в отдельные модули. Для того чтобы загрузить правила и факты из модуля доступа к базам данных SQLite, надо выполнить инструкцию <code>:- use_module(library(prosqlite)).</code> Такие инструкции являются запросами и исполняются в процессе загрузки программы.</p>
<p>Модуль <code>prosqlite</code> не включен в дистрибутив SWI-Prolog по умолчанию, его необходимо загрузить из Интернета в виде одноименного пакета. Чтобы получить список доступных пакетов, содержащих в своем названии интересующий текст, надо выполнить поисковый запрос в интерпретаторе:</p>
<p>?- pack_list(prosqlite). p db_facts@0.1.0 - Common db-tables-as-facts and SQL layer for ODBC and SQLite. p prosqlite@1.0 - An SWI-Prolog interface to SQLite</p>
<p>Установка пакета, как и выполнение предыдущего запроса, требует наличия соединения с Интернетом<a href="#fn17" class="footnoteRef" id="fnref17"><sup>17</sup></a>. В процессе установки интерпретатор может спросить, стоит ли продолжать установку, а также куда следует устанавливать библиотеку (). Отвечать следует нажатием</p>
<p>(key)</p>
<p>  y  </p>
<p>;</p>
<p>.</p>
<p>?- pack_install(prosqlite). Install prosqlite@1.0 from http://stoics... Y/n?</p>
<p>Create directory for packages (1) * /home/eugeneai/lib/swipl/pack (2) Cancel</p>
<p>Your choice? 1</p>
<p>Package: prosqlite Title: An SWI-Prolog ... SQLite Installed version: 1.0 Author: Sander Canisius, ... Maintainer: Nicos Angelopoulos Packager: Nicos Angelopoulos Home page: http://stoics.org.uk/... Download URL: http://stoics.org.uk/... Install “prosqlite-1.0.tgz” (740,988 bytes) Y/n?</p>
<p>В заключение установки проверим, загружается ли наш модуль (библиотека):</p>
<p>?- [library(prosqlite)].</p>
<section id="представление-реляционных-таблиц-в-виде-предикатов." class="level5">
<h5><span class="header-section-number">3.3.1.0.1</span> Представление реляционных таблиц в виде предикатов.</h5>
<p>SWI-Prolog позволяет непосредственно выполнять SQL-запросы к базе данных, в результате запроса последний аргумент связывается со структурой <code>row(…)</code> для каждой возвращаемой записи. Аргументами данной структуры являются значения атрибутов записи:</p>
<p>?- sqlite_connect(rzd, db, [as_predicates(true)]). ?- sqlite_query(db, ’SELECT * FROM station LIMIT 3’, Row). Row = row(’Вентспилс (эксп.)’,’Лат’,98306,0) ; Row = row(’Шаблиевская’,’С-Кав’,518827,0) ; Row = row(’Салар’,’Узбк’,720903,0) ; false.</p>
<p>Первый запрос создает соединение с базой данных <code>rzd.sqlite</code>, при этом соединение ассоциируется с атомом <code>db</code>, который далее используется как глобальный идентификатор этого соединения. Третий аргумент настраивает дополнительные возможности библиотеки – представление таблиц базы данных в виде предикатов языка Prolog. Второй запрос к Prolog является “=запросом к таблице данных о существующих станциях <code>station</code>. Prolog выдал три ответа, затем волнение запроса закончилось неудачей. Теперь воспользуемся дополнительными возможностями библиотеки и запросим перечень станций по”=прологовски, а соответствующий запрос на выборку данных он синтезирует сам:</p>
<p>?- station(Name,Region,Code,TP). Name = ’Вентспилс (эксп.)’, Region = ’Лат’, Code = 98306, TP = 0 ; Name = ’Шаблиевская’, Region = ’С-Кав’, Code = 518827, TP = 0</p>
<p>Если требуется узнать только транзитные пункты, то надо просто указать значения соответствующих параметров:</p>
<p>?- station(Name,’В-Сиб’,Code,1). Name = ’Лена’, Code = 927105 ; Name = ’Иркутск-Пассажирский’, Code = 930108 ; Name = ’Улан-Удэ’, . . . . . . . . .</p>
<p>Теперь запросы к базам данных можно комбинировать с другими предикатами программы. Соединение с базой данных разрывается предикатом <code>sqlite_disconnect(db)</code>. В таблице [tab:dbstruct] приведены данные о структуре основных таблиц базы данных <code>rzd.sqlite</code>. Структуры остальных таблиц можно посмотреть при помощи команды &lt;&lt;<code>.schema</code>&gt;&gt;, подключившись к базе данных <code>sqlite3 rzd.sqlite</code>. Теория, методы проектирования и инструментальные средства баз данных подробно рассмотрены в третьей части учебного пособия.</p>
<table>
<caption>Основные таблицы базы данных структуры РДЖ<span data-label="tab:dbstruct"></span></caption>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>name text,</code></td>
<td style="text-align: left;">Название станции</td>
<td style="text-align: left;"><code>station int,</code></td>
<td style="text-align: left;">Код ТП</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>region int,</code></td>
<td style="text-align: left;">Филиал РДЖ</td>
<td style="text-align: left;"><code>lon int,</code></td>
<td style="text-align: left;">Долгота</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>code int,</code></td>
<td style="text-align: left;">Код станции</td>
<td style="text-align: left;"><code>lat int</code></td>
<td style="text-align: left;">Широта</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>transit int</code></td>
<td style="text-align: left;">Это ТП?</td>
<td style="text-align: left;"><code>lat place_id</code></td>
<td style="text-align: left;">OSM-код объекта</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>a int,</code></td>
<td style="text-align: left;">Первый ТП</td>
<td style="text-align: left;"><code>a int,</code></td>
<td style="text-align: left;">Код станции</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>b int,</code></td>
<td style="text-align: left;">Второй ТП</td>
<td style="text-align: left;"><code>b int,</code></td>
<td style="text-align: left;">Код ТП</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>dist int</code></td>
<td style="text-align: left;">Расстояние</td>
<td style="text-align: left;"><code>dist int</code></td>
<td style="text-align: left;">Расстояние до ТП</td>
</tr>
</tbody>
</table>
</section>
<section id="par:informedcont" class="level5">
<h5><span class="header-section-number">3.3.1.0.2</span> Возвращаемся к задаче поиска оптимального пути.</h5>
<p>Итак, у нас есть база данных с необходимыми таблицами и данными. Теперь наша задача – построить алгоритм, осуществляющий поиск оптимального пути в ГПС сети железных дорог РЖД, эффективно использующий процессор. Сначала обобщим поиск в ширину – учтем тот факт, что дуги теперь нагружены (дороги, соединяющие города, разной длины):</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">ucs([<span class="dt">_</span><span class="fu">-</span>[<span class="dt">Target</span><span class="fu">|</span><span class="dt">T</span>] <span class="fu">|</span><span class="dt">_</span>]<span class="kw">,</span><span class="dt">Target</span><span class="kw">,</span>[<span class="dt">Target</span><span class="fu">|</span><span class="dt">T</span>])<span class="kw">:-!.</span>
ucs([<span class="dt">G</span><span class="fu">-</span>[<span class="dt">X</span><span class="fu">|</span><span class="dt">T</span>]<span class="fu">|</span><span class="dt">Ways</span>]<span class="kw">,</span> <span class="dt">Target</span><span class="kw">,</span> <span class="dt">S</span>)<span class="kw">:-</span>
        <span class="dt">Target</span><span class="kw">\=</span><span class="dt">X</span><span class="kw">,</span>
        findall(<span class="dt">G1</span><span class="fu">-</span>[<span class="dt">Y</span>,<span class="dt">X</span><span class="fu">|</span><span class="dt">T</span>]<span class="kw">,</span> after([<span class="dt">X</span><span class="fu">|</span><span class="dt">T</span>]<span class="kw">,</span><span class="dt">G</span><span class="kw">,</span> <span class="dt">Y</span><span class="kw">,</span><span class="dt">G1</span>)<span class="kw">,</span> <span class="dt">L</span>)<span class="kw">,</span>
        append(<span class="dt">L</span><span class="kw">,</span> <span class="dt">Ways</span><span class="kw">,</span> <span class="dt">NWays</span>)<span class="kw">,</span>
        keysort(<span class="dt">NWays</span><span class="kw">,</span><span class="dt">SNWays</span>)<span class="kw">,</span>
        ucs(<span class="dt">SNWays</span><span class="kw">,</span><span class="dt">Target</span><span class="kw">,</span><span class="dt">S</span>)<span class="kw">.</span>

after([<span class="dt">S</span><span class="fu">|</span><span class="dt">R</span>]<span class="kw">,</span><span class="dt">SG</span><span class="kw">,</span> <span class="dt">T</span><span class="kw">,</span><span class="dt">TG</span>)<span class="kw">:-</span>
        transdist(<span class="dt">S</span><span class="kw">,</span><span class="dt">T</span><span class="kw">,</span><span class="dt">D</span>)<span class="kw">,</span>  <span class="co">% Расстояние D между</span>
        <span class="kw">\+</span> member(<span class="dt">T</span><span class="kw">,</span>[<span class="dt">S</span><span class="fu">|</span><span class="dt">R</span>])<span class="kw">,</span>     <span class="co">% ТП S и T</span>
        <span class="dt">TG</span> <span class="dt">is</span> <span class="dt">SG</span> <span class="dt">+</span> <span class="dt">D</span><span class="kw">.</span>      <span class="co">% Приращение стоимости пути</span></code></pre></div>
<p>В новой программе проверка вхождения дочерней вершины в пройденный путь и вычисления стоимости нового пути вынесены в предикат <code>after/4</code>, и поэтому в первый аргумент передается не вершина, а пройденный путь. Предикат <code>after/4</code> по сравнению с <code>after/2</code> дополнен двумя аргументами: <code>SG</code> – стоимость пройденного пути <code>[S|R]</code>, <code>TG</code> – стоимость пути <code>[T,S|R]</code>. Список путей“=кандидатов теперь оформлен в виде структуры <code>G-W</code>, где <code>W</code> – путь”=кандидат, <code>G</code> – его стоимость. В <code>ucs/3</code> добавлен новый аргумент – название целевой станции: в задаче целевая вершина всего одна, да и удобнее задавать конечную станцию в запросе, а не программе. Далее, предикат <code>keysort(NWays, SNWays)</code> сортирует список <code>NWays</code> двоек <code>G-W</code> по возрастанию значения <code>G</code>. Сортировка выполняется при помощи алгоритма быстрой сортировки над всем списком <code>NWays</code>. Алгоритм реализован на языке C как двоичный модуль и выполняется достаточно эффективно, поэтому левые два аргумента <code>append/3</code> переставлены местами: длина (в элементах) списка <code>L</code> значительно меньше, чем длина списка <code>Ways</code>. Таким образом, первым элементом в отсортированном списке двоек <code>SNWays</code> оказывается двойка с минимальной стоимостью пути&quot;=кандидата.</p>
<p>Запрос на поиск пути между железнодорожными станциями – столицами двух российских регионов выглядит следующим образом<a href="#fn18" class="footnoteRef" id="fnref18"><sup>18</sup></a>:</p>
<p>?- ucs([0-[’Улан-Удэ’]],’Новосибирск-Главный’,S). S = [Новосибирск-Главный,Сокур,Юрга I,Тайга, Анжерская, Ачинск I,Уяр, Тайшет, Иркутск-Пассажирский,Улан-Удэ]</p>
<p>В программе <code>bfs/2</code> новые пути“=кандидаты добавлялись в конец существующего списка путей”=кандидатов, и список при этом оставался упорядоченным. В <code>ucs/3</code> так сделать не получится, так как вставлять новые пути уже надо внутрь списка. Поэтому приходится использовать быструю сортировку на каждом шаге, сортировка вставкой не даст дополнительных преимуществ для рекурсивных списков в Prolog. Ускорить процесс вставки можно за счет использования сбалансированных деревьев для представления списка путей&quot;=кандидатов.</p>
<p>Представленный алгоритм называется &lt;&lt;Поиск по критерию стоимости&gt;&gt; (метод равных цен, <span><em></em></span>, UCS). Если стоимости всех дуг в ГПС положительны, то UCS является полным и оптимальным, так же как и алгоритм поиска в ширину. Вместо перехода в ближайший к исходной вершине узел UCS переходит (раскрывает) в вершину с минимальной стоимостью пути до исходной вершины. Если все стоимости дуг одинаковы, UCS превращается в поиск в ширину.</p>
</section>
</section>
<section id="алгоритм-amathtt" class="level3">
<h3><span class="header-section-number">3.3.2</span> Алгоритм <code>A</code><span class="math inline">\({}^\mathtt{*}\)</span></h3>
<p>Теперь посмотрим, как можно ускорить поиск, используя дополнительную информацию. На рисунке [fig:contraction], <em>а</em> показана железнодорожная сеть (ГПС) Южного Урала, Западной Сибири и Казахстана. На примере этой сети продемонстрирован процесс UCS раскрытия вершин ГПС во время поиска решения. Задача состоит в том, чтобы найти путь со станции Тобол до станции Омск. Пунктирными окружностями обозначена область <span class="math inline">\(D\)</span> на разных этапах поиска. Как видно, UCS не делает никаких предположений о местонахождении Омска и вынужден &lt;&lt;ходить&gt;&gt; вокруг начальной вершины, на каждом шаге постепенно увеличивая радиус окружности. На практике всегда возникает вопрос: &lt;&lt;В какую сторону следует двигаться, чтобы исключить неподходящие вершины ГПС и быстрее добраться до целевой вершины?&gt;&gt;. В нашем примере в качестве такого направления выступает направление на целевую вершину (рис. [fig:contraction], <em>b</em>).</p>
<figure>
<embed src="yuzd1.pdf" /><figcaption>Сужение области поиска<span data-label="fig:contraction"></span></figcaption>
</figure>
<p>Зададим стоимость кратчайшего решающего пути, проходящего через некоторую вершину ГПС <span class="math inline">\(x\)</span>, функцией <span class="math inline">\(f\!\!:V\to R\)</span> следующего вида: <span class="math display">\[\label{eq:1}
  f(x)=g(x)+r(x),\]</span> где <span class="math inline">\(g(x)\)</span> – стоимость кратчайшего пути из начальной вершины до вершины <span class="math inline">\(x\)</span>, а <span class="math inline">\(r(x)\)</span> – стоимость пути из <span class="math inline">\(x\)</span> до целевой вершины. Если <span class="math inline">\(x\)</span> является целевой вершиной, то <span class="math inline">\(r(x)=0\)</span> и <span class="math inline">\(g(x)=f(x)\)</span>, т. е. значения функций равны стоимости решающего пути. Если <span class="math inline">\(x\)</span> не является целевой, то значение <span class="math inline">\(r(x)\)</span> не известно. Если значение <span class="math inline">\(f(x)\)</span> можно было бы вычислить для любой вершины <span class="math inline">\(x\)</span>, то тогда можно было бы разработать алгоритм поиска, который точно &lt;&lt;знает&gt;&gt;, куда следует идти на каждом шаге построения решения. Несмотря на то что такое в общем случае невозможно, кое“=что все”=таки сделать можно: будем оценивать величину <span class="math inline">\(r(x)\)</span> снизу некоторой функцией <span class="math inline">\(h(x)\)</span>. Для всех <span class="math inline">\(x\)</span> должно выполняться неравенство <span class="math inline">\(r(x)\leqslant h(x)\)</span>. Значения функции <span class="math inline">\(f(x)\)</span> будем оценивать таким образом: <span class="math display">\[\label{eq:2}
  f(x)\geqslant g(x)+h(x).\]</span></p>
<p>В нашей задаче значения <span class="math inline">\(h(x)\)</span> соответствуют расстоянию между городами, т. е. по самой короткой линии на поверхности сферы. Для вычисления этого расстояния нам потребуется база данных <code>geocache</code> (табл. [tab:dbstruct]) и реализация подсистемы запроса географических координат на сервере , которым в этот раз займемся чуть позже.</p>
<p>Программа поиска, основывающегося на оценке <span class="math inline">\(h(x)\)</span>, состоит из трех основных предикатов. Первый предикат – <code>after/6</code>, который получает еще два дополнительных параметра: <code>GPS</code> – координаты целевой вершины (входной параметр), <code>F</code> – оценка <span class="math inline">\(f(\mathtt{T})\)</span> для дочерней вершины <code>T</code> (выходной параметр). Вторым предикатом выступает <code>bf1/3</code>, являющийся реализацией собственно алгоритма поиска. Третий предикат – это процедура <code>bf/3</code>, подготавливающая данные для основного предиката <code>bf1/3</code>:</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">bf1([<span class="dt">_</span><span class="fu">-</span>s(<span class="dt">G</span><span class="kw">,</span>[<span class="dt">Target</span><span class="fu">|</span><span class="dt">T</span>]) <span class="fu">|</span><span class="dt">_</span>]<span class="kw">,</span>         <span class="co">% (1)</span>
        <span class="dt">Target</span><span class="fu">-</span><span class="dt">_</span><span class="kw">,</span>s(<span class="dt">G</span><span class="kw">,</span>[<span class="dt">Target</span><span class="fu">|</span><span class="dt">T</span>]))<span class="kw">:-!.</span>
bf1([<span class="dt">_</span><span class="fu">-</span>s(<span class="dt">G</span><span class="kw">,</span>[<span class="dt">X</span><span class="fu">|</span><span class="dt">T</span>])<span class="fu">|</span><span class="dt">Ways</span>]<span class="kw">,</span> <span class="dt">Target</span><span class="fu">-</span><span class="dt">GPS</span><span class="kw">,</span> <span class="dt">S</span>)<span class="kw">:-</span>
        <span class="dt">Target</span><span class="kw">\=</span><span class="dt">X</span><span class="kw">,</span>
        findall(<span class="dt">F1</span><span class="fu">-</span>s(<span class="dt">G1</span><span class="kw">,</span>[<span class="dt">Y</span>,<span class="dt">X</span><span class="fu">|</span><span class="dt">T</span>])<span class="kw">,</span>
           after([<span class="dt">X</span><span class="fu">|</span><span class="dt">T</span>]<span class="kw">,</span><span class="dt">G</span><span class="kw">,</span><span class="dt">GPS</span><span class="kw">,</span> <span class="dt">Y</span><span class="kw">,</span><span class="dt">G1</span><span class="kw">,</span><span class="dt">F1</span>)<span class="kw">,</span> <span class="dt">L</span>)<span class="kw">,</span>
        append(<span class="dt">L</span><span class="kw">,</span> <span class="dt">Ways</span><span class="kw">,</span> <span class="dt">NWays</span>)<span class="kw">,</span> keysort(<span class="dt">NWays</span><span class="kw">,</span><span class="dt">SNWays</span>)<span class="kw">,</span>
        bf1(<span class="dt">SNWays</span><span class="kw">,</span><span class="dt">Target</span><span class="fu">-</span><span class="dt">GPS</span><span class="kw">,</span><span class="dt">S</span>)<span class="kw">.</span>

after([<span class="dt">S</span><span class="fu">|</span><span class="dt">R</span>]<span class="kw">,</span><span class="dt">SG</span><span class="kw">,</span> <span class="dt">GPS</span><span class="kw">,</span> <span class="dt">T</span><span class="kw">,</span><span class="dt">TG</span><span class="kw">,</span> <span class="dt">F</span>)<span class="kw">:-</span>
        transdist(<span class="dt">S</span><span class="kw">,</span><span class="dt">T</span><span class="kw">,</span><span class="dt">D</span>)<span class="kw">,</span>
        <span class="kw">\+</span> member(<span class="dt">T</span><span class="kw">,</span>[<span class="dt">S</span><span class="fu">|</span><span class="dt">R</span>])<span class="kw">,</span>
        <span class="dt">TG</span> <span class="dt">is</span> <span class="dt">SG</span> <span class="dt">+</span> <span class="dt">D</span><span class="kw">,</span>
        geodist(<span class="dt">T</span><span class="kw">,</span> <span class="dt">GPS</span><span class="kw">,</span> <span class="dt">GDist</span>)<span class="kw">,</span>     <span class="co">% (2)</span>
        <span class="dt">F</span> <span class="dt">is</span> <span class="dt">TG</span> <span class="dt">+</span> <span class="dt">GDist</span><span class="kw">.</span>

bf(<span class="dt">Start</span><span class="kw">,</span> <span class="dt">Target</span><span class="kw">,</span> <span class="dt">Sol</span>)<span class="kw">:-</span>
        geocode(<span class="dt">Target</span><span class="kw">,</span> <span class="dt">Lon</span><span class="kw">,</span> <span class="dt">Lat</span><span class="kw">,</span> <span class="dt">_</span>)<span class="kw">,</span>
        bf1([<span class="dv">0</span><span class="fu">-</span>s(<span class="dv">0</span><span class="kw">,</span>[<span class="dt">Start</span>])]<span class="kw">,</span>
          <span class="dt">Target</span><span class="fu">-</span>ll(<span class="dt">Lon</span><span class="kw">,</span><span class="dt">Lat</span>)<span class="kw">,</span> <span class="dt">Sol</span>)<span class="kw">.</span> <span class="co">% (3)</span></code></pre></div>
<p>Используемые в программе структуры также немного усложнены по сравнению с UCS. Элемент списка путей&quot;=кандидатов (1) теперь представляет собой структуру вида <code>F-s(G,[X|T])</code>, где <code>X</code> – текущая вершина, <code>G</code> – стоимость пройденного пути <span class="math inline">\(g(\mathtt{X})\)</span> до текущей вершины, <code>F</code> – оценка <span class="math inline">\(f(\mathtt{X})\)</span>. Параметр <code>GPS</code> предиката <code>after/6</code> – структура <code>ll(Lon,Lat)</code>, <code>Lon</code> – долгота целевой вершины, <code>Lat</code> – ее широта. Оба значения заданы в градусах. Структура создается в строке (3) и передается в составе двойки <code>Target-GPS</code>. Оценка <span class="math inline">\(h(\mathtt{T})\)</span> вычисляется в <code>geodist/2</code> в строке (2). Приведем пример поиска кратчайшего пути между двумя станциями:</p>
<p>?- bf(’Свердловск-Сортировочный’, ’Новосибирск-Главный’, S), write(S). OSM: Пермь II lon: 56.1744706, lat:58.0050018 S = s(1535,[Новосибирск-Главный,Обь,Татарская,Карбышево I, Войновка,Тюмень,Богданович,Шарташ, Свердловск-Сортировочный])</p>
<p>В результате запроса получается структура, которая содержит решающий путь и его стоимость (длина в км). В процессе построения решения программа запрашивает данные местоположения станций в Интернете. Результаты запросов выдаются на экран в виде отладочной информации (1).</p>
<p>Построенная нами реализация алгоритма <span class="math inline">\(\mathtt{A}^*\)</span> основывается на непереоценивающей функции <span class="math inline">\(h\)</span>, т. е. выдает первым оптимальное решение. Необходимо сделать пару замечаний.</p>
<ol>
<li><p>Расстояние между городами вычисляется в пространстве на сфере, что не отражает структуры железнодорожной сети. Например, расстояние между Москвой и Иркутском составляет чуть меньше 4200 км, траектория полета самолета проходит вблизи города Сургута, находящегося значительно севернее Трассиба.</p></li>
<li><p>Запуская программу, можно наблюдать, что гарантированно получить правильные координаты станции у нас не всегда получится: сервис OSM не специализируется на предоставлении координат станций и может выдавать координаты объектов со схожим названием. Так, например, на момент публикации данного пособия не удалось правильно определить координаты станции Лена, которая находится в городе Братске Иркутской области.</p></li>
</ol>
<p>После небольшого экскурса в обработку файлов XML (<span><em></em></span>) и доступа в Интернет рассмотрим решение более общих задач на основе переборных алгоритмов. <span><span class="math inline">\(\,\hookrightarrow\)</span></span></p>
</section>
<section id="sec:inetxml" class="level3">
<h3><span class="header-section-number">3.3.3</span> Доступ в Интернет и обработка XML</h3>
<p>Язык программирования Prolog представляет собой удобное средство обработки рекурсивных структур. Использованные нами в разделе [sec:breadthfirst] списки относятся к таким рекурсивным структурам. Другой известной рекурсивной структурой является <em>дерево</em>, которое лежит в основе структуры формата данных XML. Формат XML позволяет представлять информацию таким образом, чтобы она, с одной стороны, достаточно эффективно обрабатывалась алгоритмически (на компьютере), а с другой, была понятна человеку. Вот, например, ответ с сервера геокодирования <span class="citation" data-cites="nominatim"></span>:</p>
<div class="sourceCode" fontsize="\footnotesize"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;?xml</span> version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; <span class="kw">?&gt;</span>
<span class="kw">&lt;searchresults</span><span class="ot"> timestamp=</span><span class="st">&#39;Thu, 15 Jan 15 07:54:30 +0000&#39;</span>
<span class="ot">               attribution=</span><span class="st">&#39;Data © OpenStreetMap contributors, ODbL</span>
<span class="st">                            1.0. http://www.openstreetmap.org/copyright&#39;</span>
<span class="ot">               querystring=</span><span class="st">&#39;Иркутск&#39;</span>
<span class="ot">               oviewbox=</span><span class="st">&#39;-112.15,61.44,112.15,-61.44&#39;</span>
<span class="ot">               polygon=</span><span class="st">&#39;false&#39;</span>
<span class="ot">               exclude_place_ids=</span><span class="st">&#39;158888259&#39;</span>
               <span class="kw">&gt;</span>
  <span class="kw">&lt;place</span>
<span class="ot">      place_id=</span><span class="st">&#39;158888259&#39;</span><span class="ot"> osm_type=</span><span class="st">&#39;relation&#39;</span><span class="ot"> osm_id=</span><span class="st">&#39;1430614&#39;</span>
<span class="ot">      place_rank=</span><span class="st">&#39;16&#39;</span>
<span class="ot">      boundingbox=</span><span class="st">&quot;52.2094352,52.4217324,104.0579985,104.462928&quot;</span>
<span class="ot">      lat=</span><span class="st">&#39;52.2895979&#39;</span><span class="ot"> lon=</span><span class="st">&#39;104.2805843&#39;</span>
<span class="ot">      display_name=</span><span class="st">&#39;Иркутск, городской округ Иркутск, Иркутская</span>
<span class="st">                    область, Сибирский федеральный округ, Российская</span>
<span class="st">                    Федерация&#39;</span>
<span class="ot">      class=</span><span class="st">&#39;place&#39;</span><span class="ot"> type=</span><span class="st">&#39;city&#39;</span><span class="ot"> importance=</span><span class="st">&#39;0.70744217496694&#39;</span><span class="kw">/&gt;</span>
<span class="kw">&lt;/searchresults&gt;</span></code></pre></div>
<p>Основные элементы XML – это <em>теги</em>, <em>атрибуты</em> и текст, заполняющий пространство между тегами. В данном примере тегами выступают <code>&lt;searchresults&gt;</code> и <code>&lt;place&gt;</code>. Тег <code>&lt;place&gt;</code> расположен &lt;&lt;внутри&gt;&gt; тега <code>&lt;searchresults&gt;</code>. Тег <code>&lt;searchresults&gt;</code> – корневой, который по стандарту XML должен быть только один, остальные могут повторяться. В нашем примере сервер геокодирования может выдать несколько объектов, соответствующих запросу. В XML&quot;=ответе сервера это отразится наличием повторений тега <code>&lt;place&gt;</code> для каждого объекта.</p>
<p>Атрибуты ассоциированы с тегами и несут формализованную дополнительную информацию. В примере тегами <code>lat</code> и <code>lon</code> заданы географические координаты объекта (города Иркутска), полное наименование (<code>display_name</code>), тип объекта <code>type</code> и т. д. Каждый атрибут приравнивается к некоторому значению. Таким образом, тег <code>place</code> со своими атрибутами описывает объекты, а <code>&lt;searchresults&gt;</code> – результат обработки запроса, состоящий из одного или нескольких объектов.</p>
<p>Процедуры (предикаты) обработки XML, запросы к сайтам Интернета, а также обработка списка ключевых слов (атрибутов) реализованы в соответствующих библиотеках среды Prolog. В нашей программе необходимо импортировать эти библиотеки:</p>
<p>:- use_module(library(http/http_open)). :- use_module(library(sgml)). :- use_module(library(option)).</p>
<p>Предикат <code>geocodequery/4</code> запрашивает на сервере объекты по названию <code>Name</code> и возвращает широту, долготу и идентификатор объекта. Библиотечная процедура <code>http_open</code> в качестве первого аргумента принимает список ключевых слов в формате <code>&lt;название структуры&gt;(&lt;значение&gt;)</code>. Элементы списка позволяют формировать строку URL&quot;=запроса к серверу из отдельных компонент. Важным элементом этого списка является <code>search/1</code> со списком параметров запроса к скрипту <code>search.php</code>. Параметр <code>format</code> указывает серверу на тот факт, что ответ (перечень объектов) надо возвращать в виде XML. Остальные значения понятны на интуитивном уровне.</p>
<p>Переменная <code>In</code> получает идентификатор входного потока данных, представляющих собой ответ сервера. Этот поток передается в процедуру интерпретации XML в виде текста. Текст транслируется в древовидное представление и помещается в переменную <code>S</code>. Переменная <code>S</code> затем унифицируется со структурой, чтобы разобрать корневой тег на отдельные элементы. Унификация помещает в <code>L</code> список тегов <code>&lt;place&gt;</code>. Этот список анализируется в предикате <code>geoplace/4</code>, где изымаются требуемые данные о местоположении найденных объектов.</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">geocodequery(<span class="dt">Name</span><span class="kw">,</span> <span class="dt">Lon</span><span class="kw">,</span> <span class="dt">Lat</span><span class="kw">,</span> <span class="dt">ID</span>)<span class="kw">:-</span>
        http_open([
            host(&#39;<span class="er">nominatim</span>.<span class="er">openstreetmap</span>.<span class="er">org</span>&#39;),
            path(&#39;/<span class="er">search</span>.<span class="er">php</span>&#39;),
            search([ q<span class="kw">=</span><span class="dt">Name</span>,
                     lang<span class="kw">=</span>ru,
                     format<span class="kw">=</span>xml ])
            ]<span class="kw">,</span> <span class="dt">In</span><span class="kw">,</span> [] )<span class="kw">,</span>
        load_xml(<span class="dt">In</span><span class="kw">,</span> <span class="dt">S</span><span class="kw">,</span> [])<span class="kw">,</span>
        <span class="dt">S</span><span class="kw">=</span>[element(searchresults<span class="kw">,</span><span class="dt">_</span><span class="kw">,</span>[<span class="dt">_</span><span class="fu">|</span><span class="dt">L</span>])]<span class="kw">,</span>
        <span class="fu">close</span>(<span class="dt">In</span>)<span class="kw">,</span> geoplace(<span class="dt">L</span><span class="kw">,</span> <span class="dt">Lon</span><span class="kw">,</span><span class="dt">Lat</span><span class="kw">,</span><span class="dt">ID</span>)<span class="kw">,</span>
        writef(<span class="ot">&quot;</span><span class="er">OSM</span><span class="ot">:</span><span class="al"> </span><span class="ot">%</span><span class="er">w</span><span class="al"> </span><span class="er">lon</span><span class="ot">:</span><span class="al"> </span><span class="ot">%</span><span class="er">w</span><span class="ot">,</span><span class="al"> </span><span class="er">lat</span><span class="ot">:%</span><span class="er">w</span><span class="ot">&quot;</span><span class="kw">,</span>
                [<span class="dt">Name</span>, <span class="dt">Lon</span>, <span class="dt">Lat</span>])<span class="kw">,</span><span class="fu">nl</span><span class="kw">.</span>

geoplace(element(place<span class="kw">,</span><span class="dt">Attrs</span><span class="kw">,</span><span class="dt">_</span>)<span class="kw">,</span> <span class="dt">Lon</span><span class="kw">,</span> <span class="dt">Lat</span><span class="kw">,</span> <span class="dt">Id</span>)<span class="kw">:-</span>
    option(lon(<span class="dt">Lon1</span>)<span class="kw">,</span><span class="dt">Attrs</span>)<span class="kw">,</span> atom_number(<span class="dt">Lon1</span><span class="kw">,</span><span class="dt">Lon</span>)<span class="kw">,</span>
    option(lat(<span class="dt">Lat1</span>)<span class="kw">,</span><span class="dt">Attrs</span>)<span class="kw">,</span> atom_number(<span class="dt">Lat1</span><span class="kw">,</span><span class="dt">Lat</span>)<span class="kw">,</span>
    option(place_id(<span class="dt">Id</span>)<span class="kw">,</span><span class="dt">Attrs</span>)<span class="kw">.</span>
geoplace([<span class="dt">X</span><span class="fu">|</span><span class="dt">_</span>]<span class="kw">,</span> <span class="dt">Lon</span><span class="kw">,</span> <span class="dt">Lat</span><span class="kw">,</span> <span class="dt">Id</span>)<span class="kw">:-</span>
    geoplace(<span class="dt">X</span><span class="kw">,</span> <span class="dt">Lon</span><span class="kw">,</span> <span class="dt">Lat</span><span class="kw">,</span> <span class="dt">Id</span>)<span class="kw">.</span>
geoplace([<span class="dt">_</span><span class="fu">|</span><span class="dt">T</span>]<span class="kw">,</span> <span class="dt">Lon</span><span class="kw">,</span> <span class="dt">Lat</span><span class="kw">,</span> <span class="dt">Id</span>)<span class="kw">:-</span>
    geoplace(<span class="dt">T</span><span class="kw">,</span> <span class="dt">Lon</span><span class="kw">,</span> <span class="dt">Lat</span><span class="kw">,</span> <span class="dt">Id</span>)<span class="kw">.</span></code></pre></div>
<p>Предикат <code>geoplace</code> в качестве первого параметра принимает структуру <code>element(place, &lt;список атрибутов&gt;, [])</code>, соответствующую тегу <code>place</code>, или список таких структур. Предикат возвращает геоданные об объектах, представленных в списке тегов <code>place</code>. Предикат <code>option(lon(Val),L)</code> ищет в списке <code>L</code> элемент вида <code>lon=Val</code> или <code>lon(Val)</code> и унифицирует соответствующим значением переменную <code>Val</code>. Процедура <code>atom_number(X,Y)</code> переводит атомы <code>X</code> (строки) в целые числа <code>Y</code> (и наоборот), если такое возможно.</p>
<p>Следующий текст представляет собой программу обеспечения доступа предикату <code>after/6</code> к геоданным по названию станции <code>Station</code>:</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">geocode(<span class="dt">Station</span><span class="kw">,</span> <span class="dt">Lon</span><span class="kw">,</span> <span class="dt">Lat</span><span class="kw">,</span> <span class="dt">Id</span>)<span class="kw">:-</span>
    <span class="kw">\+</span> <span class="dt">number</span>(<span class="dt">Station</span>)<span class="kw">,</span>
    station(<span class="dt">Station</span><span class="kw">,</span> <span class="dt">_</span><span class="kw">,</span> <span class="dt">Code</span><span class="kw">,</span> <span class="dt">_</span>)<span class="kw">,</span>
    geocode(<span class="dt">Code</span><span class="kw">,</span> <span class="dt">Lon</span><span class="kw">,</span> <span class="dt">Lat</span><span class="kw">,</span> <span class="dt">Id</span>)<span class="kw">.</span>

geocode(<span class="dt">Station</span><span class="kw">,</span> <span class="dt">Lon</span><span class="kw">,</span> <span class="dt">Lat</span><span class="kw">,</span> <span class="dt">Id</span>)<span class="kw">:-</span>
    <span class="dt">number</span>(<span class="dt">Station</span>)<span class="kw">,</span>
    geocache(<span class="dt">Station</span><span class="kw">,</span> <span class="dt">Lon</span><span class="kw">,</span> <span class="dt">Lat</span><span class="kw">,</span> <span class="dt">Id</span>)<span class="kw">,!.</span>

geocode(<span class="dt">Station</span><span class="kw">,</span> <span class="dt">Lon</span><span class="kw">,</span> <span class="dt">Lat</span><span class="kw">,</span> <span class="dt">Id</span>)<span class="kw">:-</span>
    <span class="dt">number</span>(<span class="dt">Station</span>)<span class="kw">,</span>
    station(<span class="dt">Name</span><span class="kw">,</span> <span class="dt">_</span><span class="kw">,</span> <span class="dt">Station</span><span class="kw">,</span> <span class="dt">_</span>)<span class="kw">,</span>
    geocodequery(<span class="dt">Name</span><span class="kw">,</span> <span class="dt">Lon</span><span class="kw">,</span> <span class="dt">Lat</span><span class="kw">,</span> <span class="dt">Id</span>)<span class="kw">,</span>
    sqlite_query_f(db<span class="kw">,</span>
     &#39;<span class="er">INSERT INTO geocache (station, lon, lat,</span>
<span class="er">         place_id) values</span>
<span class="er">         </span>(%<span class="er">w</span>,%<span class="er">w</span>,%<span class="er">w</span>,%<span class="er">w</span>)&#39;<span class="fu">-</span>[<span class="dt">Station</span>,<span class="dt">Lon</span>,<span class="dt">Lat</span>,<span class="dt">Id</span>]<span class="kw">,</span> <span class="dt">_</span>)<span class="kw">,!.</span></code></pre></div>
<p>Сначала <code>geocode/4</code> пытается найти данные в локальной базе данных координат <code>geocache/4</code>. Если попытка терпит неудачу, то осуществляется запрос к интернет“=сервису и запись результата в базу данных <code>geocache</code> для дальнейшего использования. В тексте SQL”=запроса <code>INSERT</code> <code>%w</code> обозначает место вставки строкового представления очередного значения из списка <code>[Station,Lon,…]</code>. Предикат <code>sqlite_query_f/3</code> реализован в программе следующим образом:</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">sqlite_query_f(<span class="dt">Conn</span><span class="kw">,</span> <span class="dt">S</span><span class="fu">-</span><span class="dt">Args</span><span class="kw">,</span> <span class="dt">ROW</span>)<span class="kw">:-</span>
    swritef(<span class="dt">Query</span><span class="kw">,</span> <span class="dt">S</span><span class="kw">,</span> <span class="dt">Args</span>)<span class="kw">,</span>
    sqlite_query(<span class="dt">Conn</span><span class="kw">,</span> <span class="dt">Query</span><span class="kw">,</span> <span class="dt">ROW</span>)<span class="kw">.</span></code></pre></div>
<p>Всеми преобразованиями <code>%w</code> в форматной строке <code>S</code> в конкретные значения из списка <code>Args</code> занимается библиотечный предикат <code>swritef/3</code>. Результат преобразования записывается в переменную <code>Query</code>.</p>
<p>Из приведенных примеров программного кода хорошо видно, что синтез двух реляционных языков программирования в рамках одного приложения производится достаточно просто, при этом не надо изобретать дополнительные конструкции, например циклы по строкам результата запроса. Поэтому, разрабатывая в следующий раз информационную систему со встроенными подсистемами математического моделирования, следует задуматься над вопросом о том, где в ней будут использоваться императивные языки программирования, а какие подсистемы следует реализовать на реляционном языке программирования.</p>
</section>
</section>
</section>
<section id="sec:britmuseum" class="level1">
<h1><span class="header-section-number">4</span> Поиск решения на основе перебора</h1>
<p>Иногда приходится сталкиваться с задачами, эффективный алгоритм решения которых очевидным образом реализовать не удается, либо недостаточно времени на анализ свойств задачи и поиск подходящего алгоритма. К ним относятся, например, <em>задачи с удовлетворением ограничений</em><a href="#fn19" class="footnoteRef" id="fnref19"><sup>19</sup></a>. Такие задачи являются математическими проблемами, определенными на конечном наборе объектов, чьи значения должны удовлетворять ряду ограничений, выраженных в виде неравенств и логических выражений. Исследования в области решения задач CSP ведутся достаточно давно, и по сей день актуальность этих исследований только повышается.</p>
<p>К задачам CSP сводятся многие задачи искусственного интеллекта, в частности планирование действий. Задачи удовлетворения ограничений довольно часто демонстрируют большую комбинаторную сложность, и практически для каждой индивидуальной задачи строятся собственные варианты эвристических алгоритмов<a href="#fn20" class="footnoteRef" id="fnref20"><sup>20</sup></a> их решения. Примеры известных задач: &lt;&lt;Восемь ферзей&gt;&gt;, &lt;&lt;Раскраска карты&gt;&gt;, &lt;&lt;Судоку&gt;&gt;, &lt;&lt;Поиск выполняющего набора&gt;&gt;, &lt;&lt;Составление расписания вуза&gt;&gt;.</p>
<p>Формально задачи CSP определяются следующим образом. Заданы вектор переменных <span class="math inline">\(\vec{V}=\langle v_1, v_2, \ldots, v_n\rangle\)</span>, где <span class="math inline">\(n\)</span> – количество переменных (натуральное); множество множеств <span class="math inline">\(D=\{ d_1, d_2, \ldots,\)</span> <span class="math inline">\(d_n\}\)</span>, где <span class="math inline">\(d_i\)</span> – непустое множество значений (домен), которые может принимать переменная <span class="math inline">\(v_i\)</span>, <span class="math inline">\(i=1,2,\ldots,n\)</span>. Задается также логическое условие <span class="math inline">\(P(\vec{V})=P(v_1,v_2,\ldots,v_n)\)</span>, которое истинно, если значения, присвоенные переменным <span class="math inline">\(v_i\)</span>, соответствуют условиям правильной комбинации. Например, для задачи &lt;&lt;Восемь ферзей&gt;&gt; <span class="math inline">\(P(\vec{V})\)</span> истинно, если все ферзи, расставленные на доске, не бьют друг друга. Иногда говорят о системе ограничений и о таких значениях переменных, при которых все ограничения выполняются (истинны). Систему ограничений можно записать как конъюнкцию индивидуальных ограничений, т. е. свести опять же к единому логическому условию <span class="math inline">\(P(\vec{V})\)</span>.</p>
<section id="алгоритм-british-museum" class="level2">
<h2><span class="header-section-number">4.1</span> Алгоритм British Museum</h2>
<p>Одним из простых алгоритмов, решающих задачи CSP, является алгоритм British Museum<a href="#fn21" class="footnoteRef" id="fnref21"><sup>21</sup></a>. Алгоритм реализует самый общий подход в задачах поиска решения на основе последовательной проверки всех возможностей (одну за одной), начиная с самых простых решений.</p>
<p>Алгоритм реализует концептуальный, а не практический подход, оперируя огромным количеством возможных альтернатив. В частности, в теории он представляет способ найти самую короткую программу, которая решает конкретную задачу. Например, можно сгенерировать все возможные программы длиной в один символ, проверить каждую программу – решает ли она эту задачу<a href="#fn22" class="footnoteRef" id="fnref22"><sup>22</sup></a>. Если среди односимвольных программ не найдено программы, решающей задачу, перейти к просмотру программ длиной в два символа, затем в три и т. д. В теории такой подход позволяет найти самую короткую программу, однако на практике перебор занимает недопустимо большое время вычислений (для многих задач больше, чем возраст Вселенной).</p>
<p>Название данный алгоритм получил после высказывания Аллена Ньювэлла, Дж. С. Шоу и Герберта А. Симона в 1958 году: &lt;&lt;Вполне уместно предположить, что если посадить обезьян за печатные машинки, можно через некоторое время воспроизвести все книги в известном Британском музее в Лондоне&gt;&gt;.</p>
<p>Несмотря на всю идеалистичность подхода, для задач небольшой размерности алгоритм вполне пригоден. Для начала, конечно, нет необходимости порождать программы, достаточно порождать варианты значений переменных <span class="math inline">\(v_i\)</span>, затем проверять выполнимость <span class="math inline">\(P(\vec{V})\)</span>. Рассмотрим пример задачи.</p>
<p>Разработать программу поиска номеров счастливых билетов, содержащих шесть цифр. Подсчитать их количество.</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">num(<span class="dt">X</span>) <span class="kw">:-</span> member(<span class="dt">X</span><span class="kw">,</span> [<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>])<span class="kw">.</span>
gen([])<span class="kw">.</span>
gen([<span class="dt">X</span><span class="fu">|</span><span class="dt">T</span>]) <span class="kw">:-</span> num(<span class="dt">X</span>)<span class="kw">,</span> gen(<span class="dt">T</span>)<span class="kw">.</span>

p([<span class="dt">A</span>,<span class="dt">B</span>,<span class="dt">C</span>, <span class="dt">D</span>,<span class="dt">E</span>,<span class="dt">F</span>]) <span class="kw">:-</span>
        <span class="dt">A</span> <span class="fu">+</span> <span class="dt">B</span> <span class="fu">+</span> <span class="dt">C</span> <span class="dt">=:=</span> <span class="dt">D</span> <span class="dt">+</span> <span class="dt">E</span> <span class="dt">+</span> <span class="dt">F</span><span class="kw">.</span>

lucky([<span class="dt">A</span>,<span class="dt">B</span>,<span class="dt">C</span>, <span class="dt">D</span>,<span class="dt">E</span>,<span class="dt">F</span>]) <span class="kw">:-</span>
        gen([<span class="dt">A</span>,<span class="dt">B</span>,<span class="dt">C</span>, <span class="dt">D</span>,<span class="dt">E</span>,<span class="dt">F</span>])<span class="kw">,</span>
        p([<span class="dt">A</span>,<span class="dt">B</span>,<span class="dt">C</span>, <span class="dt">D</span>,<span class="dt">E</span>,<span class="dt">F</span>])<span class="kw">.</span></code></pre></div>
<p>Программа при помощи предиката <code>gen/1</code> порождает идентификаторы билетов. Предикат <code>p/1</code> проверяет, является ли билет счастливым. Процедура порождения списка счастливых билетов оформлена в виде предиката <code>lucky/1</code> и в комментариях не нуждается. Для запуска программы выполним команду:</p>
<p>?- lucky(L).</p>
<p>L = [0,0,0,0,0,0] ? ; L = [0,0,1,0,0,1] ? ; L = [0,0,1,0,1,0] ? ; L = [0,0,1,1,0,0] ?</p>
<p>yes.</p>
<p>Для подсчета количества счастливых билетов создадим еще одно вспомогательное правило:</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">count(<span class="dt">N</span>) <span class="kw">:-</span> findall(<span class="dt">Ticket</span><span class="kw">,</span> lucky(<span class="dt">Ticket</span>)<span class="kw">,</span>
    <span class="dt">Tickets</span>)<span class="kw">,</span> length(<span class="dt">Tickets</span><span class="kw">,</span> <span class="dt">N</span>)<span class="kw">.</span></code></pre></div>
<p>Данное правило позволяет подсчитывать количество счастливых билетов, но не выводить их полный список на экран.</p>
<p>Выполним запрос (GNU-Prolog) <span class="citation" data-cites="GNUP"></span>:</p>
<p>?- count(N). N = 55252</p>
<p>(630 ms) yes.</p>
<p>Приведенные программы являются также примерами использования стандартных <code>member/2</code> и <code>length/2</code> предикатов обработки списков.</p>
<section id="сужение-области-поиска." class="level5">
<h5><span class="header-section-number">4.1.0.0.1</span> Сужение области поиска.</h5>
<p>Программа перебирает <span class="math inline">\(10^6\)</span> вариантов, из которых только около <span class="math inline">\(5,5\cdot 10^4\)</span> относятся к решению задачи. То есть примерно один из двадцати билетов – счастливый. Возникает вопрос: можно ли усовершенствовать программу, чтобы уменьшить количество неправильных вариантов и сэкономить время решения задачи на проверке этих неправильных вариантов?</p>
<p>Первым делом давайте попробуем вычислить значение переменной <code>F is A+B+C-D-E</code>. Добавим к программе следующий код:</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">lucky2([<span class="dt">A</span>,<span class="dt">B</span>,<span class="dt">C</span>, <span class="dt">D</span>,<span class="dt">E</span>,<span class="dt">F</span>]) <span class="kw">:-</span>
        gen([<span class="dt">A</span>,<span class="dt">B</span>,<span class="dt">C</span>, <span class="dt">D</span>,<span class="dt">E</span>])<span class="kw">,</span>
        <span class="dt">F</span> <span class="dt">is</span> <span class="dt">A+B+C-D-E</span><span class="kw">,</span>
        num(<span class="dt">F</span>)<span class="kw">,</span>
        p([<span class="dt">A</span>,<span class="dt">B</span>,<span class="dt">C</span>, <span class="dt">D</span>,<span class="dt">E</span>,<span class="dt">F</span>])<span class="kw">.</span>

count2(<span class="dt">N</span>) <span class="kw">:-</span> findall(<span class="dt">Ticket</span><span class="kw">,</span> lucky2(<span class="dt">Ticket</span>)<span class="kw">,</span>
        <span class="dt">Tickets</span>)<span class="kw">,</span> length(<span class="dt">Tickets</span><span class="kw">,</span> <span class="dt">N</span>)<span class="kw">.</span></code></pre></div>
<p>?- count2(N). N = 55252</p>
<p>(133 ms) yes.</p>
<p>Получено такое же количество решений, но за время, в пять раз меньшее. Вычисленное значение <code>F</code> может быть отрицательным и больше 9, что противоречит условиям задачи, поэтому в новую процедуру порождения билетов необходимо добавить дополнительную проверку <code>num(F)</code>, которая выполняется, если <code>F</code> находится в требуемом диапазоне. Теперь порождается в 10 раз меньше билетов, даже с учетом тех, где <code>F</code> находится вне диапазона. То есть каждый второй сгенерированный билет – счастливый. Если убрать уже ненужную повторную проверку <code>p/1</code>, то скорость исполнения программы увеличится еще на 30% до 106 микросекунд, т. е. уже более чем в 6 раз быстрее первоначальной:</p>
<p>?- count2(N). N = 55252</p>
<p>(103 ms) yes.</p>
</section>
<section id="дополнительное-ускорение." class="level5">
<h5><span class="header-section-number">4.1.0.0.2</span> Дополнительное ускорение.</h5>
<p>Теперь попробуем найти два последних числа. Выражение <code>A+B+C-D</code> изменяется в пределах <span class="math inline">\(-9,\)</span> <span class="math inline">\(-8,\)</span> <span class="math inline">\(\ldots,0,1,\ldots,26,27\)</span>: от <code>0+0+0-9</code> до <code>9+9+9-0</code>. Варианты, когда результат выражения – отрицательный, заведомо неподходящие, так же как если этот результат больше <span class="math inline">\(18\)</span>, <code>9+9+9-9</code>. Можно еще усовершенствовать алгоритм, но оставим это в качестве упражнения. Теперь надо разработать подпрограммы, которые для диапазона <span class="math inline">\(0,1,\ldots,18\)</span> будут решать просто отдельную переборную задачу: задано число <code>S</code><span class="math inline">\(\in 0,1,\ldots,18\)</span>, найти два слагаемых <code>E</code> и <code>F</code>, дающих в сумме <code>S</code>. Дополним программу следующим кодом:</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">lucky3([<span class="dt">A</span>,<span class="dt">B</span>,<span class="dt">C</span>, <span class="dt">D</span>,<span class="dt">E</span>,<span class="dt">F</span>]) <span class="kw">:-</span>
        gen([<span class="dt">A</span>,<span class="dt">B</span>,<span class="dt">C</span>, <span class="dt">D</span>])<span class="kw">,</span>
        <span class="dt">S</span> <span class="dt">is</span> <span class="dt">A+B+C-D</span><span class="kw">,</span>
        <span class="dt">S</span> <span class="dt">&gt;=</span> <span class="dv">0</span><span class="kw">,</span> <span class="dt">S=&lt;</span><span class="dv">18</span><span class="kw">,</span>
        gen2(<span class="dt">S</span><span class="kw">,</span> <span class="dt">E</span><span class="kw">,</span><span class="dt">F</span>)<span class="kw">.</span>

count3(<span class="dt">N</span>) <span class="kw">:-</span> findall(<span class="dt">Ticket</span><span class="kw">,</span> lucky3(<span class="dt">Ticket</span>)<span class="kw">,</span>
        <span class="dt">Tickets</span>)<span class="kw">,</span> length(<span class="dt">Tickets</span><span class="kw">,</span> <span class="dt">N</span>)<span class="kw">.</span>

gen2(<span class="dv">0</span><span class="kw">,</span><span class="dv">0</span><span class="kw">,</span><span class="dv">0</span>)<span class="kw">:-!.</span>  <span class="co">% Выделим отдельно наглядные</span>
gen2(<span class="dv">18</span><span class="kw">,</span><span class="dv">9</span><span class="kw">,</span><span class="dv">9</span>)<span class="kw">:-!.</span> <span class="co">% тривиальные варианты.</span>
gen2(<span class="dt">N</span><span class="kw">,</span><span class="dt">A</span><span class="kw">,</span><span class="dt">B</span>)<span class="kw">:-</span><span class="dt">N&lt;</span><span class="dv">10</span><span class="kw">,</span> <span class="kw">!,</span> igen(<span class="dt">N</span><span class="kw">,</span><span class="dt">A</span>)<span class="kw">,</span> <span class="dt">B</span> <span class="dt">is</span> <span class="dt">N</span> <span class="dt">-</span> <span class="dt">A</span><span class="kw">.</span>
gen2(<span class="dt">N</span><span class="kw">,</span><span class="dt">A</span><span class="kw">,</span><span class="dt">B</span>)<span class="kw">:-</span><span class="dt">D</span> <span class="dt">is</span> <span class="dt">N</span> <span class="dt">-</span> <span class="dv">9</span><span class="kw">,</span> <span class="dt">Z</span> <span class="dt">is</span> <span class="dv">9</span> <span class="dt">-</span> <span class="dt">D</span><span class="kw">,</span>
        igen(<span class="dt">Z</span><span class="kw">,</span> <span class="dt">A1</span>)<span class="kw">,</span> <span class="dt">A</span> <span class="dt">is</span> <span class="dt">A1</span> <span class="dt">+</span> <span class="dt">D</span><span class="kw">,</span> <span class="dt">B</span> <span class="dt">is</span> <span class="dt">N</span> <span class="dt">-</span> <span class="dt">A</span><span class="kw">.</span>

<span class="co">% igen(N, A) для A порождает последовательности</span>
<span class="co">% 0,1,2,...,N</span>
igen(<span class="dt">N</span><span class="kw">,</span> <span class="dt">A</span>) <span class="kw">:-</span> <span class="dt">N&gt;=</span><span class="dv">1</span><span class="kw">,</span> <span class="dt">M</span> <span class="dt">is</span> <span class="dt">N</span> <span class="dt">-</span> <span class="dv">1</span><span class="kw">,</span> igen(<span class="dt">M</span><span class="kw">,</span> <span class="dt">A</span>)<span class="kw">.</span>
igen(<span class="dt">N</span><span class="kw">,</span> <span class="dt">N</span>)<span class="kw">.</span></code></pre></div>
<p>Запускаем запрос:</p>
<p>?- count3(N). N = 55252</p>
<p>(47 ms) yes.</p>
<p>Теперь программа работает в 13 с лишним раз быстрее первоначальной и в два раза быстрее предыдущей, т. е. примерно один из трех билетов не является счастливым. Конечно, программу можно совершенствовать дальше: перейти к порождению первых трех цифр и, отталкиваясь от их суммы, по аналогии с последним примером порождать соответствующие последовательности. Однако необходимо заметить, что программа<a href="#fn23" class="footnoteRef" id="fnref23"><sup>23</sup></a> постепенно становится сложной, а текст значительно хуже воспринимаемым.</p>
</section>
</section>
</section>
<section id="cha:compalgebra" class="level1">
<h1><span class="header-section-number">5</span> Компьютерная алгебра</h1>
<p>Старшее поколение преподавателей недовольно уровнем знаний студентов вузов в области математического анализа, особенно в части знаний оператора дифференцирования. Студентам не разрешают пользоваться популярными системами компьютерной алгебры. По&quot;=видимому, сказывается недостаточная практика в этом направлении. Действительно, прежде чем <em>автоматизировать</em> некоторую <em>творческую деятельность</em>, необходимо детально в ней разобраться, и, самое главное, разбираться в случае необходимости.</p>
<p>Давайте продвинемся в решении двух проблем сразу – повторим дифференцирование и разработаем ядро своей компьютерной алгебры. В качестве побочного продукта получим навыки <em>обработки символьной информации</em> – решения важного класса задач ИИ.</p>
<section id="sec:" class="level2">
<h2><span class="header-section-number">5.1</span> Символьное дифференцирование</h2>
<p>Частную производную функции <span class="math inline">\(f(x,y,\ldots)\)</span> по переменной <span class="math inline">\(x\)</span> обозначают как <span class="math display">\[f^{\prime}_x,\;f_x,\;\frac{\partial }{\partial x}f,\;\frac{\partial f}{\partial x}, \;\mbox{или}\; \frac{d_x f}{dx}.\]</span> В языке Prolog обозначим частную производную предикатом <code>d(F,X,DF)</code>, где <code>F</code> – функция, производная <code>DF</code> которой &lt;&lt;берется&gt;&gt; по переменной <code>X</code>. Программу нахождения производных из функций (выражений) начнем писать с самых простых вариантов: производной переменной, константы и атома.</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">d(<span class="dt">Y</span><span class="kw">,</span><span class="dt">X</span><span class="kw">,</span><span class="dv">1</span>)<span class="kw">:-</span><span class="dt">var</span>(<span class="dt">X</span>)<span class="kw">,</span><span class="dt">var</span>(<span class="dt">Y</span>)<span class="kw">,</span>
    <span class="dt">Y</span><span class="fu">==</span><span class="dt">X</span><span class="kw">,!.</span>
d(<span class="dt">Y</span><span class="kw">,</span><span class="dt">X</span><span class="kw">,</span><span class="dv">0</span>)<span class="kw">:-</span>
    <span class="dt">var</span>(<span class="dt">Y</span>)<span class="kw">,</span><span class="dt">var</span>(<span class="dt">X</span>)<span class="kw">,!.</span>
d(<span class="dt">C</span><span class="kw">,</span><span class="dt">_</span><span class="kw">,</span><span class="dv">0</span>)<span class="kw">:-</span><span class="dt">atomic</span>(<span class="dt">C</span>)<span class="kw">,!.</span></code></pre></div>
<p>Предикат &lt;&lt;<code>==/2</code>&gt;&gt; позволяет определять, не с одной ли той же переменной унифицированы <code>X</code> и <code>Y</code>. Предикат <code>var/1</code> проверяет, является ли аргумент все еще переменной или нет. Выполним тестовые запросы:</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span class="fu">?-</span> d(<span class="dt">X</span><span class="kw">,</span><span class="dt">X</span><span class="kw">,</span><span class="dt">D</span>)<span class="kw">.</span>    |    <span class="fu">?-</span> <span class="dt">X</span><span class="kw">=</span><span class="dt">Y</span><span class="kw">,</span>d(<span class="dt">Y</span><span class="kw">,</span><span class="dt">X</span><span class="kw">,</span><span class="dt">D</span>)<span class="kw">.</span>
<span class="dt">D</span> <span class="kw">=</span> <span class="dv">1</span><span class="kw">.</span>          |    <span class="dt">X</span> <span class="kw">=</span> <span class="dt">Y</span><span class="kw">,</span>
                |    <span class="dt">D</span> <span class="kw">=</span> <span class="dv">1</span><span class="kw">.</span>
<span class="fu">?-</span> d(<span class="dt">Y</span><span class="kw">,</span><span class="dt">X</span><span class="kw">,</span><span class="dt">D</span>)<span class="kw">.</span>    |
<span class="dt">Y</span> <span class="kw">=</span> <span class="dt">A</span><span class="kw">,</span>          |    <span class="fu">?-</span> d(<span class="dv">1</span><span class="kw">,</span><span class="dt">X</span><span class="kw">,</span><span class="dt">D</span>)<span class="kw">.</span>
<span class="dt">X</span> <span class="kw">=</span> <span class="dt">B</span><span class="kw">,</span>          |    <span class="dt">D</span> <span class="kw">=</span> <span class="dv">0</span><span class="kw">.</span>
<span class="dt">D</span> <span class="kw">=</span> <span class="dv">0</span><span class="kw">.</span>          |
                |
<span class="fu">?-</span> d(a<span class="kw">,</span><span class="dt">X</span><span class="kw">,</span><span class="dt">D</span>)<span class="kw">.</span>    |
<span class="dt">D</span> <span class="kw">=</span> <span class="dv">0</span><span class="kw">.</span>          |</code></pre></div>
<p>Следующий этап – реализация правила преобразования арифметических операций:</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">d(<span class="dt">U</span><span class="fu">+</span><span class="dt">V</span><span class="kw">,</span><span class="dt">X</span><span class="kw">,</span><span class="dt">DU</span><span class="fu">+</span><span class="dt">DV</span>)<span class="kw">:-!,</span>   |   d(<span class="dt">U</span><span class="fu">*</span><span class="dt">V</span><span class="kw">,</span><span class="dt">X</span><span class="kw">,</span><span class="dt">DU</span><span class="fu">*</span><span class="dt">V</span><span class="fu">+</span><span class="dt">DV</span><span class="fu">*</span><span class="dt">U</span>)<span class="kw">:-!,</span>
        d(<span class="dt">U</span><span class="kw">,</span><span class="dt">X</span><span class="kw">,</span><span class="dt">DU</span>)<span class="kw">,</span>   |           d(<span class="dt">U</span><span class="kw">,</span><span class="dt">X</span><span class="kw">,</span><span class="dt">DU</span>)<span class="kw">,</span>
        d(<span class="dt">V</span><span class="kw">,</span><span class="dt">X</span><span class="kw">,</span><span class="dt">DV</span>)<span class="kw">.</span>   |           d(<span class="dt">V</span><span class="kw">,</span><span class="dt">X</span><span class="kw">,</span><span class="dt">DV</span>)<span class="kw">.</span>
                     |
d(<span class="dt">U</span><span class="fu">-</span><span class="dt">V</span><span class="kw">,</span><span class="dt">X</span><span class="kw">,</span><span class="dt">DU</span><span class="fu">-</span><span class="dt">DV</span>)<span class="kw">:-!,</span>   |   d(<span class="dt">U</span><span class="fu">/</span><span class="dt">V</span><span class="kw">,</span><span class="dt">X</span><span class="kw">,</span>(<span class="dt">DU</span><span class="fu">*</span><span class="dt">V</span><span class="fu">-</span><span class="dt">DV</span><span class="fu">*</span><span class="dt">U</span>)<span class="fu">/</span>(<span class="dt">V</span><span class="fu">^</span><span class="dv">2</span>))<span class="kw">:-!,</span>
        d(<span class="dt">U</span><span class="kw">,</span><span class="dt">X</span><span class="kw">,</span><span class="dt">DU</span>)<span class="kw">,</span>   |           d(<span class="dt">U</span><span class="kw">,</span><span class="dt">X</span><span class="kw">,</span><span class="dt">DU</span>)<span class="kw">,</span>
        d(<span class="dt">V</span><span class="kw">,</span><span class="dt">X</span><span class="kw">,</span><span class="dt">DV</span>)<span class="kw">.</span>   |           d(<span class="dt">V</span><span class="kw">,</span><span class="dt">X</span><span class="kw">,</span><span class="dt">DV</span>)<span class="kw">.</span></code></pre></div>
<p>Теперь рассмотрим суперпозицию функций, формула является рекурсивной (цепной): <span class="math display">\[\frac{\partial}{\partial x}f(g(x)) = \frac{\partial f}{\partial g}\frac{\partial g}{\partial x}.\]</span> Соответствующее правило Prolog будет следующим:</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">d(<span class="dt">E</span><span class="kw">,</span><span class="dt">X</span><span class="kw">,</span> <span class="dt">DExpF</span><span class="fu">*</span><span class="dt">DExp</span>)<span class="kw">:-</span>
    <span class="dt">E</span><span class="fu">=..</span>[<span class="dt">Atom</span>, <span class="dt">Exp</span>]<span class="kw">,</span>      <span class="co">% (1)</span>
    <span class="dt">atom</span>(<span class="dt">Atom</span>)<span class="kw">,!,</span>         <span class="co">% (2)</span>
    d(<span class="dt">Exp</span><span class="kw">,</span><span class="dt">X</span><span class="kw">,</span><span class="dt">DExp</span>)<span class="kw">,</span>        <span class="co">% (3)</span>
    df(<span class="dt">Atom</span><span class="kw">,</span> <span class="dt">Exp</span><span class="kw">,</span> <span class="dt">DExpF</span>)<span class="kw">.</span> <span class="co">% (4)</span></code></pre></div>
<p>Сначала надо удостовериться, что <code>E</code> – это функция. Для этого попробуем представить <code>E</code> в виде списка <code>[Atom, Exp]</code> (1,2), где <code>Atom</code> – это название функции, а <code>Exp</code> – выражение (аргумент). Затем в строке (3) производим построение производной из аргумента, а в (4) – обращение к набору правил соответствия функций выражениям&quot;=производным:</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">df(sin<span class="kw">,</span><span class="dt">E</span><span class="kw">,</span> cos(<span class="dt">E</span>))<span class="kw">.</span>
df(cos<span class="kw">,</span><span class="dt">E</span><span class="kw">,</span> <span class="fu">-</span>sin(<span class="dt">E</span>))<span class="kw">.</span>
df(ln<span class="kw">,</span><span class="dt">E</span><span class="kw">,</span> <span class="dv">1</span><span class="fu">/</span><span class="dt">E</span>)<span class="kw">.</span>
df(exp<span class="kw">,</span><span class="dt">E</span><span class="kw">,</span> exp(<span class="dt">E</span>))<span class="kw">.</span></code></pre></div>
<p>Предикат <code>df(Fun,Exp, DExp)</code> переводит функцию <code>Fun</code> и ее аргумент <code>Exp</code> в выражение, представляющее производную <code>DExp</code>. В этот список необходимо самостоятельно добавить другие известные функции.</p>
<p>Перейдем к дифференцированию конкретных выражений. Производная степенной функции, например, реализуется так:</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">d(<span class="dt">E</span><span class="fu">^</span><span class="dt">N</span><span class="kw">,</span><span class="dt">X</span><span class="kw">,</span> <span class="dt">N</span><span class="fu">*</span><span class="dt">E</span><span class="fu">^</span>(<span class="dt">N1</span>)<span class="fu">*</span><span class="dt">DE</span>)<span class="kw">:-!,</span>
        d(<span class="dt">E</span><span class="kw">,</span><span class="dt">X</span><span class="kw">,</span><span class="dt">DE</span>)<span class="kw">,</span>
        <span class="dt">N1</span> <span class="dt">is</span> <span class="dt">N-</span><span class="dv">1</span><span class="kw">.</span></code></pre></div>
<p>Проверим программу на нескольких выражениях:</p>
<p>?- d(X^2, X, D). D = 2*X^ (2-1)*1.</p>
<p>?- d(sin(X^2), X, D). D = cos(X^2)* (2*X^ (2-1)*1).</p>
<p>?- d(sin(cos(X^2))*ln(X+Y), X, D). D = cos(cos(X^2))* (-sin(X^2)* (2*X^ (2-1)*1))*ln(X+Y)+1/ (X+Y)* (1+0)*sin(cos(X^2)).</p>
<p>Результат требует дальнейшего совершенствования – сокращения выражений. Для этого реализуем два набора правил: фасадный<a href="#fn24" class="footnoteRef" id="fnref24"><sup>24</sup></a> предикат <code>sim/2</code>, предназначенный для сокращения выражений, и предикат <code>r/2</code>, представляющий собой элементарные упрощающие преобразования. Если элементарное преобразование удалось, то <code>r/2</code> истинен, иначе он терпит неудачу.</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">sim(<span class="dt">X</span><span class="kw">,</span> <span class="dt">X</span>)<span class="kw">:-</span>    <span class="co">% Переменная не сокращается.</span>
    <span class="dt">var</span>(<span class="dt">X</span>)<span class="kw">,!.</span>
sim(<span class="dt">E</span><span class="kw">,</span> <span class="dt">R</span>)<span class="kw">:-</span>    <span class="co">% Сделать один шаг упрощения.</span>
    r(<span class="dt">E</span><span class="kw">,</span><span class="dt">E1</span>)<span class="kw">,!,</span> <span class="co">% Если удалось, то</span>
    sim(<span class="dt">E1</span><span class="kw">,</span><span class="dt">R</span>)<span class="kw">.</span> <span class="co">% сократить результат еще.</span>
sim(<span class="dt">E</span><span class="kw">,</span><span class="dt">E</span>)<span class="kw">.</span>      <span class="co">% Выражение не сокращается.</span></code></pre></div>
<p>Реализация <code>sim/2</code> сильно походит на сортировку списка методом &lt;&lt;пузырька&gt;&gt;. Теперь рассмотрим элементарные преобразования:</p>
<div class="sourceCode" texcomments=""><pre class="sourceCode prolog"><code class="sourceCode prolog">r(<span class="dt">A</span><span class="fu">+</span><span class="dt">B</span><span class="kw">,</span> <span class="dt">A</span>)<span class="kw">:-</span><span class="dt">B</span>=@=<span class="dv">0</span><span class="kw">,!.</span>  <span class="co">% A+0 $\to$ A</span>
r(<span class="dt">B</span><span class="fu">+</span><span class="dt">A</span><span class="kw">,</span> <span class="dt">A</span>)<span class="kw">:-</span><span class="dt">B</span>=@=<span class="dv">0</span><span class="kw">,!.</span>  <span class="co">% 0+A $\to$ A</span>
r(<span class="dt">A</span><span class="fu">*</span><span class="dt">B</span><span class="kw">,</span> <span class="dt">A</span>)<span class="kw">:-</span><span class="dt">B</span>=@=<span class="dv">1</span><span class="kw">,!.</span>  <span class="co">% A*1 $\to$ A</span>
r(<span class="dt">B</span><span class="fu">*</span><span class="dt">A</span><span class="kw">,</span> <span class="dt">A</span>)<span class="kw">:-</span><span class="dt">B</span>=@=<span class="dv">1</span><span class="kw">,!.</span>  <span class="co">% 1*A $\to$ A</span>
r(<span class="dt">_</span><span class="fu">*</span><span class="dt">B</span><span class="kw">,</span> <span class="dv">0</span>)<span class="kw">:-</span><span class="dt">B</span>=@=<span class="dv">0</span><span class="kw">,!.</span>  <span class="co">% A*0 $\to$ 0</span>
r(<span class="dt">B</span><span class="fu">*</span><span class="dt">_</span><span class="kw">,</span> <span class="dv">0</span>)<span class="kw">:-</span><span class="dt">B</span>=@=<span class="dv">0</span><span class="kw">,!.</span>  <span class="co">% 0*A $\to$ 0</span>
r(<span class="dt">A</span><span class="fu">^</span><span class="dt">B</span><span class="kw">,</span> <span class="dt">A</span>)<span class="kw">:-</span><span class="dt">B</span>=@=<span class="dv">1</span><span class="kw">,!.</span>  <span class="co">% $A^1$ $\to$ A</span>
r(<span class="dt">A</span><span class="fu">^</span><span class="dt">B</span><span class="kw">,</span> <span class="dv">1</span>)<span class="kw">:-</span><span class="dt">B</span>=@=<span class="dv">0</span><span class="kw">,</span><span class="dt">A</span>\=@=<span class="dv">0</span><span class="kw">,!.</span>  <span class="co">% (1)</span>
r(<span class="dt">A</span><span class="fu">/</span><span class="dt">B</span><span class="kw">,</span> <span class="dt">A</span>)<span class="kw">:-</span><span class="dt">B</span>=@=<span class="dv">1</span><span class="kw">,!.</span>  <span class="co">% A/1 $\to$ A</span>
r(<span class="dt">B</span><span class="fu">/</span><span class="dt">A</span><span class="kw">,</span> <span class="dt">A</span><span class="fu">^</span>(<span class="fu">-</span><span class="dv">1</span>))<span class="kw">:-</span><span class="dt">B</span>=@=<span class="dv">1</span><span class="kw">,!.</span>    <span class="co">% (2)</span></code></pre></div>
<p>В строке (1) рассматривается случай <span class="math inline">\(a^0=a\)</span>, при этом исключается неопределенность <span class="math inline">\(0^0=\frac{0}{0}\)</span>. В строке (2) <span class="math inline">\(\frac{1}{x}\)</span> заменяется на <span class="math inline">\(x^{-1}\)</span>. В перечисленных правилах используется специальный вид унификации <code>=@=/2</code>, который проверяет структурную эквивалентность аргументов. Представим несколько примеров<a href="#fn25" class="footnoteRef" id="fnref25"><sup>25</sup></a> <span class="citation" data-cites="SWIP"></span>:</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span class="dv">1</span>    a =@= <span class="dt">A</span>    <span class="kw">false</span>
<span class="dv">2</span>    <span class="dt">A</span> =@= <span class="dt">B</span>    <span class="kw">true</span>
<span class="dv">3</span>    x(<span class="dt">A</span><span class="kw">,</span><span class="dt">A</span>) =@= x(<span class="dt">B</span><span class="kw">,</span><span class="dt">C</span>)  <span class="kw">false</span>
<span class="dv">4</span>    x(<span class="dt">A</span><span class="kw">,</span><span class="dt">A</span>) =@= x(<span class="dt">B</span><span class="kw">,</span><span class="dt">B</span>)  <span class="kw">true</span>
<span class="dv">5</span>    x(<span class="dt">A</span><span class="kw">,</span><span class="dt">A</span>) =@= x(<span class="dt">A</span><span class="kw">,</span><span class="dt">B</span>)  <span class="kw">false</span>
<span class="dv">6</span>    x(<span class="dt">A</span><span class="kw">,</span><span class="dt">B</span>) =@= x(<span class="dt">C</span><span class="kw">,</span><span class="dt">D</span>)  <span class="kw">true</span></code></pre></div>
<p>То есть в сокращаемых выражениях нам важно распознавать правильно, где переменная, а где константа во входных параметрах. Реализация первого правила <code>r/2</code> в виде <code>r(A+0, A):-!</code> приводит к неправильному ответу на запрос<a href="#fn26" class="footnoteRef" id="fnref26"><sup>26</sup></a>:</p>
<p>?- r(2+X, R). X = 0, R = 2.</p>
<p>Автоматическая унификация Prolog по умолчанию при сопоставлении двух выражений подставляет переменные, символы, числа и другие термы вместо переменных в правое и в левое выражения так, чтобы они стали одинаковыми. В данном примере овеществляется унификация <code>2+X=A+0</code>. Если вместо <code>A</code> подставить <code>2</code>, а вместо <code>X</code> – <code>0</code>, то получим выражение <code>2+0=2+0</code>. В нашем редукторе необходимо сокращаемые переменные сохранить как переменные , чтобы потом можно было вычислять значения производных в точке:</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">r(<span class="dt">A</span><span class="fu">+</span><span class="dt">B</span><span class="kw">,</span> <span class="dt">AB</span>)<span class="kw">:-</span><span class="dt">number</span>(<span class="dt">A</span>)<span class="kw">,</span><span class="dt">number</span>(<span class="dt">B</span>)<span class="kw">,!,</span><span class="dt">AB</span> <span class="dt">is</span> <span class="dt">A+B</span><span class="kw">.</span>
r(<span class="dt">A</span><span class="fu">*</span><span class="dt">B</span><span class="kw">,</span> <span class="dt">AB</span>)<span class="kw">:-</span><span class="dt">number</span>(<span class="dt">A</span>)<span class="kw">,</span><span class="dt">number</span>(<span class="dt">B</span>)<span class="kw">,!,</span><span class="dt">AB</span> <span class="dt">is</span> <span class="dt">A*B</span><span class="kw">.</span>
r(<span class="dt">A</span><span class="fu">+</span><span class="dt">B</span><span class="kw">,</span> <span class="dt">B</span><span class="fu">+</span><span class="dt">A</span>)<span class="kw">:-</span><span class="dt">number</span>(<span class="dt">B</span>)<span class="kw">,!.</span>
r(<span class="dt">A</span><span class="fu">*</span><span class="dt">B</span><span class="kw">,</span> <span class="dt">B</span><span class="fu">*</span><span class="dt">A</span>)<span class="kw">:-</span><span class="dt">number</span>(<span class="dt">B</span>)<span class="kw">,!.</span>

r(<span class="dt">A</span><span class="fu">+</span><span class="dt">B</span><span class="fu">+</span><span class="dt">C</span><span class="kw">,</span><span class="dt">AB</span><span class="fu">+</span><span class="dt">C</span>)<span class="kw">:-</span><span class="dt">number</span>(<span class="dt">A</span>)<span class="kw">,</span><span class="dt">number</span>(<span class="dt">B</span>)<span class="kw">,!,</span> <span class="dt">AB</span> <span class="dt">is</span> <span class="dt">A+B</span><span class="kw">.</span>
r(<span class="dt">A</span><span class="fu">*</span><span class="dt">B</span><span class="fu">*</span><span class="dt">C</span><span class="kw">,</span><span class="dt">AB</span><span class="fu">*</span><span class="dt">C</span>)<span class="kw">:-</span><span class="dt">number</span>(<span class="dt">A</span>)<span class="kw">,</span><span class="dt">number</span>(<span class="dt">B</span>)<span class="kw">,!,</span> <span class="dt">AB</span> <span class="dt">is</span> <span class="dt">A*B</span><span class="kw">.</span>
r(<span class="dt">A</span><span class="fu">+</span><span class="dt">D</span><span class="kw">,</span> <span class="dt">A</span><span class="fu">+</span><span class="dt">B</span><span class="fu">+</span><span class="dt">C</span>)<span class="kw">:-</span> <span class="kw">\+</span> <span class="dt">D</span>=@=<span class="dt">_</span><span class="kw">,</span> <span class="dt">D</span><span class="kw">=</span>(<span class="dt">B</span><span class="fu">+</span><span class="dt">C</span>)<span class="kw">,!.</span>
r(<span class="dt">A</span><span class="fu">*</span><span class="dt">D</span><span class="kw">,</span> <span class="dt">A</span><span class="fu">*</span><span class="dt">B</span><span class="fu">*</span><span class="dt">C</span>)<span class="kw">:-</span> <span class="kw">\+</span> <span class="dt">D</span>=@=<span class="dt">_</span><span class="kw">,</span> <span class="dt">D</span><span class="kw">=</span>(<span class="dt">B</span><span class="fu">*</span><span class="dt">C</span>)<span class="kw">,!.</span></code></pre></div>
<p>Эти правила предназначены для переупорядочения слагаемых и сомножителей таким образом, чтобы можно было сократить числовые выражения. Два последних правила раскрывают &lt;&lt;ненужные скобки&gt;&gt;, перестраивая древовидное представление формулы. Набор правил не полон, есть возможность их пополнить, в частности можно алгоритмизировать операции вычитания и деления. На самом деле цепочки последовательных операций сложения и вычитания, умножения и деления следует представить в виде списков слагаемых и сомножителей. Затем надо производить упорядочение элементов этого списка согласно правилам представления полиномов, поиск и сокращение однородных членов. Оставим эту задачу как упражнение.</p>
<p>Следующая группа правил пытается просто вычислить выражение, если такое возможно. Если не получается вычислить, то нужно попытаться сократить аргументы:</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">r(<span class="dt">E</span><span class="kw">,</span><span class="dt">R</span>)<span class="kw">:-</span>
    <span class="dt">compound</span>(<span class="dt">E</span>)<span class="kw">,</span>
    <span class="dt">ground</span>(<span class="dt">E</span>)<span class="kw">,!,</span>
    <span class="dt">R</span> <span class="dt">is</span> <span class="dt">E</span><span class="kw">.</span>

r(<span class="dt">E</span><span class="kw">,</span><span class="dt">R</span>)<span class="kw">:-</span>
    <span class="dt">compound</span>(<span class="dt">E</span>)<span class="kw">,</span>
    <span class="dt">E</span><span class="fu">=..</span>[<span class="dt">F</span><span class="fu">|</span><span class="dt">Args</span>]<span class="kw">,!,</span>
    r(<span class="dt">Args</span><span class="kw">,</span><span class="dt">SArgs</span>)<span class="kw">,</span>
    <span class="dt">R</span><span class="fu">=..</span>[<span class="dt">F</span><span class="fu">|</span><span class="dt">SArgs</span>]<span class="kw">,</span>
    <span class="dt">E</span>\=@=<span class="dt">R</span><span class="kw">.</span>

r([]<span class="kw">,</span>[])<span class="kw">:-!.</span>
r([<span class="dt">X</span><span class="fu">|</span><span class="dt">T</span>]<span class="kw">,</span>[<span class="dt">SX</span><span class="fu">|</span><span class="dt">ST</span>])<span class="kw">:-!,</span>
    sim(<span class="dt">X</span><span class="kw">,</span><span class="dt">SX</span>)<span class="kw">,</span>
    r(<span class="dt">T</span><span class="kw">,</span><span class="dt">ST</span>)<span class="kw">.</span></code></pre></div>
<p>Предикат <code>compound/1</code> проверяет, является ли его аргумент сложным выражением, а <code>ground/1</code> – выражением, не содержащим свободных переменных. Первое правило, вообще говоря, реализовано некорректно: оно будет порождать исключительную ситуацию, если в выражении встретится символ или список, то есть что&quot;=то, над чем невозможно выполнить арифметическую операцию.</p>
<p>Второе правило преобразует структуру к списку, аналогично тому, как мы делали с производной суперпозиции функции. Затем производится сокращение выражений в аргументах функции. В конце выражение собирается из отдельных компонент в результат сокращения. Если получилась структура, отличная от исходной, то правило завершается удачно.</p>
<p>Последние два правила рекурсивно обрабатывают список аргументов. Теперь рассмотрим пример использования компьютерной алгебры в программе расчета оптимального управления.</p>
</section>
<section id="sec:optcontr" class="level2">
<h2><span class="header-section-number">5.2</span> Оптимальное управление</h2>
<p>Разработка программ численного решения дифференциальных уравнений, расчеты оптимального управления связаны с необходимостью аналитических вычислений формул производных различных функций и их реализации в виде программного кода. В принципе, вместо реализации этого этапа разработки программ можно использовать численное дифференцирование и ограничиться только реализацией исходных функций. Но, как практически любой численный метод, численное дифференцирование а) реализуется как итеративная процедура, которая затрачивает процессорное время на вычисление значения функции в нескольких точках; б) вносит дополнительную погрешность вычисления, которая заложена уже в самом методе. Использование аналитического вычисления производных в целом избавляет программный код от этих недостатков.</p>
<p>В <span class="citation" data-cites="pontr"></span> рассмотрен метод вычисления оптимального управления, названного в честь его автора, академика Льва Семеновича Понтрягина, &lt;&lt;Принцип максимума Л. С. Понтрягина&gt;&gt;. В книге вводится обозначение <span class="math display">\[{\mathbfit{\psi}}^T{\mathbfit{x}}=\psi_ix^i=\psi_1x^1+\psi_2x^2+\ldots +\psi_nx^n,\quad i=1,2,\ldots,n;\]</span> <span class="math display">\[{\mathbfit{\psi}}={\mathbfit{\psi}}(t)=\left({\small
  \begin{array}{c}
    \psi_1,\\ \psi_2,\\ \vdots\\ \psi_n
  \end{array}}
\right),\qquad{\mathbfit{x}}={\mathbfit{x}}(t)=\left({\small
  \begin{array}{c}
    x_1,\\ x_2,\\ \vdots\\ x_n
  \end{array}}
\right).\qquad\]</span> В этом обозначении <span class="math inline">\(x^1\)</span> – <span class="math inline">\(i\)</span>-я фазовая переменная, <span class="math inline">\({\mathbfit{\psi}}^T{\mathbfit{x}}\)</span> – матричное произведение двух векторов, <span class="math inline">\(\psi_ix^i\)</span> – скалярное произведение двух векторов. Фазовые переменные описывают состояние объекта<a href="#fn27" class="footnoteRef" id="fnref27"><sup>27</sup></a> (рис. [fig:phasecoords]) в пространстве, одна переменная – одна координата, составляющая вектора скорости и т. п. Фазовые переменные <span class="math inline">\(x^i\)</span> – это вещественнозначные функции (<span class="math inline">\(x^i\in\mathbb{R}\)</span>) времени <span class="math inline">\(x^i(t)\)</span>. Верхний индекс в именах переменных и функций используется здесь и далее ввиду того, что производные функций по переменным будут указываться в нижнем индексе. Переменные <span class="math inline">\(\psi_i=\psi_i(t)\)</span> – обобщение импульса, задающее влияние фазовой переменной <span class="math inline">\(x^i(t)\)</span> на управление в определенные моменты времени. Вектор переменных <span class="math inline">\({\mathbfit{x}}={\mathbfit{x}}(t)\)</span> называется <em>фазовым вектором</em> объекта (рис. [fig:phasecoords]), а вектора, аналогичные <span class="math inline">\({\mathbfit{x}}(t)\)</span>, – <em>вектор&quot;=функциями</em>.</p>
<p>В фазовый вектор объекта входят его координаты и вектор скорости, а также другие физические величины, характеризующие состояние этого объекта в заданный момент времени <span class="math inline">\(t\in[t_o,t_1]\)</span>, где <span class="math inline">\(t_0\)</span> – начальный момент времени, а <span class="math inline">\(t_1\)</span> – конечный. На рисунке [fig:phasecoords] изображен самолет и приведен его упрощенный фазовый вектор. Переменные <span class="math inline">\(x^1,x^2,\ldots,x^6\)</span> задают координаты самолета и величины скоростей по осям, <span class="math inline">\(x^7,x^8\)</span> – угол рыскания и скорость его изменения. Далее, аналогично <span class="math inline">\(x^9,x^{10}\)</span> – угол горизонта, <span class="math inline">\(x^{11},x^{12}\)</span> – угол крена, <span class="math inline">\(x^{13}\)</span> – величина подъемной силы. Переменная <span class="math inline">\(x^{14}\)</span> задает величину силы тяжести, <span class="math inline">\(x^{15}\)</span> – величина сил, тормозящих самолет.</p>
<p>(1,0.46817057) (0,0)<span><embed src="Cessna-Plane.pdf" title="fig:" /></span> (0.02010727,0.18364614)<span>(0,0)[lb]</span> (0.35194862,0.34859676)<span>(0,0)[lb]</span> (0.49778434,0.0310192)<span>(0,0)[lb]</span> (0.12112262,0.10192023)<span>(0,0)[lb]</span> (0.14180206,0.43426882)<span>(0,0)[lb]</span> (0.47267358,0.42245199)<span>(0,0)[lb]</span> (0.38144729,0.09601183)<span>(0,0)[lb]</span> (0.01329395,0.18611522)<span>(0,0)[lb]</span> (0.91580501,0.35302806)<span>(0,0)[lb]</span> (0.6706056,0.19350074)<span>(0,0)[lb]</span> (0.79911377,0.13293946)<span>(0,0)[lb]</span> (0.12703102,0.2703102)<span>(0,0)[lb]</span> (0.87365574,0.41654357)<span>(0,0)[lb]</span> (0.90444605,0.27326441)<span>(0,0)[lb]</span></p>
<p>Изменение переменных <span class="math inline">\(\dot{x}^i(t)\)</span> во времени в общем случае задается системой дифференциальных уравнений в частных производных: <span class="math display">\[\label{eq:3}
\dot{x}^i=\frac{dx^i}{dt}=f^i(x^1,x^2,\ldots,x^n)=f^i({\mathbfit{x}});\quad
   \dot{{\mathbfit{x}}}=\frac{d{\mathbfit{x}}}{dt}={\mathbfit{f}}({\mathbfit{x}}),\]</span> где вторая форма записи – векторная, причем для краткости параметр <span class="math inline">\(t\)</span> опущен. Уравнения задают, например, влияние геометрии оперения и силы тяги на вектор скорости самолета, влияние вектора скорости и силы тяжести на координаты в трехмерном пространстве и т. п. Дифференциальные связи второго порядка, например влияние координаты объекта на величину силы тяжести искусственного спутника Земли, также задаются при помощи уравнений ([eq:3]).</p>
<p>Задав <span class="math inline">\({\mathbfit{x}}(t_0)={\mathbfit{x}}_0\)</span> в момент времени <span class="math inline">\(t_0\)</span> и решив уравнение ([eq:3]), можно рассчитать траекторию изменения объекта (перемещение его в пространстве, например), т. е. решить задачу Коши. Теперь обобщим уравнение ([eq:3]), преобразуем его в следующий вид: <span class="math display">\[\label{eq:4}
  \dot{{\mathbfit{x}}}={\mathbfit{f}}({\mathbfit{x}},{\mathbfit{u}}),\]</span> где <span class="math inline">\({\mathbfit{u}}={\mathbfit{u}}(t)\)</span> – <em>управление</em>, которое также зависит от <span class="math inline">\(t\)</span>. Предполагается, что <span class="math inline">\({\mathbfit{f}}\)</span> непрерывна по совокупности всех переменных и имеет непрерывные производные по каждому <span class="math inline">\(x^i\)</span> и <span class="math inline">\(u^i\)</span>.</p>
<p>Как только в параметры <span class="math inline">\({\mathbfit{f}}\)</span> добавили <span class="math inline">\({\mathbfit{u}}\)</span>, решение дифференциального уравнения ([eq:4]) стало опять многозначным, т. е. траектория зависит теперь не только от <span class="math inline">\({\mathbfit{x}}_0\)</span>, но и от того, как объектом управляют <span class="math inline">\({\mathbfit{u}}={\mathbfit{u}}(t)\)</span>. На рисунке [fig:phasecoords] в вектор управления <span class="math inline">\({\mathbfit{u}}\)</span> входят величина силы тяги <span class="math inline">\(u^1\)</span>, а также <span class="math inline">\(u^1,u^2,\ldots,u^5\)</span>, обозначающие величины сил, вызванных соответствующей геометрией крыла и хвостового оперения: закрылков, элеронов, рулей высоты и направления. Геометрия крыла и хвостового оперения изменяется системой управления, например пилотом. Далее будем предполагать, что самолетом управляет техническое устройство, например компьютер с системой датчиков для получения значений элементов фазового ветра, а также выработанный им вектор <span class="math inline">\({\mathbfit{u}}\)</span> каким&quot;=либо образом меняет тягу и геометрию корпуса самолета.</p>
<p>Для того чтобы &lt;&lt;выбрать&gt;&gt; из бесконечного количества возможных решений одно, необходимо из всех возможных траекторий найти в некотором смысле лучшую. Какая траектория лучше, а какая хуже, определяет функция&quot;=критерий, отображающая траектории (или параметры, ее полностью определяющие) на некоторое число из <span class="math inline">\(\mathbb{R}\)</span>. В оптимальном управлении такая функция называется <em>функционалом</em>. <span class="math display">\[\label{eq:5}
  I({\mathbfit{x}},{\mathbfit{u}})=\int\limits_{t_0}^{t_1}f^0({\mathbfit{x}},{\mathbfit{u}})dt \to \min.\]</span></p>
<p>В формуле ([eq:5]) функция <span class="math inline">\(f^0({\mathbfit{x}},{\mathbfit{u}})\)</span> вычисляет (формализует) значение критерия оценки качества траектории тела в момент времени <span class="math inline">\(t\in[t_0,t_1]\)</span>. Предполагается, что функция <span class="math inline">\(f^0\)</span> дифференцируема по переменным из <span class="math inline">\({\mathbfit{x}},{\mathbfit{u}}\)</span> (так же как и <span class="math inline">\({\mathbfit{f}}\)</span>). Значение функции <span class="math inline">\(f^0\)</span> в конечный момент времени <span class="math inline">\(t_1\)</span> не зависит от управления, так как в этот момент управлять<a href="#fn28" class="footnoteRef" id="fnref28"><sup>28</sup></a> объектом уже нет смысла. В связи с этим перепишем функционал следующим образом: <span class="math display">\[\label{eq:6}
  I({\mathbfit{x}},{\mathbfit{u}})=\int\limits_{t_0}^{t_1}f^0({\mathbfit{x}},{\mathbfit{u}})dt+F(t_1,{\mathbfit{x}}(t_1)) \to \min.\]</span></p>
<p>Теперь функция <span class="math inline">\(F(t_1,{\mathbfit{x}}(t_1))\)</span> будет обозначать качество траектории в этот последний момент времени <span class="math inline">\(t_1\)</span>, а интегральное выражение – качество основной части траектории, где объектом еще можно управлять.</p>
<p>Принцип максимума определяется через функцию Гамильтона (гамильтониан), которая имеет следующий вид: <span class="math display">\[\label{eq:7}
  H(t,{\mathbfit{x}},{\mathbfit{\psi}},{\mathbfit{u}})=f^0({\mathbfit{x}},{\mathbfit{u}})+{\mathbfit{\psi}}^T{\mathbfit{f}}({\mathbfit{x}},{\mathbfit{u}}).\]</span></p>
<p>Управление <span class="math inline">\({\mathbfit{u}}\)</span> будет оптимальным <span class="math inline">\({\mathbfit{u}}^*\)</span> с соответствующей оптимальной траекторией <span class="math inline">\({\mathbfit{x}}^*\)</span>, если выполняется условие <span class="math display">\[\label{eq:777}
  H(t,{\mathbfit{x}}^*,{\mathbfit{\psi}},{\mathbfit{u}}^*)\geqslant H(t,{\mathbfit{x}}^*,{\mathbfit{\psi}},{\mathbfit{u}})\]</span> для любого допустимого <span class="math inline">\({\mathbfit{u}}\)</span>. Если привести ([eq:4])–([eq:777]) в одну систему и переписать все уравнения через <span class="math inline">\(H\)</span>, то получим следующую задачу оптимального управления <span class="citation" data-cites="sethi"></span>: <span class="math display">\[\label{eq:8}
  \left\{
    \begin{array}{ll}
      \dot{{\mathbfit{x}}}={\mathbfit{H}}_{{\mathbfit{\psi}}}, &amp; {\mathbfit{x}}(t_0)={\mathbfit{x}}_0,\\
      \dot{{\mathbfit{\psi}}}=-{\mathbfit{H}}_{{\mathbfit{x}}}, &amp; {\mathbfit{\psi}}(t_1)=F(t_1,{\mathbfit{x}}(t_1)).
    \end{array}
  \right.\]</span> То есть <span class="math inline">\({\mathbfit{x}}\)</span> определяется своим левым <span class="math inline">\({\mathbfit{x}}(t_0)\)</span> концом, а <span class="math inline">\({\mathbfit{\psi}}\)</span> – правым <span class="math inline">\({\mathbfit{\psi}}(t_1)\)</span>. Иногда <span class="math inline">\({\mathbfit{\psi}}\)</span> называют также функцией, сопряженной <span class="math inline">\({\mathbfit{x}}\)</span>.</p>
<section id="sec:discrete" class="level3">
<h3><span class="header-section-number">5.2.1</span> Дискретный вариант задачи улучшения управления</h3>
<p>Использование численных расчетов предполагает постановку задачи в дискретном времени. Для этого разобьем интервал <span class="math inline">\([t_0,t_1]\)</span> на <span class="math inline">\(N\)</span> равных частей с шагом <span class="math inline">\(h=(t_1-t_0)/N\)</span>, <span class="math inline">\(N\in\mathbb{N}\)</span>. Дискретные моменты времени можно обозначать <span class="math inline">\(t_0,\)</span> <span class="math inline">\(t_0+h\)</span>, <span class="math inline">\(t_0+2h,\)</span>…, <span class="math inline">\(t_1-h,\)</span> <span class="math inline">\(t_1\)</span> или, как будет далее использовано в пособии, <span class="math inline">\(t_0\)</span> <span class="math inline">\(t_1,\)</span> <span class="math inline">\(t_2,\)</span>…<span class="math inline">\(t_j,\)</span>…<span class="math inline">\(t_N\)</span>. Функцию <span class="math inline">\(\dot{{\mathbfit{x}}}(t)\)</span> в левой части ([eq:4]) заменим на <span class="math inline">\({\mathbfit{x}}(t_{j+1})\)</span> или еще короче <span class="math inline">\({\mathbfit{x}}_{j+1}\)</span> (так же как и остальные переменные) и получим дискретный вариант уравнения движения следующего вида: <span class="math display">\[\begin{aligned}
 \label{eq:4d}
 &amp;{\mathbfit{x}}_{j+1}={\mathbfit{g}}_j={\mathbfit{g}}(t_j,{\mathbfit{x}}_j,{\mathbfit{u}}_j),\quad j\in\{0,1,\ldots,N\};\\
  \label{eq:4dcond}
  &amp;{\mathbfit{x}}(t_0)={\mathbfit{x}}_0, \quad {\mathbfit{x}}_j\in\mathbb{R}^n,  \quad {\mathbfit{u}}_j\in\mathbb{R}^m.\end{aligned}\]</span> Формула ([eq:4d]) уже не является дифференциальным уравнением, и преобразование из ([eq:4]) в ([eq:4d]) – теперь задача пользователя программы, которую мы разработаем далее. Самый простой способ – применить простую схему интегрирования Эйлера: <span class="math display">\[\label{eq:4d1} \nonumber
  {\mathbfit{x}}_{j+1}={\mathbfit{x}}_j+h{\mathbfit{f}}(t_j,{\mathbfit{x}}_j,{\mathbfit{u}}_j).\]</span> Далее будем предполагать, что пользователь сам задает ([eq:4d]). Качество траекторий оценим следующим функционалом: <span class="math display">\[I({\mathbfit{x}},{\mathbfit{u}})=\sum_{j=0}^{N-1}f^0(t_j,{\mathbfit{x}}_J,{\mathbfit{u}}_j)+F(t_N,{\mathbfit{x}}_N) \to \min.
    \label{eq103}\]</span></p>
<p>Принцип максимума в данном случае определяется при помощи дискретного варианта функции Гамильтона <span class="math display">\[H_j=H(t_j,{\mathbfit{x}}_j,{\mathbfit{u}}_j)=f^0(t_j,{\mathbfit{x}}_j,{\mathbfit{u}}_j)+
   {\mathbfit{\psi}}^T(t_{j+1}){\mathbfit{g}}(t_j,{\mathbfit{x}}_j,{\mathbfit{u}}_j).   \label{eq:descH}\]</span></p>
<p>Выпишем теперь принцип максимума <span class="math display">\[\begin{aligned}
  H(t_j,{\mathbfit{x}}^*_j,{\mathbfit{\psi}}_{j+1},{\mathbfit{u}}^*_j)\geqslant H(t_j,{\mathbfit{x}}^*_j,{\mathbfit{\psi}}_{j+1},{\mathbfit{u}}_j) \label{eq:descMax}\end{aligned}\]</span> для всех допустимых <span class="math inline">\({\mathbfit{u}}_j\)</span>. Сопряженная вектор&quot;=функция <span class="math inline">\({\mathbfit{\psi}}_j\)</span> вычисляется по схеме <span class="math display">\[\begin{aligned}
  \label{eq:startPsi}
  {\mathbfit{\psi}}^T_N&amp;=F_{\mathbfit{x}}(t_N,{\mathbfit{x}}_N), \nonumber\\ {\mathbfit{\psi}}^T_j&amp;={\mathbfit{\psi}}^T_{j+1}+{\mathbfit{H}}_{\mathbfit{x}}(t_j,{\mathbfit{x}}^*_j,{\mathbfit{\psi}}^T_{j+1},{\mathbfit{u}}^*_j).\end{aligned}\]</span></p>
<p>Условиям ([eq:7]) и ([eq:descMax]) соответствует минимум <span class="math inline">\(I({\mathbfit{x}},{\mathbfit{u}}).\)</span> Поиск этого минимума с использованием численного метода основывается на вычислении градиента <span class="math inline">\(I\prime({\mathbfit{u}})\)</span> (по переменным <span class="math inline">\({\mathbfit{u}}\)</span>): <span class="math display">\[\begin{aligned}
  I\prime({\mathbfit{u}})&amp;={\mathbfit{H}}_{\mathbfit{u}}(t,{\mathbfit{x}},{\mathbfit{\psi}},{\mathbfit{u}}).\end{aligned}\]</span></p>
</section>
<section id="sec:improvealg" class="level3">
<h3><span class="header-section-number">5.2.2</span> Схема алгоритма улучшения первого порядка</h3>
<p>u</p>
<p>Теперь мы знаем, как вычислять градиент. Используя эти знания, построим алгоритм улучшения <span class="math inline">\(I({\mathbfit{x}},{\mathbfit{u}})\)</span>. Обозначим через <span class="math inline">\(\langle\x^I(i),\u^I(i)\rangle\)</span> некоторую допустимую траекторию и управление на всем отрезке времени <span class="math inline">\([t_0,t_1]\)</span>. Цель шага улучшения – найти такую траекторию <span class="math inline">\(\langle\x^{I\!I}(i),\u^{I\!I}(i)\rangle\)</span>, чтобы <span class="math inline">\(I(\x^{I\!I},\u^{I\!I}) &lt; I(\x^I,\u^I).\)</span> Общая схема улучшения выглядит следующим образом:</p>
<ol>
<li><p>Задается начальное управление <span class="math inline">\({\mathbfit{u}}^I(t)\)</span>. Из уравнения и условий определяется <span class="math inline">\({\mathbfit{x}}^I(t)\)</span>. Вычисляется <span class="math inline">\(I({\mathbfit{x}}^I,{\mathbfit{u}}^I).\)</span></p></li>
<li><p>Из системы <span class="math inline">\(\mathbf{\psi}={\mathbfit{H}}_{\mathbfit{x}},\;\bpsi_N=-\F_\x(t_N,\x_N)\)</span> находим <span class="math inline">\(\bpsi,\)</span><br />
где <span class="math inline">\(\H(t_j,\x_j,\bpsi_{j+1},\u_j)=\bpsi^{T}_{j+1}{\mathbfit{g}}(t_j,\x_j,\u_j)-f^{0}(t_j,\x_j,\u_j),\)</span> производная <span class="math inline">\({\mathbfit{H}}_\u\)</span> находится в точке <span class="math inline">\(\left(t,\x^{I}_j,\bpsi_{j+1},\u^{I}_j\right)\)</span>. <span class="math display">\[{\mathbfit{H}}_{{\mathbfit{u}}}(t_j,\x_j,\bpsi_{j+1},\u_j)={\mathbfit{g}}_{{\mathbfit{u}}}(t_j,\x_j,\u_j)\bpsi_{j+1}-f^{0}_{\mathbfit{u}}(t_j,\x_j,\u_j)\]</span> из ([eq:4dcond]). Задается параметр <span class="math inline">\(\alpha\)</span>.</p></li>
<li><p>Из системы <span class="math inline">\(\x_{j+1}={\mathbfit{g}}(t_j,\x_j,\u^{I\!I}_j),\)</span> <span class="math inline">\(\x(t_0)=\x_0,\)</span> где<span class="math inline">\(\u^{I\!I}=\u^{I}+\alpha \H_\u,\)</span> вычисляется <span class="math inline">\(\x^{I\!I}.\)</span></p></li>
<li><p>Новое управление и значение параметра <span class="math inline">\(\alpha\)</span> подсчитываются из решения задачи одномерной минимизации для функционала <span class="math inline">\(I(\x^{I\!I},\u^{I\!I})\to \min\limits_{\alpha}.\)</span></p></li>
<li><p>Если <span class="math inline">\(I\left(\x^{I\!I},\u^{I\!I}\right)\geqslant I\left(\x^{I},\u^{I}\right)\)</span> (улучшение не произошло), то уменьшаем <span class="math inline">\(\alpha\)</span> и переходим к следующей итерации, начиная с пункта 3.</p></li>
<li><p>Иначе, если <span class="math inline">\(I\left(\x^{I},\u^{I}\right)-I\left(\x^{I\!I},\u^{I\!I}\right)&gt;\varepsilon\)</span>, то переходим к следующей итерации, начиная с пункта 2. Значение <span class="math inline">\(\varepsilon\)</span> – параметр точности.</p></li>
</ol>
<p>Шестой шаг алгоритма не относится непосредственно к схеме улучшения, но он логичен, так как создает итеративный процесс поиска минимума <span class="math inline">\(I(\x,\u),\)</span> т. е. функции <span class="math inline">\({\mathbfit{u}}\)</span> оптимального управления объектом.</p>
</section>
<section id="sec:improprog" class="level3">
<h3><span class="header-section-number">5.2.3</span> Реализация программы</h3>
<p>Алгоритм реализуем на простом и компактном языке программирования Python <span class="citation" data-cites="pythondoc pythondl pythonbook"></span>. Язык является объектноориентированным, его дистрибутив содержит огромное количество библиотек. Кроме того, в Интернете находится еще множество других библиотек и приложений, в том числе библиотеки <code>numpy</code> и <code>sympy</code>. Библиотека <code>numpy</code> включает в себя операции с векторами данных и матрицами. При их помощи будем задавать фазовый вектор <span class="math inline">\({\mathbfit{x}}\)</span> в виде переменной“=массива <code>X</code> (<code>X[j]={\mathbfit{x}}_j</code>), траектории, моменты времени, функцию управления и т. п. В библиотеке <code>sympy</code> содержатся операции вычисления производных из выражений, функции преобразования и сокращения выражений, а также процедуры преобразования выражений в байт”=код виртуальной машины Python (компиляции выражений в программный код).</p>
<p>Программу начнем реализовывать с импорта <code>numpy</code> и <code>sympy</code>, библиотеки специальных структур&quot;=итераторов <code>itertools</code>, системной библиотеки <code>os</code>.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> math
<span class="im">import</span> numpy, sympy
<span class="im">import</span> itertools
<span class="im">from</span> sympy <span class="im">import</span> symbols, diff, Symbol
<span class="im">import</span> numpy.linalg
<span class="im">from</span> sympy.utilities.lambdify <span class="im">import</span> lambdify
<span class="im">import</span> os

TupleType<span class="op">=</span><span class="bu">type</span>((<span class="dv">1</span>,))
ListType<span class="op">=</span><span class="bu">type</span>([])</code></pre></div>
<p>Сначала запрограммируем абстрактный класс, представляющий модель управляемого объекта. В классе необходимо представить <span class="math inline">\(\x_0\)</span>, определить размерности <span class="math inline">\(n\)</span> и <span class="math inline">\(m\)</span> вектор&quot;=функций <span class="math inline">\(\x\)</span> и <span class="math inline">\(\u\)</span>. Вектор <code>U0</code> (<span class="math inline">\(\u^{I}\)</span>) необходимо задать как начальное приближение синтезируемого управления:</p>
<div class="sourceCode" texcomments=""><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> Model(<span class="bu">object</span>):

    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, X0, U0):
        <span class="va">self</span>.X0<span class="op">=</span>atleast_1d(X0)  <span class="co"># $\x_0$ должен быть вектором</span>
        <span class="va">self</span>.U0<span class="op">=</span>U0
        <span class="va">self</span>.N<span class="op">=</span><span class="va">self</span>.X0.shape[<span class="dv">0</span>] <span class="co"># Размерность $\vecx$</span>
        <span class="va">self</span>.M<span class="op">=</span>U0.shape[<span class="dv">1</span>]      <span class="co"># Размерность $\vecu$</span>

    <span class="kw">def</span> F(<span class="va">self</span>, x):
        <span class="cf">return</span> <span class="fl">0.0</span>              <span class="co"># Заглушка по умолчанию</span>

    <span class="kw">def</span> g(<span class="va">self</span>, t, x, u):
        <span class="cf">raise</span> <span class="pp">RuntimeError</span>(<span class="st">&quot;метод реализуется в подклассе&quot;</span>)

    <span class="kw">def</span> f0(<span class="va">self</span>, t, x, u):
        <span class="cf">return</span> <span class="fl">0.0</span>              <span class="co"># Заглушка по умолчанию</span></code></pre></div>
<p>Реализация схемы улучшения – это класс <code>Process</code>, наследующий все свойства класса <code>VFCalc</code>, реализующего компьютерную алгебру над вектор&quot;=функциями. Реализацию <code>VFCalc</code> рассмотрим далее, а пока сосредоточимся на схеме улучшения.</p>
<p>Схема улучшения получает в качестве входных данных в конструктор <code>__init__</code> два параметра: <code>model</code> – класс“=потомок класса <code>Model</code> и <code>alpha</code> – параметр <span class="math inline">\(\alpha\)</span>. Для вычисления производных <code>VFCalc</code> необходимо знать размерности <span class="math inline">\({\mathbfit{x}}\)</span> и <span class="math inline">\({\mathbfit{u}}\)</span>. Конструктор также сохраняет функции <span class="math inline">\({\mathbfit{f}},\)</span> <span class="math inline">\(f\)</span> и <span class="math inline">\(F\)</span> в виде специальных структур”=выражений <code>sympy</code>, над которыми можно производить операции символьного дифференцирования:</p>
<div class="sourceCode" texcomments=""><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> Process(VFCalc):
    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, model, alpha<span class="op">=</span><span class="fl">1.0</span>):
        VFCalc.<span class="fu">__init__</span>(<span class="va">self</span>, model.N, model.M)
        t,x,u<span class="op">=</span><span class="va">self</span>.v.t,<span class="va">self</span>.v.x,<span class="va">self</span>.v.u
        <span class="va">self</span>.model<span class="op">=</span>model<span class="op">;</span> <span class="va">self</span>.alpha<span class="op">=</span>alpha
        <span class="va">self</span>.v.g<span class="op">=</span>model.g(t, x, u)    <span class="co"># Получить выражение $\vecg$</span>
        <span class="va">self</span>.v.f0<span class="op">=</span>model.f0(t, x, u)  <span class="co"># Получить выражение $f^0$</span>
        <span class="va">self</span>.v.F<span class="op">=</span>model.F(x)          <span class="co"># Получить выражение $F$</span>

    <span class="kw">def</span> trajectory(<span class="va">self</span>, U):         <span class="co"># Расчет траектории $\vecx(t)$</span>
        x0<span class="op">=</span><span class="va">self</span>.model.X0<span class="op">;</span> X <span class="op">=</span> [x0]   <span class="co"># по известному $\vecu$</span>
        <span class="cf">for</span> t, u <span class="kw">in</span> <span class="bu">enumerate</span>(U):    <span class="co"># (0, u0), (1, u1)</span>
            xn<span class="op">=</span><span class="va">self</span>.model.g(t, X[t], u)<span class="op">;</span> X.append(xn)
        <span class="cf">return</span> array(X)

    <span class="kw">def</span> I(<span class="va">self</span>, X, U):               <span class="co"># Вычисление $I(\vecx,\vecu)$</span>
        <span class="kw">def</span> _a(acc, t):
            <span class="cf">return</span> acc <span class="op">+</span> <span class="va">self</span>.model.f0(t, X[t], U[t])
        <span class="cf">return</span> <span class="bu">reduce</span>(_a, <span class="bu">range</span>(<span class="bu">len</span>(X)<span class="op">-</span><span class="dv">1</span>), <span class="va">self</span>.model.F(X[<span class="op">-</span><span class="dv">1</span>]))

    <span class="kw">def</span> optimize(<span class="va">self</span>, t, eps<span class="op">=</span><span class="fl">0.001</span>, iters<span class="op">=</span><span class="dv">1000</span>): <span class="co"># Схема</span>
        Up<span class="op">=</span><span class="va">self</span>.model.U0             <span class="co"># $(\x^{I},\u^{I})$</span>
        Xp<span class="op">=</span><span class="va">self</span>.trajectory(Up)
        Ip<span class="op">=</span><span class="va">self</span>.I(Xp,Up)<span class="op">;</span> it <span class="op">=</span> <span class="dv">1</span>     <span class="co"># $I(\x^{I},\u^{I})$</span>
        <span class="cf">while</span> <span class="va">True</span>:
            alpha <span class="op">=</span> <span class="va">self</span>.alpha
            Psi<span class="op">=</span><span class="va">self</span>.Psi(t, Xp, Up)  <span class="co"># $\vecpsi(t)$</span>
            _H_u<span class="op">=</span><span class="va">self</span>.H((<span class="va">self</span>.v.u,), t[:<span class="op">-</span><span class="dv">1</span>], Xp[:<span class="op">-</span><span class="dv">1</span>], Up, Psi)
            <span class="cf">while</span> <span class="va">True</span>:
                _dU<span class="op">=</span>_H_u<span class="op">*</span>alpha       <span class="co"># $\vecH_\u\alpha$</span>
                Un <span class="op">=</span> Up <span class="op">+</span> _dU
                Xn <span class="op">=</span> <span class="va">self</span>.trajectory(Un) <span class="co"># $(\x^{I\!I},\u^{I\!I})$</span>
                In <span class="op">=</span> <span class="va">self</span>.I(Xn, Un)  <span class="co"># $I(\x^{I\!I},\u^{I\!I})$</span>
                dI <span class="op">=</span> Ip<span class="op">-</span>In
                <span class="cf">if</span> <span class="bu">abs</span>(dI)<span class="op">&lt;</span>eps:      <span class="co"># Решение найдено</span>
                    <span class="cf">return</span> In, Xn, Un, it, <span class="st">&quot;opt&quot;</span>
                <span class="cf">if</span> iters<span class="op">&lt;=</span><span class="dv">0</span>:         <span class="co"># Решение не найдено</span>
                    <span class="cf">return</span> In, Xn, Un, it, <span class="st">&quot;nonoptimal&quot;</span>
                iters<span class="op">-=</span><span class="dv">1</span><span class="op">;</span> it<span class="op">+=</span><span class="dv">1</span>
                <span class="cf">if</span> In<span class="op">&gt;=</span>Ip:
                    alpha<span class="op">/=</span><span class="dv">2</span>         <span class="co"># Новый параметр</span>
                    <span class="cf">continue</span>         <span class="co"># шага улучшения</span>
                <span class="cf">else</span>:
                    Xp, Up, Ip <span class="op">=</span> Xn, Un, In
                    <span class="cf">break</span></code></pre></div>
<p>В предыдущем отрезке программного кода переменные <code>X</code>, <code>U</code> и их аналоги – это массивы значений <span class="math inline">\({\mathbfit{x}}(t)\)</span> и <span class="math inline">\({\mathbfit{u}}(t)\)</span> для каждого момента времени <span class="math inline">\(t\)</span> на интервале <span class="math inline">\([t_0,t_1]\)</span>.</p>
<p>Вычисления <span class="math inline">\({\mathbfit{\psi}}\)</span> и нужной производной <span class="math inline">\({\mathbfit{H}}\)</span> реализуются при помощи специальных методов класса <code>Process</code>, которые описаны далее. Операция <code>dot(A,B)</code> выполняет матричное умножение аргументов. Если в качестве параметра этой операции передать два вектора&quot;=строки, то второй вектор будет автоматически транспонирован в столбец. Эта особенность реализации в библиотеке <code>numpy</code> позволяет тривиальные матричные умножения векторов делать без дополнительной явной операции транспонирования. В результате операции <code>X[:-1]</code> возвращается последний &lt;&lt;<code>-1</code>&gt;&gt; элемент <code>X</code>, т. е. <span class="math inline">\(\x(t_1)\)</span>:</p>
<div class="sourceCode" texcomments=""><pre class="sourceCode python"><code class="sourceCode python">    <span class="kw">def</span> Psi(<span class="va">self</span>, t, X, U):
        v<span class="op">=</span><span class="va">self</span>.v
        psie <span class="op">=</span> <span class="op">-</span><span class="va">self</span>.fun(v.F,(v.x,), t[<span class="op">-</span><span class="dv">1</span>], X[<span class="op">-</span><span class="dv">1</span>], U[<span class="op">-</span><span class="dv">1</span>])
        psi<span class="op">=</span>[psie]<span class="op">;</span> X<span class="op">=</span>X[:<span class="op">-</span><span class="dv">1</span>]<span class="op">;</span> t<span class="op">=</span>t[:<span class="op">-</span><span class="dv">1</span>]
        _f0_x<span class="op">=</span><span class="va">self</span>.fun(v.f0, (v.x,), t, X, U) <span class="co"># $f^0_\x$</span>
        _g_x <span class="op">=</span><span class="va">self</span>.fun(v.g, (v.x,), t, X, U)  <span class="co"># $\vecg_{\!\x}$</span>
        j<span class="op">=</span><span class="bu">len</span>(t)<span class="op">-</span><span class="dv">1</span><span class="op">;</span> p<span class="op">=</span>psie   <span class="co"># Начать с конца интервала</span>
        <span class="cf">while</span> j<span class="op">&gt;=</span><span class="dv">1</span>:
            i<span class="op">=</span>t[j]<span class="op">;</span> pp<span class="op">=</span>p
            pn <span class="op">=</span> dot(pp, _g_x[i]) <span class="op">-</span> _f0_x[i]
            psi.append(pn)<span class="op">;</span> p<span class="op">=</span>pn<span class="op">;</span> j<span class="op">-=</span><span class="dv">1</span>
        psi<span class="op">=</span>array(psi)
        <span class="cf">return</span> psi[::<span class="op">-</span><span class="dv">1</span>]     <span class="co"># Переставить в обратном порядке</span>

    <span class="kw">def</span> H(<span class="va">self</span>, <span class="bu">vars</span>, T, X, U, Psi):
        g<span class="op">=</span><span class="va">self</span>.fun(<span class="va">self</span>.v.g, <span class="bu">vars</span>, T, X, U)
        f0<span class="op">=-</span><span class="va">self</span>.fun(<span class="va">self</span>.v.f0, <span class="bu">vars</span>, T, X, U)
        H <span class="op">=</span> alpha <span class="op">*</span> f0
        <span class="cf">for</span> psi,_H,_g,i <span class="kw">in</span> <span class="bu">zip</span>(Psi, H, g, <span class="bu">range</span>(<span class="bu">len</span>(H))):
            _H <span class="op">+=</span> dot(psi,_g)<span class="op">;</span> H[i]<span class="op">=</span>_H
        <span class="cf">return</span> H</code></pre></div>
<p>В приведенном отрезке кода в <code>H</code> передается список векторов переменных, по которым вычисляются производные <span class="math inline">\({\mathbfit{H}}\)</span>, значения <span class="math inline">\({\mathbfit{x}}\)</span> и <span class="math inline">\({\mathbfit{u}}\)</span> на всем интервале времени, а также сам интервал времени и параметр <span class="math inline">\(\alpha\)</span>.</p>
<p>Функции <span class="math inline">\({\mathbfit{g}},\)</span> <span class="math inline">\(f^0\)</span> и <span class="math inline">\(F\)</span>, задаваемые пользователем нашей библиотеки решения задач оптимального управления, в программе могут получить значения как в определенный момент времени (например, <code>X[:-1]</code>), так и на всем интервале (<code>X</code>). Кроме того, формулы производных от <span class="math inline">\(g^i\)</span> могут &lt;&lt;вырождаться&gt;&gt; в константы, т. е. <code>g</code> может выдать не вектор значений, когда это надо, а просто одно числовое значение. Для того чтобы меньше зависеть от этих случаев, необходимо реализовать специальную функцию, которая возвращала бы адекватный по типу результат типу переданных ей параметров. А вот внутри функции должно вычисляться значение нужной нам производной нужной нам функции. Такой функцией в <code>Process</code> является метод <code>fun</code>.</p>
<div class="sourceCode" texcomments=""><pre class="sourceCode python"><code class="sourceCode python">    <span class="kw">def</span> fun(<span class="va">self</span>, f, <span class="bu">vars</span>, T, X, U):
        code,df<span class="op">=</span><span class="va">self</span>.code(f, <span class="op">*</span><span class="bu">vars</span>) <span class="co"># Найти производную</span>
                                    <span class="co"># и скомпилировать ее.</span>
        X<span class="op">=</span>numpy.atleast_1d(X)       <span class="co"># Входной параметры X и U</span>
        U<span class="op">=</span>numpy.atleast_1d(U)       <span class="co"># должны быть векторами.</span>
        <span class="cf">if</span> X.ndim<span class="op">&gt;</span><span class="dv">1</span>:
            Xs<span class="op">=</span>[X[:,i:i<span class="op">+</span><span class="dv">1</span>] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(X.shape[<span class="dv">1</span>])]
            Us<span class="op">=</span>[U[:,i:i<span class="op">+</span><span class="dv">1</span>] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(U.shape[<span class="dv">1</span>])]
            args<span class="op">=</span>(T,)<span class="op">+</span><span class="bu">tuple</span>(Xs<span class="op">+</span>Us)
        <span class="cf">else</span>:
            args<span class="op">=</span>(T,)<span class="op">+</span><span class="bu">tuple</span>(X)<span class="op">+</span><span class="bu">tuple</span>(U)
        rc<span class="op">=</span>code(<span class="op">*</span>args)  <span class="co"># Вычислить функцию (производную)</span>
        rct<span class="op">=</span><span class="bu">type</span>(rc)
        rc<span class="op">=</span>numpy.atleast_1d(rc)
        <span class="cf">if</span> <span class="bu">type</span>(T)<span class="op">==</span>numpy.ndarray:
            <span class="cf">try</span>: <span class="co"># Попробовать транспонировать список</span>
                <span class="cf">if</span> rct <span class="kw">in</span> [TupleType,ListType]:
                    rc<span class="op">=</span>rc.reshape(rc.shape[:<span class="op">-</span><span class="dv">1</span>])
                    rc<span class="op">=</span>rc.T
                    <span class="cf">return</span> rc
            <span class="cf">except</span> <span class="pp">ValueError</span>: <span class="cf">pass</span> <span class="co"># ... не получилось</span>
            <span class="cf">if</span> T.shape[<span class="dv">0</span>]<span class="op">!=</span>rc.shape[<span class="dv">0</span>]: <span class="co"># Константа $\to$ вектор</span>
                nrc<span class="op">=</span>numpy.zeros((<span class="bu">len</span>(T),)<span class="op">+</span>rc.shape,dtype<span class="op">=</span><span class="bu">float</span>)
                nrc[:]<span class="op">=</span>rc<span class="op">;</span> rc<span class="op">=</span>nrc
        <span class="cf">return</span> rc</code></pre></div>
</section>
<section id="sec:VFdiff" class="level3">
<h3><span class="header-section-number">5.2.4</span> Дифференцирование вектор&quot;=функций</h3>
<p>Теперь рассмотрим подсистему вычисления производных вектор&quot;=функций. Для этого разработаем специальный класс, экземпляры которого настроены на поддержку нашей программы, реализующей схему улучшения.</p>
<p>Экземпляры прежде всего должны знать, какого размера <code>N</code> фазовый вектор <span class="math inline">\({\mathbfit{x}}\)</span> и вектор управления <span class="math inline">\({\mathbfit{u}}\)</span> (<code>M</code>). Эти параметры передаются в конструктор класса <code>VFCalc</code> при создании экземпляра. Далее порождается ряд символов, специальных структур библиотеки <code>sympy</code>, обозначающих идентификаторы в выражениях. При помощи этих символов записываются функции, из которых будут вычисляться производные.</p>
<p>Класс <code>VFCalc</code>, кроме сервиса вычисления производных, предоставляет возможности компиляции полученных выражений в байт&quot;=код виртуальной машины среды исполнения <code>Python</code>. Так как класс <code>VFCalc</code> является базовым для класса <code>Process</code>, то его определение в тексте программы должно быть помещено перед определением <code>Process</code>.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> Helper():
    <span class="cf">pass</span>

<span class="kw">class</span> VFCalc(<span class="bu">object</span>):
    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, N,M):
        <span class="va">self</span>.N<span class="op">=</span>N<span class="op">;</span> <span class="va">self</span>.M<span class="op">=</span>M<span class="op">;</span> <span class="va">self</span>.v<span class="op">=</span>Helper()
        <span class="va">self</span>.v.x<span class="op">=</span>[Symbol(<span class="st">&#39;x&#39;</span><span class="op">+</span><span class="bu">str</span>(i<span class="op">+</span><span class="dv">1</span>)) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="va">self</span>.N)]
        <span class="va">self</span>.v.u<span class="op">=</span>[Symbol(<span class="st">&#39;u&#39;</span><span class="op">+</span><span class="bu">str</span>(i<span class="op">+</span><span class="dv">1</span>)) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="va">self</span>.M)]
        <span class="va">self</span>.v.t<span class="op">=</span>Symbol(<span class="st">&#39;t&#39;</span>)  <span class="co"># Переменные для представления</span>
                              <span class="co">#    выражений</span>
    <span class="kw">def</span> diff1(<span class="va">self</span>, f, var):  <span class="co"># Шаг вычисления производной</span>
        <span class="cf">if</span> <span class="bu">type</span>(f) <span class="kw">in</span> [TupleType,ListType]:
            df<span class="op">=</span><span class="bu">tuple</span>([<span class="va">self</span>.diff1(fi, var) <span class="cf">for</span> fi <span class="kw">in</span> f])
        <span class="cf">else</span>:
            df<span class="op">=</span><span class="bu">tuple</span>([diff(f, vi) <span class="cf">for</span> vi <span class="kw">in</span> var])
        <span class="cf">if</span> <span class="bu">len</span>(df)<span class="op">==</span><span class="dv">1</span>: df<span class="op">=</span>df[<span class="dv">0</span>] <span class="co"># Лишние скобки</span>
        <span class="cf">return</span> df

    <span class="kw">def</span> diff(<span class="va">self</span>, f, <span class="op">*</span><span class="bu">vars</span>): <span class="co"># Производная вектор-функции</span>
        cf<span class="op">=</span>f
        <span class="cf">for</span> v <span class="kw">in</span> <span class="bu">vars</span>:        <span class="co"># Выполнить пошагово</span>
            cf<span class="op">=</span><span class="va">self</span>.diff1(cf, v)
        <span class="cf">return</span> cf

    <span class="kw">def</span> subs(<span class="va">self</span>, f, s):     <span class="co"># Подстановка в вектор-функцию</span>
        <span class="cf">if</span> <span class="bu">type</span>(f) <span class="kw">not</span> <span class="kw">in</span> [TupleType,ListType]:
            <span class="cf">return</span> f.subs(s)
        <span class="cf">return</span> <span class="bu">tuple</span>([<span class="va">self</span>.subs(fi,s) <span class="cf">for</span> fi <span class="kw">in</span> f])

    <span class="kw">def</span> lambdify(<span class="va">self</span>, f):    <span class="co"># Компилирование вектор-функции</span>
        l<span class="op">=</span>[<span class="va">self</span>.v.t]          <span class="co"># Формирование списка</span>
        l.extend(<span class="va">self</span>.v.x)    <span class="co">#   параметров</span>
        l.extend(<span class="va">self</span>.v.u)
        fl<span class="op">=</span>lambdify(l, f, <span class="st">&quot;numpy&quot;</span>) <span class="co"># Использовать арифметику</span>
        <span class="cf">return</span> fl             <span class="co">#  из пакета numpy</span>

    <span class="kw">def</span> code(<span class="va">self</span>, f, <span class="op">*</span><span class="bu">vars</span>): <span class="co"># Вычислить производную</span>
        df<span class="op">=</span><span class="va">self</span>.diff(f, <span class="op">*</span><span class="bu">vars</span>)
        c<span class="op">=</span><span class="va">self</span>.lambdify(df)   <span class="co"># и скомпилировать ее.</span>
        <span class="cf">return</span> c,df           <span class="co"># Возвратить оба результата</span></code></pre></div>
<p>Тестирование класса произведем при помощи следующего программного кода:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">d<span class="op">=</span>VFCalc(<span class="dv">2</span>,<span class="dv">2</span>)
x1,x2<span class="op">=</span>Symbol(<span class="st">&#39;x1&#39;</span>),Symbol(<span class="st">&#39;x2&#39;</span>)
u1,u2<span class="op">=</span>Symbol(<span class="st">&#39;u1&#39;</span>),Symbol(<span class="st">&#39;u2&#39;</span>)
y1<span class="op">=</span>x1<span class="op">**</span><span class="dv">2</span><span class="op">*</span>u1<span class="op">+</span>x2<span class="op">*</span>u2<span class="op">**</span><span class="dv">2</span>
y2<span class="op">=</span>x1<span class="op">**</span><span class="dv">2</span><span class="op">*</span>x2<span class="op">**</span><span class="dv">2</span><span class="op">*</span>u1<span class="op">**</span><span class="dv">2</span><span class="op">*</span>u2<span class="op">**</span><span class="dv">2</span>
res<span class="op">=</span>(d.diff([y1,y2],
    [x1,x2], [u1,u2]))
pprint (res)
<span class="cf">return</span></code></pre></div>
<p>В приведенном коде <code>x1</code> и <code>x2</code> – переменные, формирующие вектор переменных <span class="math inline">\({\mathbfit{x}}\)</span>, <code>u1</code> и <code>u2</code> – переменные, формирующие вектор переменных <span class="math inline">\({\mathbfit{u}}\)</span>, функции <code>y1</code> и <code>y2</code> формируют вектор&quot;=функцию <span class="math inline">\({\mathbfit{f}}\)</span>, из которой берется производная <span class="math inline">\({\mathbfit{f}}_{{\mathbfit{x}}{\mathbfit{u}}}\)</span>. В результате получаем следующую матрицу функций:</p>
<div class="sourceCode" style="bw"><pre class="sourceCode python"><code class="sourceCode python">(((<span class="dv">2</span><span class="op">*</span>x1, <span class="dv">0</span>), (<span class="dv">0</span>, <span class="dv">2</span><span class="op">*</span>u2)),
 ((<span class="dv">4</span><span class="op">*</span>u1<span class="op">*</span>u2<span class="op">**</span><span class="dv">2</span><span class="op">*</span>x1<span class="op">*</span>x2<span class="op">**</span><span class="dv">2</span>,
   <span class="dv">4</span><span class="op">*</span>u1<span class="op">**</span><span class="dv">2</span><span class="op">*</span>u2<span class="op">*</span>x1<span class="op">*</span>x2<span class="op">**</span><span class="dv">2</span>),
  (<span class="dv">4</span><span class="op">*</span>u1<span class="op">*</span>u2<span class="op">**</span><span class="dv">2</span><span class="op">*</span>x1<span class="op">**</span><span class="dv">2</span><span class="op">*</span>x2,
   <span class="dv">4</span><span class="op">*</span>u1<span class="op">**</span><span class="dv">2</span><span class="op">*</span>u2<span class="op">*</span>x1<span class="op">**</span><span class="dv">2</span><span class="op">*</span>x2)))</code></pre></div>
</section>
<section id="sec:testing" class="level3">
<h3><span class="header-section-number">5.2.5</span> Тестирование программы</h3>
<p>Тестирование программы проведем на простой модели: <span class="math display">\[\begin{aligned}
  &amp;g_1=x_1(t_j)+hu_1(t_j),\quad x_1(t_0)=1.0,\\
  &amp;f^0=h(x_1^2+u_1^2),\quad F=0.0, \\
  &amp;h=0.01,\quad t_0=0.0, \quad t_i=t_0+h(i-1),\quad t_N=t_1=1.0,\\
  &amp;{\mathbfit{u}}^I=0.0.\end{aligned}\]</span></p>
<p>Модель реализуем в виде класса, унаследовав его от <code>Model</code>:</p>
<div class="sourceCode" texcomments=""><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> LinModel1(Model):
    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):
        X0<span class="op">=</span>(<span class="fl">1.0</span>,)
        <span class="va">self</span>.h <span class="op">=</span> <span class="fl">0.01</span>
        <span class="va">self</span>.num <span class="op">=</span> <span class="bu">int</span>((<span class="fl">1.0</span><span class="op">-</span><span class="fl">0.0</span>) <span class="op">/</span> <span class="va">self</span>.h) <span class="co"># num=$N$</span>
        <span class="va">self</span>.T <span class="op">=</span> linspace(start<span class="op">=</span><span class="fl">0.0</span>, stop<span class="op">=</span><span class="fl">1.0</span>, num<span class="op">=</span><span class="va">self</span>.num)
        <span class="va">self</span>.t <span class="op">=</span> arange(<span class="bu">len</span>(<span class="va">self</span>.T))  <span class="co"># 0,1,2,3,4,5...</span>
        Model.<span class="fu">__init__</span>(<span class="va">self</span>, X0<span class="op">=</span>X0, U0<span class="op">=</span><span class="va">self</span>.start_control())

    <span class="kw">def</span> start_control(<span class="va">self</span>):  <span class="co"># $\vecu^I$=0.0</span>
        U <span class="op">=</span> [(<span class="fl">0.0</span>,) <span class="cf">for</span> t <span class="kw">in</span> <span class="va">self</span>.t[:<span class="op">-</span><span class="dv">1</span>]]
        <span class="cf">return</span> array(U)

    <span class="kw">def</span> F(<span class="va">self</span>, x):
        <span class="cf">return</span> <span class="fl">0.0</span>

    <span class="kw">def</span> g(<span class="va">self</span>, t, x, u):
        x0<span class="op">=</span>x[<span class="dv">0</span>]<span class="op">;</span> u0<span class="op">=</span>u[<span class="dv">0</span>]
        <span class="cf">return</span> (x0<span class="op">+</span><span class="va">self</span>.h<span class="op">*</span>u0,)   <span class="co"># Схема Эйлера для $\dot{x_1}=u_1$.</span>

    <span class="kw">def</span> f0(<span class="va">self</span>, t, x, u):
        x0<span class="op">=</span>x[<span class="dv">0</span>]<span class="op">;</span> u0<span class="op">=</span>u[<span class="dv">0</span>]
        <span class="cf">return</span> <span class="va">self</span>.h <span class="op">*</span> (x0<span class="op">*</span>x0<span class="op">+</span>u0<span class="op">*</span>u0)</code></pre></div>
<p>Теперь создадим экземпляр задачи, передадим его в качестве параметра в процесс улучшения, который тоже является экземпляром своего класса. Проведем тестовый запуск:</p>
<div class="sourceCode" texcomments=""><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> test_1():
    m <span class="op">=</span> LinModel1()          <span class="co"># Модель</span>
    p1<span class="op">=</span>Process(m, alpha<span class="op">=</span><span class="fl">1.0</span>) <span class="co"># Процесс улучшения</span>
    iters<span class="op">=</span><span class="dv">2000</span>   <span class="co"># Максимальное количество итераций</span>
    eps<span class="op">=</span><span class="fl">0.001</span>    <span class="co"># Точность аппроксимации минимума $I$</span>
    rc<span class="op">=</span>I1, X1, U1, it1, rstr <span class="op">=</span>
        p1.optimize(m.t, eps<span class="op">=</span>eps, iters<span class="op">=</span>iters)
    <span class="bu">print</span> (I1, <span class="st">&quot;iters:&quot;</span>, it1)

test_1()         <span class="co"># Запуск теста</span></code></pre></div>
<p>В результате запуска вычислений получим результат следующего вида:</p>
<pre class="text"><code>0.776664425757 iters: 47.</code></pre>
<p>Получается, что за 47 итераций получены управление и траектория, оцениваемая минимальным функционалом со значением 0,777. Траектория и управление изображены на рис. [fig:result]. На рисунке нижняя линия – это синтезированное оптимальное управление, а верхняя – траектория.</p>
<figure>
<img src="1dplot" alt="Результат расчета оптимального управления задачи" /><figcaption>Результат расчета оптимального управления задачи<span data-label="fig:result"></span></figcaption>
</figure>
</section>
<section id="резюме" class="level3">
<h3><span class="header-section-number">5.2.6</span> Резюме</h3>
<p>Мы рассмотрели практическое приложение процедур вычисления частных производных из функций. На самом деле данные процедуры не являются в полной мере реализациями какого“=либо метода искусственного интеллекта, но они демонстрируют, как при помощи синтеза (гибридизации) численного моделирования и символьных вычислений разрабатываются полезные приложения, а также экономится труд математиков и программистов: поскольку нет необходимости в выписывании и программировании процедур вычисления производных вектор”=функций.</p>
<p>Существенным недостатком разработанной программы является низкая производительность функции <code>fun</code>, так как она вычисляет производные заново при каждом обращении. Сделано это для того, чтобы не усложнять тексты программ в пособии. Проблема решается при помощи реализации механизма кеширования: вычислив производную из какой“=либо функции, надо сохранить ее копию в кеше. Дальнейшим развитием изложенного подхода к разработке программного обеспечения численных методов является порождение программ, реализующих метод на основе анализа или интерпретации Python”=программы. Интересным также является разработка библиотеки или программного пакета, при помощи которого можно было бы задавать уравнение движением в непрерывной форме вместе со схемой ее перевода в дискретный вид для численного решения, а по полученной схеме опять же генерировать высокопроизводительную программу, реализация которой учитывает особенности микропроцессора.</p>
</section>
</section>
</section>
<section id="заключение" class="level1 unnumbered">
<h1>Заключение</h1>
<p>В учебном пособии приведен ряд задач искусственного интеллекта, решения которых представлены в виде программ на логическом языке программирования Prolog. Представлены как классические, относящиеся к планированию действий, поиску решения с удовлетворением ограничений, так и задачи, апеллирующие к специфике численных методов решения дифференциальных уравнений и поиска оптимального управления движением. Отдельно рассмотрено применение логического языка для организации символьных вычислений. Свойства логического языка программирования позволяют программисту развить навыки логического мышления и серьезное отношение к своей программе не просто как к некоторому набору операторов, а как к строгой логической конструкции. Причем это касается не только языков программирования высокого уровня, таких как Prolog, Refal, и языков функционального программирования, но и языков императивных: С/С++/С#, Pascal, Visual Basic и т. д.</p>
<p>За рамками пособия остались такие интересные темы, как &lt;&lt;Эволюционные вычисления&gt;&gt;, &lt;&lt;Решение игровых задач&gt;&gt;, &lt;&lt;Экспертные системы&gt;&gt;, &lt;&lt;Анализ данных&gt;&gt; и др.</p>
<p>Надеемся, что задача пособия – рассказать, на каких принципах работают современные системы компьютерной алгебры, выполнена, а студенты&quot;=читатели с интересом знакомились с разделами пособия и выполняли задания. Надеемся также, что тематика учебного пособия теперь будет представлять научный интерес для читателей.</p>
<p>Задачи, рассмотренные в пособии, всегда присутствуют в любом производственном процессе, связанном с обработкой информации, но, к сожалению, они остаются незамеченными. Достаточно просто распознать вычислительную задачу, труднее – задачу, связанную с математическим моделированием, и совсем трудно – задачу автоматизации рассуждений и принятия решения. Читателю следует и далее уделять некоторое время развитию навыков программирования систем искусственного интеллекта и анализу бизнес&quot;=процессов предприятия с целью выявления и решения этих необычных задач.</p>
<p>Успехов в изучении методов искусственного интеллекта!</p>
<p><a href="http://eugeneai.github.io/ais/"><img src="QRickit.png" alt="image" /></a></p>
<p><a href="http://eugeneai.github.io/ais/" class="uri">http://eugeneai.github.io/ais/</a></p>
<p><span>99</span> plus 0.3pt Братко И. : пер. с англ./ И. Братко. – М.: Мир, 1990. – 560 c.: ил. Васильев С. Н. / С. Н. Васильев, А. К. Жерлов, Е. А. Федосов, Б. Е. Федунов. – М.: Физматлит, 2000. – 352 с: ил. / под ред. Э. В. Попова. – М.: Радио и связь, 1990. – 464 c.:ил. Лорьер. Ж.-Л. / Ж.-Л. Лорьер. – М.: Мир, 1991. – 568 с.: ил. Лутц М. <a href="https://vk.com/doc10903696_196246835?hash=4b80f3cf914c7d65dd&amp;dl=f90686bee18e565271">Изучаем Python, 4-е издание.</a>: пер. с англ./ М. Лутц. СПб.:Символ-Плюс, 2011. 1280 с., ил. / гл. ред. Ю. В. Прохоров. – М.: Сов. энциклопедия, 1988. – 847 c. Непейвода Н. Н. / Н. Н. Непейвода, И. Н. Скопин. – Москва; Ижевск: Институт компьютерных исследований, 2003 – 880 c.: ил. Непейвода Н. Н. / Н. Н. Непейвода. – 2-е изд. – Новосибирск: Изд-во Новосиб. ун-та, 2000. – 521 c.: ил. <a href="http://younglinux.info/sites/default/files/python_structured_programming.pdf">Основы программирования на Python.</a> [Электронный ресурс]: сайт. URL:<a href="http://younglinux.info/sites/default/files/python_structured_programming.pdf" class="uri">http://younglinux.info/sites/default/files/python_structured_programming.pdf</a>. (дата обращения: 11.01.2015). Понтрягин Л. С. Принцип максимума в оптимальном управлении / Л. С. Понтрягин. 2-е изд. М.: Едиториал УРСС, 2004. – 64 с. Рассел С. <a href="http://www.aiportal.ru/downloads/books/ai-modern-approach-2-edition-by-rassel-norvig.html">Искусственный интеллект: современный подход</a>: пер. с англ./ С. Рассел, П. Новриг. 2-е изд. – М.: Изд. дом &lt;&lt;Вильямс&gt;&gt;, 2006. – 1408 c.: ил. <a href="http://mapservis.ru/docs/tar_ruc_4.htm">Тарифное руководство № 4. Книга 2. Часть 1. Алфавитный список железнодорожных станций.</a> [Электронный ресурс]: сайт. <a href="http://mapservis.ru/docs/tar_ruc_4.htm" class="uri">http://mapservis.ru/docs/tar_ruc_4.htm</a> (дата обращения: 06.05.2015). . URL:<a href="http://www.gprolog.org/" class="uri">http://www.gprolog.org/</a>. (дата обращения: 28.11.2013). OpenStreetMap Nominatim: Search. [Электронный ресурс]: сайт. URL:<a href="http://wiki.openstreetmap.org/wiki/Nominatim" class="uri">http://wiki.openstreetmap.org/wiki/Nominatim</a>. (дата обращения: 11.01.2015). Sethi S. P., Thomson G. L. Optimal Control Theory: Applications to Management Science and Economics. 2nd Edition. 2005. 506 pp. . URL:<a href="http://www.swi-prolog.org/" class="uri">http://www.swi-prolog.org/</a>. (дата обращения: 28.11.2013). Welcome to Python.org. [Электронный ресурс]: сайт. URL:<a href="https://www.python.org/" class="uri">https://www.python.org/</a> (дата обращения: 11.01.2015).</p>
</section>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>В англоязычной литературе данный термин называется <em>Artifical Inelligence, AI</em>.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p><em>Англ.</em> – Knowledge Acquisition.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>Например, математическое моделирование, базы данных.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>Интуитивное определение алгоритма: <em>алгоритм</em> – это конечная последовательность действий, каждое из которых выполняется за конечное время, приводящая к определенному результату.<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>Данное определение задает термин в достаточно узком смысле.<a href="#fnref5">↩</a></p></li>
<li id="fn6"><p>На самом деле это определение не охватывает такую важную отрасль ИИ, как нейронные сети.<a href="#fnref6">↩</a></p></li>
<li id="fn7"><p>Вообще говоря, данное предложение не является определением, оно неконструктивно, т. е. не задает логических связей с известными объектами и терминами. В частности, термин &lt;&lt;навык&gt;&gt; тоже подходит под это же определение как нечто, отличное от &lt;&lt;данных&gt;&gt;.<a href="#fnref7">↩</a></p></li>
<li id="fn8"><p>Способы формального описания.<a href="#fnref8">↩</a></p></li>
<li id="fn9"><p>Со знака процента &lt;&lt;<code>%</code>&gt;&gt; начинается комментарий к тексту программы.<a href="#fnref9">↩</a></p></li>
<li id="fn10"><p>Разные реализации интерпретаторов задают различные ограничения на алфавит букв, из которых можно формировать идентификаторы. Одни интерпретаторы позволяют использовать только буквы латинского алфавита, другие – всю таблицу Unicode.<a href="#fnref10">↩</a></p></li>
<li id="fn11"><p>В математической логике атомами обозначают неделимые высказывания, т. е. конструкции вида <span class="math inline">\(m(x)\)</span>, <span class="math inline">\(h(x)\)</span>. Это, конечно, приводит к некоторой путанице.<a href="#fnref11">↩</a></p></li>
<li id="fn12"><p>Предикат (от лат. <em>praedicatum</em> – сказуемое) в узком смысле – то же, что термин &lt;&lt;свойство&gt;&gt;; в широком смысле – отношение, т. е. общее свойство нескольких предметов. В логике – пропозициональная функция, т. е. выражение с неопределенными терминами (переменными), при выборе конкретных значений для этих терминов преобразующееся в осмысленное (истинное или ложное) высказывание.<a href="#fnref12">↩</a></p></li>
<li id="fn13"><p>Фактически производится добавление новых знаний и фактов из загружаемого файла. Если в файле содержатся определения предикатов, которые уже имеются в рабочей памяти системы, то происходит обновление этих предикатов. Это может стать причиной неработоспособности программы. Рекомендуется иногда выходить из интерпретатора и очищать рабочую память.<a href="#fnref13">↩</a></p></li>
<li id="fn14"><p>Терм – структура, обозначающая объект <span class="citation" data-cites="DDW"></span>. Терм обобщает понятия константы, переменной и функции. Например, высказывание <code>h(wife(s))</code> содержит терм <code>wife(s)</code>, обозначающий жену Сократа.<a href="#fnref14">↩</a></p></li>
<li id="fn15"><p>Программа на языке Prolog занимает значительно меньше места, чем программа на языке C. Это в основном связано с тем, что Prolog&quot;=интерпретатор представляет сам по себе механизм поиска решения &lt;&lt;в глубину&gt;&gt;, а в C-программе его надо реализовать.<a href="#fnref15">↩</a></p></li>
<li id="fn16"><p>Большинство реализаций языка Prolog не разрешают переопределять библиотечные предикаты. Если собираетесь экспериментировать, то выберите для него какое-нибудь другое имя.<a href="#fnref16">↩</a></p></li>
<li id="fn17"><p>На самом деле можно загрузить архив пакета и выполнить установку и без подключения к Интернету. Процедура установки описана на сайте SWI-Prolog <span class="citation" data-cites="SWIP"></span>.<a href="#fnref17">↩</a></p></li>
<li id="fn18"><p>В список станций не входит &lt;&lt;Красноярск&quot;=Главный&gt;&gt;, так как в базе данных он не является транзитным пунктом.<a href="#fnref18">↩</a></p></li>
<li id="fn19"><p>Англ. <em>, CSP.</em><a href="#fnref19">↩</a></p></li>
<li id="fn20"><p>Алгоритмов, в которых на этапах выбора очередного направления поиска решения из нескольких альтернатив используется дополнительная (по отношению к исходной) информация для задания этим альтернативам некоторого предпочтения.<a href="#fnref20">↩</a></p></li>
<li id="fn21"><p>В советской литературе вариант этого подхода известен как метод &lt;&lt;Отобразить и проверить&gt;&gt; (источник информации, к сожалению, потерян). В настоящее время широко используется термин &lt;&lt;Метод грубой силы&gt;&gt; (<span><em></em></span>) для обозначения данного подхода.<a href="#fnref21">↩</a></p></li>
<li id="fn22"><p>Существует фундаментальная проблема остановки, которая делает такую проверку, в общем случае, невозможной.<a href="#fnref22">↩</a></p></li>
<li id="fn23"><p>Автор пособия не ставил целью найти самую эффективную и короткую программу для решения этой задачи. Задача – продемонстрировать ход рассуждений.<a href="#fnref23">↩</a></p></li>
<li id="fn24"><p>Фасадный предикат предназначен для запуска пользователем. За фасадом здания скрывается вся его сложная конструкция, доступная для понимания только специалистам.<a href="#fnref24">↩</a></p></li>
<li id="fn25"><p>Специальные варианты унификаций SWI-Prolog рассматриваются на странице <a href="http://www.swi-prolog.org/pldoc/man?section=unifyspecial" class="uri">http://www.swi-prolog.org/pldoc/man?section=unifyspecial</a>.<a href="#fnref25">↩</a></p></li>
<li id="fn26"><p>Последовательность слагаемых в запросе имеет принципиальное значение.<a href="#fnref26">↩</a></p></li>
<li id="fn27"><p>Самолета, корабля, автомобиля, природного ресурса и т. д.<a href="#fnref27">↩</a></p></li>
<li id="fn28"><p>Переводить управляемый объект в новое состояние &lt;&lt;волевым усилием&gt;&gt; функции <span class="math inline">\({\mathbfit{u}}.\)</span><a href="#fnref28">↩</a></p></li>
</ol>
</section>
</body>
</html>
