<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<p><span> Министерство образования и науки Российской федерации<br />
Федеральное государственное бюджетное образовательное<br />
учреждение высшего профессионального образования<br />
&lt;&lt;Иркутский государственный университет&gt;&gt;<br />
Учреждение Российской академии наук<br />
&lt;&lt;Институт динамики систем и теории управления<br />
Сибирского отделения РАН&gt;&gt; </span> to<br />
<strong>Иркутск 2013</strong></p>
<p>УДК 681.3.06 (075.8)<br />
ББК 32.973-01я73<br />
Ч-48</p>
<p>Печатается по решению ученого совета ИМЭИ<br />
<strong>Издание выходит в рамках Программы<br />
стратегического развития ФГБОУ ВПО &lt;&lt;ИГУ&gt;&gt;<br />
на 2012–2016 гг., проект Р121-02-001</strong></p>
<p><strong>Рецензенты:</strong><br />
канд. техн. наук <span><em>В. С. Ульянов</em></span>,<br />
канд. физ.-мат. наук <span><em>А. А. Лемперт</em></span></p>
<p><br />
Ч-48</p>
<p><span><strong>Черкашин Е. А.</strong></span></p>
<p>Рекурсивно&quot;=логическое программирование: учеб. пособие/ Е. А. Черкашин. – Иркутск: Изд-во ИГУ, 2013. –  c.</p>
<p><span><strong>ISBN 978-5-9624-0938-2</strong></span></p>
<p>В пособии представлены лекционные материалы и лабораторные работы курса &lt;&lt;Рекурсивно“=логическое программирование&gt;&gt;: базовые термины искусственного интеллекта, задачи, методы и их свойства; основы рекурсивно”=логического программирования на языке Пролог; типичные задачи, решение которых лаконично представляется как рекурсивные и переборные алгоритмы. Пособие содержит задания на лабораторный практикум по темам &lt;&lt;Формализация&gt;&gt;, &lt;&lt;Обработка списков&gt;&gt;, &lt;&lt;Метод Британского музея (отобразить и проверить)&gt;&gt; и &lt;&lt;Базы данных&gt;&gt;.</p>
<p>Пособие предназначено для студентов специальности &lt;&lt;инженер&quot;=программист&gt;&gt;, &lt;&lt;инженер—системный программист&gt;&gt;. Изучение материала будет полезно студентами других специальностей, так или иначе связанных с программированием, формальной логикой и комбинаторикой.</p>
<p>УДК 681.3.06 (075.8)<br />
ББК 32.973-01я73</p>
<p>ISBN 978-5-9624-0938-2</p>
<ul>
<li><p>Черкашин Е. А., 2013</p></li>
<li><p>ФГБОУ ВПО &lt;&lt;ИГУ&gt;&gt;, 2013</p></li>
<li><p>Институт динамики систем и теории управления СО РАН, 2013</p></li>
</ul>
<section id="предисловие" class="level1 unnumbered">
<h1>Предисловие</h1>
<p>Предлагаемое учебное пособие разработано для студентов специальности &lt;&lt;инженер“=программист&gt;&gt;, &lt;&lt;инженер—системный программист&gt;&gt;, однако может быть использовано всеми заинтересованными программистами, желающими овладеть некоторыми методами искусственного интеллекта. Пособие подборку материала по курсу &lt;&lt;Рекурсивно”=логическое программирование&gt;&gt;, а также варианты лабораторных работ и методические указания по их выполнению. Оно никоим образом не претендует на полноту излагаемого материала и базируется на личном опыте преподавания. Пособие следует воспринимать как путеводитель, и учащиеся в процессе обучения должны активно использовать литературу, на которую в тексте указаны ссылки. В цитируемом тексте в виде сносок автор позволяет себе высказывать свое отношение к изложенному.</p>
<p>В пособие включены как разделы, разработанные лично автором пособия, так и заимствованные из других источников и адаптированные к современному состоянию, в частности из книг И. Братко, Дж. Малпаса, справочников и т. д. Везде, где произведено такое заимствование, в первом абзаце указана ссылка на оригинальный источник. При подготовке данного пособия автор придерживался той точки зрения, что использованный материал является наиболее простым для понимания студентами, лаконично представляет суть изучаемого материала, поэтому его дальнейшее совершенствование или изложение как-то по&quot;=новому не имеет никакого смысла. Автор не преследует целью коммерческое использование учебного пособия. В электронной версии пособия ссылки на литературу в списке литературы — активные и ведут к найденным в Интернете электронным версиям книг. Читатель должен решить самостоятельно: скачивать их из Интернета, покупать в магазинах или искать в библиотеках.</p>
<p>Автор является приверженцем открытых технологий, свободных книг, научного метода познания мира и открытого программного обеспечения. Адрес исходного кода методического пособия — <a href="https://github.com/eugeneai/ais/tree/new-isu" class="uri">https://github.com/eugeneai/ais/tree/new-isu</a>. Исхоный код разрешено использовать в соответствии с лицензией , которая разрешает использование материала в своих произведениях (необходимо указывать автора оригинальных материалов), запрещает коммерческое использование материалов (ввиду наличия вышеперечисленных заимствований) и требует распространение производных материалов производить по этой же самой лицензии (по предыдущей причине). Адрес лицензии — <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" class="uri">http://creativecommons.org/licenses/by-nc-sa/4.0/</a>.</p>
<p>В тексте пособия использована следующая разметка:</p>
<dl>
<dt>Жирным шрифтом</dt>
<dd><p>выделяются имена существительные и глаголы, на которые, по мнению автора, следует обратить внимание, это — что-то вроде дополнительной семантической разметки текста учебного пособия.</p>
</dd>

<dd><p>приводятся программы, отрывки программ в основном тексте пособия, а также имена идентификаторов, т. е. все, что имеет какое&quot;=либо отношение к <span><strong>тексту программы</strong></span>.</p>
</dd>

<dd><p>выделяются <span><strong>новые</strong></span> термины, вводимые в текст и возникающие, например, в определениях, а также текст выделенных примеров.</p>
</dd>
<dt>При помощи &lt;&lt;кавычек&gt;&gt;</dt>
<dd><p>выделяются метафоры, значения, элементы текстов программ, цитаты, слова, использованные в переносном смысле, и т. д.</p>
</dd>
</dl>
<p>Надеюсь, что изучение такого интересного раздела информатики как &lt;&lt;Искусственный интеллект&gt;&gt;, к которому относится рекурсивно&quot;=логическое программирование, доставит учащимся не меньше удовольствия, чем в свое время автору этого учебного пособия.</p>
<p>Автор признателен своему научному руководителю академику Российской академии наук С.“,Н.”,Васильеву за создание плодотворной почвы для проведения научных исследований в области систем искусственного интеллекта. Автор благодарит преподавателей Института кибернетики, Кафедры вычислительной техники Национального исследовательского Иркутского государственного технического университета, а также преподавателей Института математики, экономики и информатики Иркутского государственного университета за предоставление возможности изучать область искусственного интеллекта.</p>
<p>Автор благодарит канд. геол.-минерал. наук Т. Ю. Черкашину, канд. техн. наук А. К. Попову за помощь в подготовке данного учебного пособия.</p>
<p>to to to to <span>P. S.</span> Автора всегда можно найти по адресу <a href="mailto:eugeneai@icc.ru">eugeneai@icc.ru</a>, в поле &lt;&lt;<span>тема</span>&gt;&gt; прошу указывать &lt;&lt;РЛП-2013&gt;&gt;.</p>
</section>
<section id="введение-в-область-искусственного-интеллекта" class="level1">
<h1><span class="header-section-number">1</span> Введение в область искусственного интеллекта</h1>
<p>Среди задач, которые решают современные программисты, выделяются задачи создания программных систем математического моделирования и прогнозирования, проектирования и реализации информационных систем и баз данных, системного программного обеспечения. Все перечисленные задачи объединяет одно общее свойство — для широкого практического класса задач можно построить детерминированную процедуру (например, алгоритм) их решения. Существует большой класс задач, для которых такую процедуру построить достаточно сложно, а порой и невозможно. Например, разработать игровую систему, способную играть в шахматы с человеком на достаточно высоком профессиональном уровне. К таким задачам относятся также и задачи поиска решения (планирование действий, или Problem Solving), распознавание образов, экспертные консультации, интеллектуальное управление сложными динамическими объектами и т. д. В каждой такой задаче четко вырисовывается их первое общее <span><strong>свойство</strong></span> — необходимость <span><strong>автоматизации принятия некоторого решения</strong></span>. В других задачах четко вырисовывается еще одно свойство — <span><strong>обработка символьной информации</strong></span>. Примерами задач, обработка информации в которых основывается на преобразовании строк символов, выступают следующие задачи: автоматический перевод текста с одного естественного языка на другой, автоматическое доказательство теорем. В той или иной мере оба выделенных свойства присутствуют в каждой из перечисленных задач.</p>
<p>Средства рекурсивно“=логического программирования позволяют представить решение таких задач, алгоритм, в рекурсивном виде или в виде некоторого переборного процесса. Такое представление обладает одним полезным свойством — оно компактно и достаточно близко к исходной математической модели задачи по сравнению с изученной ранее процедурной парадигмой программирования. Программисту не требуется определять все действия, необходимые для достижения результата. Как правило, достаточно рассказать транслятору, какие данные есть в наличии, объяснить, как они связаны друг с другом и постановкой задачи. Система постарается получить решение самостоятельно. Рекурсивно”=логическое программирование прежде всего направлено на решение задач искусственного интеллекта (ИИ)<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>, поэтому в данном учебном пособии необходимо ввести читателя в базовые концепции ИИ. Для начала рассмотрим, как можно определить, относится ли ваша задача к задачам ИИ.</p>
<p>Рассмотрим задачи планирования действий (). Что есть решение в этих задачах? Это — ответ на вопрос &lt;&lt;Какие действия необходимо выполнить и в каком порядке их надо выполнять, чтобы достичь цели из некоторого начального состояния?&gt;&gt;. Получается, что ответ на этот вопрос есть некоторая конечная последовательность действий. Эта последовательность представляется в памяти компьютера в виде некоторого ряда чисел, кодирующего эту последовательность. Построить (найти) эту последовательность, выбрать последовательность из возможных альтернатив — это и есть принятие решения.</p>
<p>Есть еще один интересный аспект алгоритма — массовость, т. е. алгоритмы должны строиться для некоторого класса задач, а не для конкретных входных данных. Что это значит? На вход программы, реализующей алгоритм, подаются какие&quot;=либо входные данные, задающие конкретную задачу из класса решаемых алгоритмом задач. Теперь представим такую ситуацию, что на вход алгоритма невозможно подать все необходимые данные, т. е. имеет место <em>неполнота информации</em>. Или другой вариант — имеется два эксперимента с разными результатами, но с одинаковым набором исходных данных. Какие данные следует передавать на вход алгоритма? Этот случай связан с <em>противоречивой информацией</em>. Разрабатывая программное обеспечение, позволяющее функционировать в таких условиях, приходится создавать подпрограммы, принимающие решение, что следует делать. Например, во втором случае можно запустить алгоритм для каждого набора данных и проанализировать полученные результаты. Может получиться так, что эти результаты не будут сильно отличаться друг от друга, а может этого не получиться. В последнем случае одним из вариантов дальнейших действий является поиск нового атрибута (характеристики), который позволит различать варианты, находящиеся в противоречии.</p>
<p>Задачи, обладающие перечисленными свойствами, и методы их решения на ЭВМ в конечном счете составляют предмет исследования искусственного интеллекта — одного из разделов информатики (Computer Science).</p>
<section id="термин-искусственный-интеллект" class="level2">
<h2><span class="header-section-number">1.1</span> Термин &lt;&lt;искусственный интеллект&gt;&gt;</h2>
<p>В литературе можно найти целый спектр определений термина искусственный интеллект, однако, насколько известно автору, ни один из них не принят как стандарт.</p>
<p>Среди многих точек зрения доминируют три <span class="citation" data-cites="AIDictionary"></span>. Согласно <span><strong>первой</strong></span>, исследования в области искусственного интеллекта являются фундаментальными исследованиями, в рамках которых разрабатываются модели и методы решения задач, традиционно считавшихся интеллектуальными и не поддававшихся ранее формализации и автоматизации. Согласно <span><strong>второй</strong></span> точке зрения, новое направление связано с новыми идеями решения задач на ЭВМ, с разработкой принципиально иной технологии программирования, с переходом к архитектуре ЭВМ, отвергающей классическую архитектуру, которая восходит еще к первым ЭВМ. Наконец, <span><strong>третья точка зрения</strong></span>, по&quot;=видимому, наиболее прагматическая, состоит в том, что в результате работ в области искусственного интеллекта рождается множество прикладных систем, решающих задачи, для которых ранее создаваемые системы были непригодны.</p>
<p>Достаточно простые определения <span><em>искусственного интеллекта</em></span> показаны в таблице [pic:determai] <span class="citation" data-cites="Russell"></span>. Выделяются несколько комбинаций двух пар ключевых терминов: &lt;&lt;размышлять&gt;&gt; и &lt;&lt;вести себя&gt;&gt;, &lt;&lt;как человек&gt;&gt; и &lt;&lt;рационально&gt;&gt;.</p>
<table>
<caption>Несколько определений искусственного интеллекта<span data-label="pic:determai"></span></caption>
<thead>
<tr class="header">
<th style="text-align: left;">Системы, которые размышляют, как люди</th>
<th style="text-align: left;">Системы, которые размышляют рационально</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Системы, которые ведут себя, как люди</td>
<td style="text-align: left;">Системы, которые ведут себя рационально</td>
</tr>
</tbody>
</table>
<p><span><em>Искусственный интеллект</em></span> как наука насчитывает уже около 60 лет. Задачей этой науки является воссоздание с помощью искусственных устройств (в основном с помощью ЭВМ) разумных рассуждений и действий <span class="citation" data-cites="Lauriere"></span>.</p>
<p><span><em>Искусственный интеллект</em></span> — раздел информатики, изучающий методы, способы и приемы моделирования и воспроизведения с помощью ЭВМ разумной деятельности человека, связанной с решением задач <span class="citation" data-cites="math_slov:88"></span>.</p>
<section id="тест-тьюринга" class="level3">
<h3><span class="header-section-number">1.1.1</span> Тест Тьюринга</h3>
<p>В книге <span class="citation" data-cites="Russell"></span> вводится понятие <span><em>агента</em></span>. <span><em>Агент</em></span> — субъект, находящийся в среде, имеющий цель своего существования, взаимодействующий со средой или другими агентами с помощью <span><em>рецепторов</em></span> и <span><em>эффекторов</em></span>. Рецепторы воспринимают информацию о среде, а эффекторы — это способ воздействия на среду, которое меняет среду, а следовательно, и информацию о среде. Агентом может являться как программа, так и человек. Вводится понятие <span><em>интеллектуального агента</em></span> — агента, обладающего интеллектом.</p>
<p>Агенты взаимодействуют друг с другом. Примером такого взаимодействия выступают, например, общение человека с человеком или работа человека с компьютерной программой.</p>
<p>Тест Тьюринга предложен Аланом Тьюрингом (1950), и был разработан, чтобы представить действующее определение интеллекта <span class="citation" data-cites="Russell"></span>. Тьюринг определял интеллектное поведение как возможность достижения человеческого уровня производительности во всех задачах, где возможно обмануть человека, задающего вопросы. Грубо говоря, предложенный им тест состоял в следующем. Компьютеру задает вопросы человек через удаленное устройство. Тест считается пройденным, если человек не может сказать, кто или что на другом конце устройства: компьютер или человек.</p>
<p>С точки зрения агентов, этот тест можно представить так: один интеллектуальный агент (человек) по информационному каналу, не позволяющему ему использовать иную информацию, кроме ответов на поставленные им вопросы, анализирует поступающую информацию (ответы собеседника) от другого агента (испытуемого). Если первый агент не в силах определить, кто на другом конце информационного канала — человек или устройство, тогда считается, что испытуемый агент обладает интеллектуальными свойствами.</p>
</section>
<section id="применение-искусственного-интеллекта" class="level3">
<h3><span class="header-section-number">1.1.2</span> Применение искусственного интеллекта</h3>
<p>Всякая задача, для которой неизвестен алгоритм решения, априорно относится к ИИ. Перечислим некоторые направления (задачи) ИИ <span class="citation" data-cites="AIDictionary"></span>:</p>
<dl>
<dt>Восприятие и распознавание образов.</dt>
<dd><p>К таким задачам относятся распознавание текста (как печатного, так и рукописного), компьютерное зрение.</p>
</dd>
<dt>Автоматическое доказательство теорем.</dt>
<dd><p>В этом направлении решаются задачи автоматизации математических исследований, разработки формальных (математических) методов логического вывода для поддержки решения других задач ИИ. Это направление нашло применение в задачах верификации программного и аппаратного обеспечения.</p>
</dd>
<dt>Игры.</dt>
<dd><p>Автоматизация решения игровых задач, например, игры в шахматы, калах, реверси, а также других игр.</p>
</dd>
<dt>Решение задач (Problem Solving), планирование.</dt>
<dd><p>В этих задачах предполагается наличие некоторого выбора из возможных путей решения, требуется найти первое, лучшее или оптимальное решение. Примеры: составление расписания работы учебного учреждения, планирование действий автономного необитаемого аппарата.</p>
</dd>
<dt>Понимание естественного языка.</dt>
<dd><p>Как правило, системы понимания естественного языка являются составляющими информационных систем различного назначения: от автоматических систем заказа билетов до систем ввода экспертного знания.</p>
</dd>
<dt>Логическое программирование.</dt>
<dd><p>Языки и системы программирования высокого выразительного уровня, построенные на основе результатов исследования формально&quot;=логических систем, теорий исчислений. Эта область ИИ носит, кроме прочего, инструментальный характер, т. е. логическое программирование является средством реализации систем ИИ.</p>
</dd>
<dt>Экспертные системы.</dt>
<dd><p>Экспертные системы (ЭС) позволяют заменять человека&quot;=эксперта в некоторой предметной области программной системой, способной проводить экспертные консультации пользователя. ЭС нашли широкое применение в индустрии.</p>
</dd>
<dt>Интеллектные информационные системы.</dt>
<dd><p>Эти cистемы объединяют разнородные интеллектные системе (например, системы речевого общения, решения задач и др.) для организации интеллектного доступа, обработки информации. Они, как правило, предназначены для работы с конечным пользователем низкой квалификации. Пример: электронные переводчики и разговорники.</p>
</dd>
<dt>Восприятие и усвоение знаний.</dt>
<dd><p>Одна из задач ИИ — это приобретение знаний<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> (обучение, наполнение базы знаний) от человека или самостоятельно из среды функционирования. Системы усвоения знаний используются как подсистемы других интеллектных систем.</p>
</dd>
<dt>Интеллектное управление <span class="citation" data-cites="Vass:2000"></span>.</dt>
<dd><p>Новое направление, появившееся на стыке ИИ и теории управления, в котором разрабатываются управляющие системы, основанные на тех или иных методах ИИ. В настоящее время наиболее развиты методы управления на основе нечеткой логики и искусственных нейронных сетей. В этом новом направлении ведутся научные разработки Института динамики систем и теории управления СО РАН (<a href="http://www.idstu.irk.ru" class="uri">http://www.idstu.irk.ru</a>).</p>
</dd>
<dt>Робототехника (Robotics).</dt>
<dd><p>Собирательное направление исследований, задачей которого является автоматизация функционирования роботов, вплоть до полной независимости их от человека.</p>
</dd>
</dl>
</section>
<section id="определение-задач-ии-в-контексте-пособия" class="level3">
<h3><span class="header-section-number">1.1.3</span> Определение задач ИИ в контексте пособия</h3>
<p>К сфере искусственного интеллекта относятся задачи, обладающие следующими свойствами <span class="citation" data-cites="Lauriere"></span>:</p>
<ul>
<li><p>в них используется информация в символьной форме: буквы, слова, знаки, рисунки. Это отличает область ИИ от областей, в которых традиционно компьютерам доверяется обработка данных в числовой форме<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>;</p></li>
<li><p>в них предполагается наличие выбора; действительно, сказать, что не существует алгоритма<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a>, — это значит сказать, по сути дела, только то, что нужно сделать выбор между многими вариантами в условиях неопределенности, и этот недетерминизм, который носит фундаментальный характер, эта свобода действия являются существенной составляющей интеллекта.</p></li>
</ul>
<p>Излагаемый в пособии курс подразумевает непосредственное изучение технических аспектов применения методов ИИ, таких как применимость того или иного метода в конкретной задаче, реализация программных модулей конкретного метода. Поэтому в предлагаемом курсе мы будем использовать следующее определение искусственного интеллекта:</p>
<blockquote>
<p><span><em>Искусственный интеллект</em></span> — область информатики, в которой разрабатываются и исследуются методы построения программных систем и решения задач так или иначе связанных с принятием решения и обработкой символьной информации<a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a>.</p>
</blockquote>
</section>
</section>
<section id="данные-и-знания" class="level2">
<h2><span class="header-section-number">1.2</span> Данные и знания</h2>
<p>Одним из фундаментальных терминов ИИ является термин <span><em>знание</em></span>. Данный термин также является сложным в смысле его конструктивного определения, понятного читателю. Как правило, авторы статей по ИИ сознательно уклоняются давать более или менее точные определения, предполагая, что читателю это уже известно.</p>
<p>Более формальный термин &lt;&lt;данные&gt;&gt; получил широкое распространение в научно&quot;=техническом обиходе, в особенности в практике использования ЭВМ для решения самых разнообразных задач <span class="citation" data-cites="AIDictionary"></span>. При этом вся обрабатываемая информация называется данными: начальными, промежуточными или конечными, входными или выходными. Для предложений естественного языка более привычен термин &lt;&lt;знание&gt;&gt;, а чаще — связанный с ним глагол &lt;&lt;знать&gt;&gt;. Ни у кого не вызывает возражений использование этого слова в предложениях вроде &lt;&lt;я знаю, как решить задачу&gt;&gt;, или &lt;&lt;я знаю, что вчера Петя встречался с Наташей&gt;&gt;. Сомнению может подвергаться лишь истинность подобных утверждений, но никак не возможность сочетания слова &lt;&lt;знать&gt;&gt; с фрагментами предложения, обозначающих любую информацию, о которой говорится, что она кому-то известна.</p>
<p>Вопрос о разделении информации на данные и знания возник при разработке систем ИИ, определяемых в последнее время как системы, основанные на знаниях<a href="#fn6" class="footnoteRef" id="fnref6"><sup>6</sup></a>. Был предложен ряд определений, отражающих различные аспекты этих понятий, но касающихся скорее форм (см. раздел [sec:knowlege_repr] представления данных и знаний, правил их использования, чем их сути.</p>
<section id="два-подхода-к-разработке-методов-и-средств-ии" class="level4 unnumbered">
<h4>Два подхода к разработке методов и средств ИИ</h4>
<p>Суть подхода выражена в фразе &lt;&lt;<span><em>Давайте создадим механическое (вычислительное) устройство, похожее на (моделирующее) мозг человека, а затем посмотрим, как оно будет решать задачи ИИ</em></span>&gt;&gt;.</p>
<p>В основе этого подхода лежит <span><em>разработка методов моделирования процесса мышления человека (логических выводов, логических рассуждений</em></span>.</p>
<p>Методы и системы ИИ, основанные на подходе &lt;&lt;Снизу&quot;=вверх&gt;&gt;, как правило, представляют собой сложную сеть взаимосвязанных, простых по сути, элементарных агентов. Эта сеть агентов формирует агента высокого уровня, направленного на решение конкретной задачи ИИ. Элементарные агенты сети вносят небольшой персональный вклад в решение агента высокого уровня. Выделяют одно из достоинств этого подхода — <span><em>если задача &lt;&lt;не решается&gt;&gt; какими-то формальными методами, то ее &lt;&lt;хоть какое-то&gt;&gt; решение может быть получено методами &lt;&lt;Снизу&quot;=вверх&gt;&gt;</em></span>. Как правило, схема применения описываемых методов и систем состоит из двух этапов: <span><strong>обучение</strong></span> на известном наборе &lt;&lt;данные — решения&gt;&gt; (данные и решения известны) и <span><strong>решения</strong></span> новых задач (данные известны, решения — нет).</p>
<p>Известным недостатком, присущим методам и системам &lt;&lt;Снизу&quot;=вверх&gt;&gt;, является неопределенность характеристик с точки зрения их практического применения: трудно ответить, например, на вопросы: &lt;&lt;Сколько нужно агентов, чтобы решить конкретную задачу? Каковы должны быть связи между агентами?&gt;&gt;. В каждом конкретном случае требуются эмпирические исследования (&lt;&lt;сможет–не сможет&gt;&gt;).</p>
<p>Типичным представителем подхода &lt;&lt;Снизу&quot;=вверх&gt;&gt; являются нейронные сети.</p>
<p>Моделирование логических выводов и рассуждений — основа подхода &lt;&lt;Сверху“=вниз&gt;&gt;. В системах ИИ (агентах), основывающихся на этом подходе, как правило, <span><strong>четко выделяют</strong></span> функциональные блоки &lt;&lt;Хранилище Базы знаний&gt;&gt;, &lt;&lt;Машина логического вывода&gt;&gt; и интерфейс &lt;&lt;Рецептор—Блок рассуждений—Эффектор&gt;&gt;. В задачу последнего блока входит преобразование информации в/из вид(а), используемый(ого) в первых двух блоках. Именно в этих методах и системах ИИ возникает задача представления знаний в некотором формализованном виде, удобном для осуществления их интерпретации и преобразований в блоке &lt;&lt;Машина логического вывода&gt;&gt;. Примерами систем &lt;&lt;Сверху”=вниз&gt;&gt; выступают язык программирования Пролог, экспертные системы, системы автоматического логического вывода.</p>
<p>Исходя из общих соображений, естественно определить данные как некоторые сведения об отдельных объектах, а знания — о мире в целом. В согласии с таким подходом будем считать, что:</p>
<blockquote>
<p><span><em>Данные</em></span> представляют информацию о существовании объектов с определенными комбинациями свойств (значений признаков), а <span><em>знания</em></span> — информацию о существующих в мире закономерных связях между признаками, запрещающих некоторые другие сочетания свойств у объектов.</p>
</blockquote>
<p>Отсюда следует, что различие между данными и знаниями можно сформулировать так: <span><em>данные</em></span> — это информация о существовании объектов с некоторым набором свойств, а <span><em>знания</em></span> — информация о несуществовании объектов с некоторым набором свойств<a href="#fn7" class="footnoteRef" id="fnref7"><sup>7</sup></a>.</p>
<p>Используя логический формализм (см. далее) представления знаний, продемонстрируем эти понятия в формализованном виде. Отображая наличие упомянутых наборов предикатами <span class="math inline">\(P\)</span> и <span class="math inline">\(Q\)</span>, можно представлять <span><em>данные</em></span> утверждениями с кванторами существования <span class="math inline">\(\exists\)</span>: <span class="math display">\[\exists w: P(w),\]</span> а <span><em>знания</em></span> — утверждениями с его отрицанием <span class="math inline">\(\neg\exists\)</span>: <span class="math display">\[\neg\exists w: Q(w),\]</span> легко преобразуемыми в утверждения с квантором <span class="math inline">\(\forall\)</span>: <span class="math display">\[\forall w: \neg Q(w).\]</span> Вообще говоря, последняя форма (с использованием отрицания некоторого высказывания) практически не используется. Однако используется форма, подобная этой — <span class="math inline">\(\forall w: A(w)\to B(w)\)</span>. Здесь, по сути, важен факт присутствия квантора всеобщности, говорящего, что <span><strong>все объекты</strong></span> <span class="math inline">\(w\)</span>, обладающие свойством <span class="math inline">\(A\)</span>, будут обладать свойством <span class="math inline">\(B\)</span>.</p>
<p>Тремя базовыми элементами как практической, так и теоретической рациональной деятельности являются<a href="#fn8" class="footnoteRef" id="fnref8"><sup>8</sup></a> следующие <span class="citation" data-cites="DDWII"></span>:</p>
<p><span><em>Данные</em></span>, которые должны прежде всего храниться, а затем, в порядке убывания приоритетов для непосредственной применимости, успешно находиться при нужде, проверяться, поддерживаться в порядке и обновляться при необходимости. Таким образом, они хранятся неизменными, пока не будут явно обновлены, и поэтому обычно внимание уделяют прежде всего сохранению, поддержанию их адекватности меняющемуся состоянию дел и целостности при необходимых изменениях.</p>
<p><span><em>Знания</em></span> должны прежде всего преобразовываться. Далее, их нужно хранить, как и данные, они должны быть доступными, они должны конкретизироваться применительно к данной ситуации и обобщаться для целого класса применений. Они, конечно же, должны при необходимости пересматриваться. И, наконец, они должны переводиться с одного языка на другой.</p>
<p><span><em>Умения</em></span> прежде всего применяются. Помимо этого, они преобразуются для обеспечения гибкости или приспособления к изменившимся условиям. Далее, они обобщаются и пересматриваются.</p>
<p>При исследовании естественных предметных областей данные представляют первичную информацию, получаемую путем обнаружения некоторых объектов и выявления их свойств — измерения значений признаков. Знания — результат переработки данных, их обобщения. Классическим примером данных служат таблицы движения планет по небесному своду Тихо Браге, примером знаний — выведенные из них законы Иоганна Кеплера и затем, как обобщение результатов Кеплера, закон всемирного тяготения Исаака Ньютона.</p>
</section>
</section>
<section id="sec:knowlege_repr" class="level2">
<h2><span class="header-section-number">1.3</span> Формализмы представления знаний</h2>
<p>В интеллектуальных системах (ИС) используются различные способы представления знаний. Наиболее известные из них — это <span><em>логический</em></span>, <span><em>сетевой</em></span>, <span><em>продукционный</em></span> и <span><em>фреймовый</em></span> формализмы<a href="#fn9" class="footnoteRef" id="fnref9"><sup>9</sup></a> (модели) представления знаний.</p>
<section id="логические-модели" class="level3">
<h3><span class="header-section-number">1.3.1</span> Логические модели</h3>
<p>В основе такого типа лежит формальная система, задаваемая четверкой типа <span class="math inline">\(M=\langle T, P, A, B\rangle\)</span> <span class="citation" data-cites="AIDictionary"></span>. Множество <span class="math inline">\(T\)</span> есть множество базовых элементов различной природы, например, слов из некоторого ограниченного словаря, деталей детского конструктора, входящих в состав некоторого набора, и т. п. Важно, что для множества <span class="math inline">\(T\)</span> существует некоторый способ определения принадлежности или непринадлежности произвольного элемента к этому множеству. Процедура такой проверки может быть любой, но за конечное число шагов она должна давать положительный или отрицательный ответ на вопрос, является ли <span class="math inline">\(x\)</span> элементом множества <span class="math inline">\(T\)</span>. Обозначим эту процедуру <span class="math inline">\(\Pi(T)\)</span>.</p>
<p>Множество <span class="math inline">\(P\)</span> есть множество синтаксических правил. С их помощью из элементов <span class="math inline">\(T\)</span> образуют синтаксически правильные совокупности. Например, из слов ограниченного словаря строятся синтаксически правильные фразы, из деталей детского конструктора с помощью гаек и болтов собираются новые конструкции. Декларируется существование процедуры <span class="math inline">\(\Pi(P)\)</span>, с помощью которой за конечное число шагов можно получить ответ на вопрос, является ли совокупность <span class="math inline">\(x\)</span> синтаксически правильной.</p>
<p>Во множестве синтаксически правильных совокупностей выделяется некоторое подмножество <span class="math inline">\(A\)</span>. Элементы <span class="math inline">\(A\)</span> называются аксиомами. Как и для других составляющих формальной системы, должна существовать процедура <span class="math inline">\(\Pi(A)\)</span>, с помощью которой для любой синтаксически правильной совокупности можно получить ответ на вопрос о принадлежности ее к множеству <span class="math inline">\(A\)</span>. Множество <span class="math inline">\(B\)</span> есть множество правил вывода. Применяя их к элементам <span class="math inline">\(A\)</span>, можно получать новые синтаксически правильные совокупности, к которым снова можно применять правила из <span class="math inline">\(B\)</span>. Так формируется множество выводимых в данной формальной системе совокупностей. Если имеется процедура <span class="math inline">\(\Pi(B)\)</span>, с помощью которой можно определить для любой синтаксически правильной совокупности, является ли она выводимой, то соответствующая формальная система является разрешимой. Это показывает, что именно правила вывода являются наиболее сложной составляющей формальной системы.</p>
<p>Для знаний, входящих в базу знаний, можно считать, что множество <span class="math inline">\(A\)</span> образует все информационные единицы, которые введены в базу знаний (БЗ) извне, а с помощью правил вывода из них выводятся новые производные знания. Другими словами, <span><em>формальная система</em></span> представляет собой <span><strong>генератор порождения новых знаний</strong></span>, образующих множество выводимых в данной системе знаний <span class="math inline">\(D\)</span>. Это свойство логических моделей делает их притягательными для использования в базах знаний. Оно позволяет хранить в базе лишь те знания, которые образуют множество <span class="math inline">\(A\)</span>, а все остальные знания из <span class="math inline">\(D\)</span> получать из них по правилам вывода.</p>
<p>Здесь и далее рассмотрим, как можно представить следующий набор высказываний (данных и знаний)<a href="#fn10" class="footnoteRef" id="fnref10"><sup>10</sup></a>: [ex:repr:main]</p>
<ol>
<li><p>Все люди смертны.</p></li>
<li><p>Сократ — человек.</p></li>
</ol>
<p>Для начала введем наш язык (элементы детского конструктора). Пусть <span class="math inline">\(H(x)\)</span> обозначает фразу &lt;&lt;<span class="math inline">\(x\)</span> является человеком&gt;&gt;, а <span class="math inline">\(M(x)\)</span> — &lt;&lt;<span class="math inline">\(x\)</span> — смертен&gt;&gt;. Необходимо заметить, что <span class="math inline">\(x\)</span> как элемент языка представляет объекты предметной области, которыми в нашем случае выступают люди<a href="#fn11" class="footnoteRef" id="fnref11"><sup>11</sup></a>. Можно выделить и отдельные объекты, например Сократа — &lt;&lt;<span class="math inline">\(s\)</span>&gt;&gt;. Теперь позаимствуем еще несколько символов из исчисления предикатов первого порядка, а именно <span class="math inline">\(\forall\)</span>, <span class="math inline">\(\to\)</span>, скобки и др. Теперь первое высказывание представляется как <span class="math display">\[\forall x \left(H(x)\to M(x)\right).\]</span> Это высказывание является <span><em>знанием</em></span>. Второе высказывание — <span class="math display">\[H(s).\]</span> Это — <em>данные</em>, т. е. существует Сократ, который смертен.</p>
</section>
<section id="сетевые-модели" class="level3">
<h3><span class="header-section-number">1.3.2</span> Сетевые модели</h3>
<p>В основе моделей этого типа лежит конструкция, названная ранее семантической сетью. Сетевые модели формально можно записать в виде <span class="math display">\[H=\langle I, C_1, C_2, \ldots, C_n, \Gamma\rangle.\]</span> Здесь <span class="math inline">\(I\)</span> есть множество информационных единиц; <span class="math inline">\(C_1, C_2, \ldots,\)</span> <span class="math inline">\(C_n\)</span> — множество типов связей между информационными единицами. Отображение <span class="math inline">\(\Gamma\)</span> задает между информационными единицами, входящими в <span class="math inline">\(I\)</span>, связи из заданного набора типов связей. В зависимости от типов связей, используемых в модели, различают <span><em>классифицирующие</em></span> и <span><em>функциональные</em></span> сети, а также <span><em>сценарии</em></span> <span class="citation" data-cites="AIDictionary"></span>.=-1</p>
<p>В <span><strong>классифицирующих</strong></span> сетях используются различные отношения структуризации. Такие сети позволяют в базу знаний вводить различные иерархические отношения между информационными единицами. <span><strong>Функциональные</strong></span> сети характеризуются наличием функциональных отношений. Их часто называют вычислительными моделями, так как они позволяют описывать процедуры вычислений одних информационных единиц через другие. В <strong>сценариях</strong> используются казуальные<a href="#fn12" class="footnoteRef" id="fnref12"><sup>12</sup></a> отношения, а также отношения типов &lt;&lt;средство — результат&gt;&gt;, &lt;&lt;орудие — действие&gt;&gt; и т. п.</p>
<p>Если в сетевой модели допускаются связи различного типа, то ее обычно называют <span><em>семантической</em></span> сетью. Примером семантической сети представления знаний является энциклопедический словарь. Такой словарь содержит определения одних понятий через другие. Как правило, в определениях выделяются те базовые определения, которые содержатся в этом словаре.</p>
<p>= [draw, very thick, minimum height=2em, rounded corners=0.6em, minimum width=2em] = [draw, very thick, minimum height=2em, rounded corners=1em, minimum width=2em]</p>
<p>node[abox] (s) <span>Сократ</span>; node[tbox, right of=s] (h) <span>Человек</span> (s) edge node <span>является</span> (h); node[tbox, right of=h, xshift=4em] (m) <span>Смертный</span> (h) edge node <span>обладает свойством</span> (m);</p>
<p>На рис. [pic:repr:semnet] представлен пример [ex:repr:main] в виде семантической сети. В вершинах графа располагаются термины и объекты: &lt;&lt;Человек&gt;&gt;, &lt;&lt;Смертный&gt;&gt;, &lt;&lt;Сократ&gt;&gt;. Дуги графа — это логические связи между терминами и объектами, например, &lt;&lt;являться&gt;&gt; разновидностью (в англоязычной литературе это отношение принято называть &lt;&lt;is_a&gt;&gt;).</p>
</section>
<section id="продукционные-модели" class="level3">
<h3><span class="header-section-number">1.3.3</span> Продукционные модели</h3>
<p>В моделях этого типа используются элементы логических и сетевых моделей. Из логических моделей заимствована <span><strong>идея правил вывода</strong></span>, которые здесь называются <span><em>продукциями</em></span>, а из сетевых моделей — описание знаний в виде формализма семантической сети <span class="citation" data-cites="AIDictionary"></span>.</p>
<p>В результате применения правил вывода к фрагментам сетевого описания происходит трансформация семантической сети за счет смены ее фрагментов, наращивания сети и исключения из нее ненужных фрагментов. Таким образом, в продукционных моделях процедурная информация явно выделена и описывается иными средствами, чем декларативная информация. Вместо логического вывода, характерного для логических моделей, в продукционных моделях появляется вывод на знаниях.</p>
<p>Рассмотрим продукционное представление примера [ex:repr:main]. В виде сети представим второе высказывание — &lt;&lt;Сократ — человек&gt;&gt;, а первое высказывание представим в виде правила преобразования участка сети в другой вид. Правила преобразования можно представлять в виде структур &lt;&lt;Если …, то …&gt;&gt;, т. е., в нашем случае: &lt;&lt;Если <span class="math inline">\(X\)</span> — человек, то <span class="math inline">\(X\)</span> — смертен&gt;&gt;. Полученное представление данных и знаний изображено на рис. [pic:repr:prod].</p>
<p><span>c|c</span> Данные &amp; Знания<br />
&amp;<br />
</p>
<p><span>cc</span></p>
<p>node[abox] (s) <span>Сократ</span>; node[tbox, right of=s] (h) <span>Человек</span> (s) edge node <span>является</span> (h);</p>
<p>&amp;</p>
<p><span>c|l</span></p>
<p>node[tbox] (x1) <span><span class="math inline">\(X\)</span></span>; node[tbox, right of=x1] (h1) <span>Человек</span> (x1) edge node <span>является</span> (h1); node[tbox, below of=x1, yshift=3em] (x2) <span><span class="math inline">\(X\)</span></span> (x1) edge[dashed] node <span>добавить</span> (x2); node[tbox, right of=x2] (m) <span>Смертен</span> (x2) edge node <span>свойство</span> (m);</p>
<p>&amp;</p>
<p>node (if) ; node [below of=if, yshift=3em] (then) ;</p>
</section>
<section id="фреймовые-модели" class="level3">
<h3><span class="header-section-number">1.3.4</span> Фреймовые модели</h3>
<p>В отличие от моделей других типов, во фреймовых моделях фиксируется жесткая структура информационных единиц, которая называется протофреймом<a href="#fn13" class="footnoteRef" id="fnref13"><sup>13</sup></a>. В общем виде она выглядит следующим образом <span class="citation" data-cites="AIDictionary"></span>:</p>
<pre><code>    (Имя фрейма:
        Имя слота 1 (значение слота 1);
        Имя слота 2 (значение слота 2);
        . . . . . . . . . . . . . . . .
        Имя слота K (значение слота K)).</code></pre>
<p>Значением слота может быть практически все, что угодно (числа или математические соотношения, тексты на естественном языке или программы, правила вывода или ссылки на другие слоты данного фрейма или других фреймов). В качестве слота может выступать набор слотов более низкого уровня, что позволяет во фреймовых представлениях реализовать принцип матрешки. При конкретизации<a href="#fn14" class="footnoteRef" id="fnref14"><sup>14</sup></a> фрейма ему и слотам присваиваются конкретные имена и происходит заполнение слотов. Таким образом, из протофреймов получаются фреймы“=экземпляры. Переход от исходного протофрейма к фрейму”=экземпляру может быть многошаговым, за счет постоянного уточнения значений слотов. Например, структура таблицы [tab:frame], записанная в виде протофрейма, имеет вид</p>
<pre><code>    (Список работников:
        Фамилия (значение слота 1);
        Год рождения (значение слота 2);
        Специальность (значение слота 3);
        Стаж (значение слота 4)).</code></pre>
<table>
<caption>Сведения о работниках<span data-label="tab:frame"></span></caption>
<thead>
<tr class="header">
<th style="text-align: left;">Фамилия</th>
<th style="text-align: center;">Год рождения</th>
<th style="text-align: left;">Специальность</th>
<th style="text-align: center;">Стаж (годы)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Попов</td>
<td style="text-align: center;">1965</td>
<td style="text-align: left;">слесарь</td>
<td style="text-align: center;">5</td>
</tr>
<tr class="even">
<td style="text-align: left;">Сидоров</td>
<td style="text-align: center;">1946</td>
<td style="text-align: left;">токарь</td>
<td style="text-align: center;">20</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Иванов</td>
<td style="text-align: center;">1925</td>
<td style="text-align: left;">токарь</td>
<td style="text-align: center;">30</td>
</tr>
<tr class="even">
<td style="text-align: left;">Петров</td>
<td style="text-align: center;">1937</td>
<td style="text-align: left;">сантехник</td>
<td style="text-align: center;">25</td>
</tr>
</tbody>
</table>
<p>Если в качестве значений слотов использовать данные таблицы  [tab:frame], то получится фрейм&quot;=экземпляр</p>
<pre><code> (Список работников:
   Фамилия (Попов-Сидоров-Иванов-Петров);
   Год рождения (1965-1946-1925-1937);
   Специальность (слесарь-токарь-токарь-сантехник);
   Стаж (5-20-30-25)).</code></pre>
<p>Связи между протофреймами задаются значениями специального слота Связь<a href="#fn15" class="footnoteRef" id="fnref15"><sup>15</sup></a>. Часть специалистов ИИ считает, что нет необходимости специально выделять фреймовые модели в представлении знаний, так как в них объединены все основные особенности моделей остальных типов.</p>
<p>Считается, что для представления конкретной системы (набора) знаний всегда можно выбрать из каждого класса приведенных формализмов формальный метод, обладающий достаточной выразительностью языка представления этих знаний<a href="#fn16" class="footnoteRef" id="fnref16"><sup>16</sup></a>. Таким образом, формализмы представления знаний эквивалентны, и, если удалось представить знание в одном из формализмов, то это знание можно представить и в остальных трех.</p>
<p>Перечислите по крайней мере три свойства (признака) задач искусственного интеллекта.</p>
<p>Дайте характеристику терминам &lt;&lt;искусственный интеллект&gt;&gt;, &lt;&lt;данные&gt;&gt; и &lt;&lt;знания&gt;&gt;.</p>
<p>В чем суть теста А. Тьюринга?</p>
<p>Перечислите как минимум пять классов задач искусственного интеллекта.</p>
<p>Какие формализмы представления знаний существуют, чем они отличаются?</p>
</section>
</section>
</section>
<section id="язык-программирования-пролог" class="level1">
<h1><span class="header-section-number">2</span> Язык программирования Пролог</h1>
<p>Предметом нашего дальнейшего изучения будет язык логического программирования Пролог. Слово &lt;&lt;Пролог&gt;&gt; образовано из слияния терминов: &lt;&lt;ПРОграммирование в терминах ЛОГики&gt;&gt;. Пролог относится к классу языков, называемых <span><em>сентенциальными<a href="#fn17" class="footnoteRef" id="fnref17"><sup>17</sup></a></em></span>. Классические реализации Пролога используются в вузах мира для обучения студентов методам автоматизации рассуждений. Специальные версии этого языка, например Prolog-III, являются дорогими коммерческими продуктами. Наибольшее распространение Пролог приобрел в Европе. В Америке активно развивался язык функционального программирования Лисп (от LISt Processing), основанный на <span class="math inline">\(\lambda\)</span>-исчислении Черча. В г.Иркутске в Институте математики, экономики и информатики ИГУ под руководством профессора, доктора физ. мат. наук А. В. Манциводы разработан язык Flang (Functional-logical LANGuage) — язык функционально&quot;=логического программирования, опосредующий свойства языков Пролог и Лисп.</p>
<section id="основные-термины" class="level2">
<h2><span class="header-section-number">2.1</span> Основные термины</h2>
<p>Всякая программа на Прологе состоит из набора фраз (предложений) <span class="citation" data-cites="Bratko"></span>.</p>
<p>Прологовские предложения бывают трех типов: <em>факты, правила</em> и <em>запросы.</em> <em>Факты</em> содержат утверждения, которые считаются всегда безусловно верными. <em>Правила</em> содержат утверждения, истинность которых зависит от некоторых условий. <em>Запросы</em> — цель (условия), которую необходимо выполнить; она, как правило, описывает то, что в конечном счете требуется получить пользователю. С помощью <em>запросов</em> пользователь может спрашивать систему о том, какие утверждения являются истинными.</p>
<p>Предложения Пролога состоят из <em>головы</em> и <em>тела.</em> Тело — это список <em>целей,</em> разделенных запятыми. Запятая понимается как конъюнкция.</p>
<p>Факты — это предложения, имеющие <span><strong>пустое</strong></span> тело. Запросы — только тела правил. Правила имеют голову и (непустое) тело.</p>
<pre><code>    human(socrates).        % факт языка Пролог
    mortal(X) :- human(X).  % правило языка Пролог</code></pre>
<p>Здесь <span>mortal(X)</span> “— <span><em>голова</em></span> правила, а <span>human(X)</span> — <span><em>тело</em></span> правила. В представленной в виде Пролог”=программы системе данных и знаний можно выполнить запрос</p>
<pre><code>    mortal(socrates).       % Сократ смертен?</code></pre>
<p>Каждое предложение заканчивается точкой.</p>
<section id="реализации-языка" class="level3">
<h3><span class="header-section-number">2.1.1</span> Реализации языка</h3>
<p>Большинство классических реализаций Пролога — либо интерпретаторы, либо трансляторы в коды виртуальной машины, например <span><em>машины Уоррена</em></span> (Warren). В данный момент существует множество реализаций Пролога, которые поддерживают компиляцию в машинный код. Из известных реализаций Пролога в интернете доступны GNU-Prolog, Visual Prolog (бывший Turbo Prolog) — компиляторы, SWI-Prolog функционирует на основе виртуальной машины ZIP. Большинство реализаций опираются на стандарт ISO-Prolog, но некоторые, например Visual Prolog, — нет. В данном пособии под ISO-Prolog будем понимать любую реализацию языка Пролог, поддерживающую этот стандарт.</p>
<p>В этом учебном пособии использованы синтаксис и семантика стандарта ISO-Prolog, а реализация — GNU-Prolog<a href="#fn18" class="footnoteRef" id="fnref18"><sup>18</sup></a> <span class="citation" data-cites="GNUP"></span>.</p>
</section>
</section>
<section id="структура-языка" class="level2">
<h2><span class="header-section-number">2.2</span> Структура языка</h2>
<section id="простые-типы-данных" class="level3">
<h3><span class="header-section-number">2.2.1</span> Простые типы данных</h3>
<section id="термы." class="level5">
<h5><span class="header-section-number">2.2.1.0.1</span> Термы.</h5>
<p>Объекты данных в Прологе обозначаются <em>термами</em>. <span><em>Терм</em></span> — это структура, обозначающая некоторый объект <span class="citation" data-cites="DDW"></span>. Терм может быть константой, переменной или составным термом. Составной терм соответствует структурам данных в структурном программировании. Константами являются целые и действительные числа, например:</p>
<pre><code>    0, -l, 123.4, 0.23E-5,</code></pre>
<p>т. е. будем считать, что числа сами себя обозначают.</p>
<p>Большинство реализаций Пролога поддерживают и целые, и действительные числа. Для того чтобы выяснить, каковы диапазоны и точность чисел, следует обратиться к руководству по конкретной реализации.</p>
<p>К термам относятся также <em>символы</em>, такие как:</p>
<pre><code>    goldy, а, atom.</code></pre>
<p><span><em>Символ (symbol)</em></span> есть любая последовательность символов английского алфавита и чисел, начинающаяся с маленькой английской буквы, либо любая строка, взятая в одинарные кавычки, например ’Российская Федерация’.</p>
<p>Как и в других языках программирования, термы обозначают конкретные элементарные объекты моделируемой предметной области, а все другие типы данных в Прологе составлены из сочетаний других термов: чисел и символов.</p>
</section>
<section id="переменные." class="level5">
<h5><span class="header-section-number">2.2.1.0.2</span> Переменные.</h5>
<p>Имена переменных начинаются с заглавных букв английского алфавита или с символа подчеркивания &lt;&lt;<span>_</span>&gt;&gt; и содержат только символы букв, цифр и подчеркивания. Ниже приведены примеры переменных:</p>
<pre><code>    X, Variable, _3, _variable.</code></pre>
<p>Понятие <em>переменной</em> в Прологе отличается от принятого во многих языках программирования. Переменная не рассматривается как выделенный участок памяти. Она служит для обозначения объекта, на который нельзя сослаться по имени. Переменную можно считать <span><strong>локальным<a href="#fn19" class="footnoteRef" id="fnref19"><sup>19</sup></a> именем</strong></span> для некоторого объекта. Переменная также является термом.</p>
<p>Если переменная используется только один раз, необязательно называть ее. Она может быть записана как анонимная переменная, состоящая из одного символа подчеркивания &lt;&lt;<span>_</span>&gt;&gt;. Кроме этого, анонимная переменная обозначает объекты, свойства которых нас не интересуют. Эта переменная может обозначать высказывания &lt;&lt;что-либо&gt;&gt;, &lt;&lt;значение, которое нас не интересует&gt;&gt;, &lt;&lt;все, что угодно&gt;&gt;. Переменные являются элементарными объектами языка Пролог.</p>
</section>
<section id="область-действия-переменных." class="level5">
<h5><span class="header-section-number">2.2.1.0.3</span> Область действия переменных.</h5>
<p>Областью действия переменной является <em>утверждение</em> (факт, правило или запрос). В пределах одного утверждения одно и то же имя принадлежит одной и той же переменной. Два утверждения могут использовать одно имя переменной совершенно различным образом. Правило определения области действия переменной справедливо также в случае рекурсии и в том случае, когда несколько утверждений имеют одну и ту же голову.</p>
<p>Единственным исключением из правила определения области действия переменных является анонимная переменная, например <span>_</span> в факте <span>likes(Х,_).</span> Каждая анонимная переменная есть <span><strong>отдельная сущность</strong></span>. Она применяется тогда, когда конкретное значение переменной несущественно для данного утверждения. Таким образом, каждая анонимная переменная отличается от всех других анонимных переменных в утверждении.</p>
<p>Переменные, отличные от анонимных, называются <span><em>именованными</em></span>, а неконкретизированные (переменные, которым не было присвоено значение) называются <span><em>свободными</em></span>.</p>
</section>
<section id="сложные-термы." class="level5">
<h5><span class="header-section-number">2.2.1.0.4</span> Сложные термы.</h5>
<p>Завершает список синтаксических единиц сложный терм, или структура. Все, что не может быть отнесено к переменной, числу и символу, называется сложным термом. Сложный терм состоит из чисел, символов, переменных и других сложных термов, связанных так называемыми функторами. Пример сложного терма — двоичное дерево:</p>
<pre><code>    t(t(t(nil, t(nil, nil)),nil), t(t(nil,nil),
        t(t(nil,nil),t(nil,nil)))).</code></pre>
</section>
</section>
</section>
<section id="программа-на-языке-пролог" class="level2">
<h2><span class="header-section-number">2.3</span> Программа на языке Пролог</h2>
<p>Программирование на языке Пролог отличается своими особенностями <span class="citation" data-cites="Bratko"></span>:</p>
<ul>
<li><p>Декларативная интерпретация (смысл) программ главенствует над процедурным. При этом программист в качестве программы выписывает <span><strong>то, что он хочет получить</strong></span>, а не <span><strong>то, как это надо получать</strong></span> (вычислять, искать и т. д.).</p></li>
<li><p>Программист осуществляет задание <em>отношений</em>, а не <span>процедур и функций</span>, что является более общим формальным аппаратом представления алгоритмов.</p></li>
</ul>
<section id="утверждения." class="level5">
<h5><span class="header-section-number">2.3.0.0.1</span> Утверждения.</h5>
<p>Программа на языке Пролог есть совокупность <em>утверждений</em>. Утверждения включают цели и хранятся в базе знаний Пролога. Таким образом, база знаний Пролога может рассматриваться как программа на Прологе. В конце утверждения ставится точка &lt;&lt;.&gt;&gt;. Утверждения также называются предложениями или фразами.</p>
<p>Основная операция Пролога — доказательство целей, входящих в утверждение.</p>
<p>Существуют два типа утверждений:</p>
<dl>
<dt>Факт</dt>
<dd><p> — это утверждение, которое безусловно истинно.</p>
</dd>
<dt>Правило</dt>
<dd><p>состоит из головы и одной или более хвостовых подцелей, которые истинны при некоторых условиях.</p>
</dd>
</dl>
<p>Правило обычно имеет несколько хвостовых подцелей в форме конъюнкции. Конъюнкцию можно рассматривать как логическую функцию &lt;&lt;&amp;&gt;&gt;. Таким образом, правило истинно, если истинны все его хвостовые подцели.</p>
<p>Примеры фактов:</p>
<pre><code>    dog(rex).           % rex - собака.
    parent(goldy, rex). % rex - родитель goldy.</code></pre>
<p>Примеры правил:</p>
<pre><code>    dog(X) :- parent (X, Y), dog(Y).
        % Всякий, у которого родитель - собака,
        %   тоже является собакой.
    human(Х) :- man(Х).
    human(Х) :- woman(Х).
        % Человек - это мужчина или женщина.</code></pre>
<p>Символом &lt;&lt;<span>:-</span>&gt;&gt; обозначена логическая связка &lt;&lt;<span class="math inline">\(\leftarrow\)</span>&gt;&gt; (если), а символом &lt;&lt;<span>,</span>&gt;&gt; — логическая операция конъюнкция &lt;&lt;<span class="math inline">\(\&amp;\)</span>&gt;&gt;. Прибегая к помощи исчисления предикатов первого порядка, первое правило можно переписать так: <span class="math display">\[\forall x \forall y (parent(x, y) \,{}\&amp;\,{} dog(y) \to dog(y)).\]</span> Напоминаем, что правила состоят из <span><em>заголовка</em></span> и <span><em>тела</em></span>. Например, <span>dog(X)</span> и <span>human(X)</span> — заголовки правил, а <span>man(X)</span> и <span>woman(X)</span> — части тел правил (подцели).</p>
<p>Введем еще один термин — <span><em>предикат<a href="#fn20" class="footnoteRef" id="fnref20"><sup>20</sup></a>.</em></span> Суть этого слова следующая: несколько объектов связаны некоторым свойством. Например, <span>parent(X, Y)</span> связывает некоторый объект <span>X</span> с некоторым объектом <span>Y</span> свойством &lt;&lt;быть родителем&gt;&gt;. Факты и заголовки правил и назовем предикатами. Предикаты различаются между собой названием (идентификатором) и количеством аргументов, т. е. предикат <span>parent(X, Y)</span> обозначается выражением <span>parent/2</span>.</p>
<p>Разница между правилами и фактами чисто семантическая. Так, факты, приведенные выше, записываются в виде правил следующим образом:</p>
<pre><code>   dog(rex) :- true.            % dog(rex).
   parent(goldy, rex) :- true.  % parent(goldy, rex).</code></pre>
<p>Теперь рассмотрим нашу первую программу на языке ISO-Prolog.</p>
<pre><code>   dog(rex).           % rex - собака.
   dog(X) :- parent(X, Y), dog (Y).
   % Всякий, у которого родитель - собака,
   %   тоже является собакой.

   parent(goldy, rex). % rex - родитель goldy.

   human(Х) :- man(Х).
   human(Х) :- woman(Х).
   % Человек - это мужчина или женщина.</code></pre>
<p>Предикаты с одинаковым именем в большинстве версий Пролога должны быть сгруппированы, т. е. не разрешается, например, вставлять между фактом <span>dog(rex)</span> и правилом <span>dog(X) :- parent(X, Y), dog(Y)</span> другие предикаты (факты и правила), например, <span>human/2</span>. Имена предикатов пишутся с маленькой латинской буквы, некоторые версии поддерживают русские имена идентификаторов (в кодировке UTF-8). Некоторые версии ISO-Prolog, например GNU-Prolog, неадекватно реагируют на пробел между именем предиката и открывающей скобкой. Встроенный предикат <span>true/0</span> обозначает тождественно&quot;=истинное высказывание, он не связывает никакие объекты.</p>
<p>В синтаксисе языка Пролог помимо связки &lt;&lt;<span>,</span>&gt;&gt; (&lt;&lt;и&gt;&gt;), есть еще связка &lt;&lt;<span>;</span>&gt;&gt; (&lt;&lt;или&gt;&gt;), с помощью которой последнее правило <span>human/1</span> можно переписать в следующем виде:</p>
<pre><code>   human(Х) :- man(Х) ; woman(Х).
      % Человек - это мужчина или женщина.</code></pre>
</section>
<section id="типы-данных-языка-пролог." class="level5">
<h5><span class="header-section-number">2.3.0.0.2</span> Типы данных языка Пролог.</h5>
<p>Простые типы данных в языке Пролог представлены следующими идентификаторами:</p>
<dl>
<dt>Symbol</dt>
<dd><p> — тип, обозначающий &lt;&lt;символы&gt;&gt;, т. е. имена (названия, обозначения) объектов (понятий). Например, нашего Сократа можно обозначить символом <span>socrates</span><a href="#fn21" class="footnoteRef" id="fnref21"><sup>21</sup></a> или в виде строки в одинарных кавычках <span><code>'Сократ'</code></span>. Символы — это специальные структуры, похожие на строки, которым сопоставляется некое индивидуальное число из таблицы символов Пролога. В процессе решения задачи Пролог оперирует не строками, а этими числами. В стандартной библиотеке ISO-Prolog есть различные средства для манипуляции символами как строками (сложение, поиск подстроки и т. п.), при этом для каждого нового символа создается свое число в таблице символов.</p>
</dd>
<dt>Char</dt>
<dd><p> — тип, обозначающий индивидуальные символы ASCII, например <span>’A’</span>. Этот тип ничем не отличается от Symbol.</p>
</dd>
<dt>String</dt>
<dd><p> — последовательность символов (русских, английских и др.), заключенная в двойные кавычки (как в языке C, С++) &lt;&lt;<span><code>&quot;</code></span>&gt;&gt;. В ISO-Prolog строками являются списки символов&quot;=букв. К строкам применимы все операции со списками (см. ниже). В данном учебном пособии мы не будем использовать строки.</p>
</dd>
<dt>Integer</dt>
<dd><p> — типы данных, обозначающие целые величины.</p>
</dd>
<dt>Float</dt>
<dd><p> — тип данных, обозначающие рациональные величины в виде чисел с плавающей точкой.</p>
</dd>
</dl>
<p>В стандарте ISO-Prolog данные обозначения типов используются только для документирования прикладного пользовательского интерфейса библиотек<a href="#fn22" class="footnoteRef" id="fnref22"><sup>22</sup></a>. В системе Visual-Prolog интерфейсы предикатов задаются в специальных секциях в явном виде.</p>
</section>
<section id="sec:complex_data" class="level5">
<h5><span class="header-section-number">2.3.0.0.3</span> Сложные типы данных.</h5>
<p>Сложные типы данных (структуры) в Прологе создаются с помощью так называемых <span><em>функторов</em></span>. Функтор — это терм, состоящий из простых типов данных и других функторов. Например, конкретное двоичное дерево, состоящее из четырех вершин, задается так:</p>
<pre><code>  t(t(nil,5,nil), 10, t(t(nil,15,nil),20, nil)).</code></pre>
<p>Здесь <code>nil</code><a href="#fn23" class="footnoteRef" id="fnref23"><sup>23</sup></a> — символ, использованный нами для обозначения пустого поддерева, <code>t/3</code> — трехаргументный функтор (точнее, функциональный символ), объединяющий три более простых терма в одну структуру (терм) <code>t(&lt;левое поддерево&gt;, &lt;данные&gt;, &lt;правое поддерево&gt;)</code>. Второй аргумент в нашем примере <code>t/3</code> — число, которое хранится в дереве.</p>
<p>Поиск в двоичном дереве, используя полный перебор его вершин. [ex:treesearch]</p>
<pre><code>    % search(tree, integer).
    % истинный, если второй аргумент
    % находится в дереве (первый аргумент).
    search( t( _, X, _), X).
    % В вершине найдено требуемое число.
    search( t( L, Y, _), X) :- Y &lt;&gt; X,
       % Если требуемого числа здесь нет
       search( L, X).
       % то попробовать найти его в левом
       % поддереве.
    search( t( _, Y, R), X) :- Y &lt;&gt; X,
       % Если требуемого числа здесь нет
       search( R, X).
       % то попробовать найти его в правом
       % поддереве.</code></pre>
<p>Эта программа может выполнить, например, такой запрос:</p>
<pre><code>    search( t( t(nil, 5, nil), 0,
        t(nil, 8, t(nil, 10, nil))), 10).</code></pre>
</section>
<section id="запросы." class="level5">
<h5><span class="header-section-number">2.3.0.0.4</span> Запросы.</h5>
<p>После записи утверждений в базу знаний вычисления (логический вывод целевого утверждения, цели) инициируется вводом <em>запроса</em>.</p>
<p>Запрос выглядит так же, как хвост правила, образуется и обрабатывается по тем же правилам, но его ввод производится после загрузки файла с программой в среду выполнения. Запрос состоит из ряда хвостовых целевых утверждений, записываемых, чаще всего, в виде конъюнкции. Приведем примеры запросов:</p>
<pre><code>   parent(X, Y), dog(Y).</code></pre>
<p>или</p>
<pre><code>   dog(goldy).</code></pre>
<p>В большинстве Пролог&quot;=систем запросы вводятся в специальной командной строке рядом с приглашением &lt;&lt;<code>?-</code>&gt;&gt;, вместо вертикальной черты может быть число — номер запроса. Например, представленные выше запросы вводятся в систему GNU-Prolog следующим образом:</p>
<pre><code>?- parent(X, Y), dog(Y).</code></pre>
<p>или</p>
<pre><code>?- dog(goldy).</code></pre>
<p>Далее мы будем обозначать выполняемые вручную запросы при помощи именно такой записи, если не оговорено особо.</p>
<pre><code>?- dog(goldy).</code></pre>
<p>Если необходимо инициировать запрос при загрузке базы знаний (программы), то согласно стандарту ISO надо использовать предикат <code>initialization/1</code>.</p>
<pre><code>:- initialization(dog(goldy)).</code></pre>
<p>Этот запрос выполнится во время загрузки программы. Аналогично выполняются запросы на выполнение различных директив. Для этого используется следующая декларация:</p>
<pre><code>:- dynamic(fib/2).</code></pre>
<p>Конкретно в этом случае происходит запуск директивы транслятора, которая сообщает системе, что предикат <code>fib/2</code> будет динамическим, т. е. новые экземпляры <code>fib/2</code> можно будет добавлять в рабочую память Пролога. Запросы, включающие предикаты пользователя как подцели, в некоторых системах также можно запускать при помощи этой конструкции<a href="#fn24" class="footnoteRef" id="fnref24"><sup>24</sup></a>.</p>
</section>
<section id="загрузка-программы." class="level5">
<h5><span class="header-section-number">2.3.0.0.5</span> Загрузка программы.</h5>
<p>Редактирование программ Пролога возможно в Windows&quot;=версии системы GNU-Prolog во встроенном редакторе. Разумеется, программист может использовать свой любимый текстовый редактор, а затем просто загрузить программу в интерпретатор Пролога.</p>
<p>В классических реализациях языка Пролог введение списка утверждений в Пролог&quot;=систему осуществляется при помощи встроенного предиката <span>consult/1</span>. Единственным аргументом этого предиката <span>consult/1</span> является атом, который интерпретируется системой как имя файла, содержащего текст программы на Прологе. Файл открывается, и его содержимое записывается<a href="#fn25" class="footnoteRef" id="fnref25"><sup>25</sup></a> в базу знаний. Если в файле встречаются управляющие команды, они сразу же выполняются. Возможен случай, когда файл не содержит ничего, кроме управляющих команд, например, для загрузки других файлов. Для ускорения набора команды загрузки пользователи Пролога изобрели для себя следующую конструкцию, являющуюся синонимом предикату <span>consult/1</span>:</p>
<pre><code>?- [&#39;&lt;имя файла&gt;&#39;].</code></pre>
<p>В Прологе имеются и другие методы добавления и удаления утверждений из базы данных. Некоторые реализации языка поддерживают модульную структуру, позволяющую разрабатывать модульные программы.</p>
<p>В заключение раздела дадим формальное определение основной части синтаксиса Пролога, используя форму записи Бэкуса—Наура, называемую бэкусовской нормальной формой.</p>
<pre><code>&lt;запрос&gt; ::- &lt;хвост утверждения&gt;
&lt;правило&gt; ::- &lt;голова утверждения&gt; &quot;:-&quot;
   &lt;хвост утверждения&gt;
&lt;факт&gt; ::- &lt;предикат&gt; &quot;.&quot;
&lt;голова утверждения&gt; ::- &lt;предикат&gt;
&lt;предикат&gt; ::- &lt;идентификатор&gt; [ &quot;(&quot; &lt;термы&gt; &quot;)&quot; ]
&lt;предикаты&gt; ::- &lt;предикат&gt; [ &quot;,&quot; &lt;предикаты&gt; ]
&lt;хвост утверждения&gt; ::- &lt;предикаты&gt; [ &quot;;&quot;
   &lt;предикаты&gt; ] &quot;.&quot;
&lt;термы&gt; ::- &lt;терм&gt; [ &quot;,&quot; &lt;термы&gt; ]
&lt;терм&gt; ::- &lt;число&gt; | &lt;переменная&gt; | &lt;строка&gt; |
   &lt;символ&gt; | &lt;функтор&gt;
&lt;функтор&gt; ::- &lt;идентификатор&gt; [ &quot;(&quot; &lt;термы&gt; &quot;)&quot; ]</code></pre>
<p>Знак &lt;&lt;<span>::=</span>&gt;&gt; здесь читается как &lt;&lt;состоит из&gt;&gt;. Данное определение синтаксиса не включает операторную, списковую и строковую формы записи классического Пролога. Однако любая программа на Прологе может быть написана с использованием вышеприведенного синтаксиса. Специальные формы только упрощают понимание программы. Как мы видим, синтаксис Пролога не требует пространного объяснения. Но для проектирования и реализации хороших программ необходимо глубокое понимание языка.</p>
</section>
</section>
<section id="унификация-и-мэтчинг" class="level2">
<h2><span class="header-section-number">2.4</span> Унификация и мэтчинг</h2>
<p>Одним из наиболее важных аспектов программирования на Прологе являются понятия унификации, мэтчинга и конкретизации переменных.</p>
<p>Пролог пытается отождествить термы при доказательстве (согласовании) целевого утверждения. Например, для согласования запроса <span>dog(X)</span> цель <span>dog(X)</span> будет унифицирована с фактом <span>dog(rex)</span>, в результате чего переменная <span>Х</span> станет конкретизированной: <span>Х = rex</span>.</p>
<p>Унификация<a href="#fn26" class="footnoteRef" id="fnref26"><sup>26</sup></a> — это процесс, на вход которого поступают два терма <span class="math inline">\(t_1\)</span> и <span class="math inline">\(t_2\)</span>. Процесс унификации анализирует структуры этих термов и ищет их схожие элементы. Конечная цель унификации — найти множество подстановок структур (термов) в переменные, найденные в <span class="math inline">\(t_1\)</span> и <span class="math inline">\(t_2\)</span>. Подстановки должны быть такие, что, заменяя все переменные в <span class="math inline">\(t_1\)</span> и <span class="math inline">\(t_2\)</span> на структуры из этой подстановки, <span class="math inline">\(t_1\)</span> и <span class="math inline">\(t_2\)</span> превращаются в одинаковые структуры. Если удается построить такое множество, то считается, что унификация прошла успешно. Собственно, в результате унификации прологовские переменные и получают свои значения. Пример унификации арифметических выражений показан на рис. [pic:unification]. На этом рисунке <span class="math inline">\(\Theta\)</span> — множество подстановок (первый аргумент — переменная, в который подставляется терм — второй аргумент). Выражение <span class="math inline">\(X\Theta\)</span> — результат применения (application) подстановки <span class="math inline">\(\Theta\)</span> в выражение <span class="math inline">\(X\)</span>.</p>
<figure>
<embed src="pics/unification.eps" /><figcaption>Унификация двух арифметических выражений<span data-label="pic:unification"></span></figcaption>
</figure>
<p>Рассмотрим правила унификации более подробно. Терм <span>X</span> унифицируется с термом <span>Y</span> по следующим правилам. Если <span>Х</span> и <span>Y</span> — символы или числа, то они унифицируемы, только если они одинаковы. Если <span>Х</span> является константой или структурой, а <span>Y</span> — неконкретизированной переменной, то <span>Х</span> и <span>Y</span> унифицируемы и <span>Y</span> принимает значение <span>Х</span> (и наоборот). Если <span>Х</span> и <span>Y</span> — структуры, то они унифицируемы тогда и только тогда, когда у них один и тот же главный функтор и арность и каждая из их соответствующих компонент сопоставима. Если <span>Х</span> и <span>Y</span> — неконкретизированные (свободные) переменные, то они сопоставимы, в этом случае говорят, что они сцеплены. В таблице [tab:unif] приведены примеры унифицируемых и неунифицируемых термов.</p>
<p>Следует сказать, что в большинстве реализаций Пролога для повышения эффективности его работы допускается существование циклических унификаторов<a href="#fn27" class="footnoteRef" id="fnref27"><sup>27</sup></a>. Например, попытка унифицировать термы <span>f(X)</span> и <span>Х</span> приведет к циклической подстановке <span>X = f(X)</span>, который определяет бесконечно&quot;=вложенный терм <span>f(f(f(...)))</span>, что еще и логически некорректно. Иногда такую неполную унификацию называют мэтчинг (matching).</p>
<table>
<caption>Иллюстрация унификации<span data-label="tab:unif"></span></caption>
<thead>
<tr class="header">
<th style="text-align: left;"><span>Терм<span class="math inline">\({}_1\)</span></span></th>
<th style="text-align: left;"><span>Терм<span class="math inline">\({}_2\)</span></span></th>
<th style="text-align: left;"><span>Унифицируемы?</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">jack(Х)</td>
<td style="text-align: left;">jack(human)</td>
<td style="text-align: left;"><span>да:</span> Х=human</td>
</tr>
<tr class="even">
<td style="text-align: left;">jack(person)</td>
<td style="text-align: left;">jack(human)</td>
<td style="text-align: left;"><span>нет</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">jack(Х, Х)</td>
<td style="text-align: left;">jack(23, 23)</td>
<td style="text-align: left;"><span>да:</span> Х=23</td>
</tr>
<tr class="even">
<td style="text-align: left;">jack(Х, Х)</td>
<td style="text-align: left;">jack(12, 23)</td>
<td style="text-align: left;"><span>нет</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">jack(_, _)</td>
<td style="text-align: left;">jack(12, 23)</td>
<td style="text-align: left;"><span>да</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">f(Y, Z)</td>
<td style="text-align: left;">X</td>
<td style="text-align: left;"><span>да:</span> X = f(Y, Z)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">X</td>
<td style="text-align: left;">Z</td>
<td style="text-align: left;"><span>да:</span> X = Z</td>
</tr>
</tbody>
</table>
<p>Возможность унификации (мэтчинга) двух термов проверяется с помощью оператора &lt;&lt;<span>=</span>&gt;&gt;.</p>
<p>Ответом на запрос</p>
<pre><code>?- 3 + 2 = 5</code></pre>
<p>в ISO-Prolog будет <span>нет</span>, так как термы неунифицируемы (в ISO-Prolog оператор &lt;&lt;<span>=</span>&gt;&gt; не вычисляет значения своих аргументов). ISO-Prolog воспринимает арифметические операции как функторы, а арифметические выражения — как сложные структуры; для вычисления арифметических выражений используется специальный предикат &lt;&lt;<span>is</span>&gt;&gt;. Унификация часто используется для доступа к подкомпонентам термов. Так, например, если нам требуется выбрать правое поддерево (см. пример [ex:treesearch]), можно провести следующую унификацию (<span>T</span> — исходное дерево, <span>ST</span> — поддерево).</p>
<pre><code>  T=t( t( nil, 7, nil), 5, t( t(nil, 10, nil), 8,
      nil)),
  ( _, _, ST) = T
      % теперь ST = t( t(nil, 10, nil), 8, nil).</code></pre>
<p>Отрицание оператора &lt;&lt;<span>=</span>&gt;&gt; записывается как &lt;&lt;<span><code>\=</code></span>&gt;&gt; или &lt;&lt;<span><code>\+</code> (_ = _)</span>&gt;&gt;.</p>
</section>
<section id="лабораторная-работа-1-факты-и-правила" class="level2">
<h2><span class="header-section-number">2.5</span> Лабораторная работа 1: Факты и правила</h2>
<p>Формализация высказываний естественного языка в виде Пролог&quot;=программы.</p>
<section id="задание." class="level5">
<h5><span class="header-section-number">2.5.0.0.1</span> Задание.</h5>
<p>В pаботе<a href="#fn28" class="footnoteRef" id="fnref28"><sup>28</sup></a> тpебуется формализовать высказывания в виде программы на языке Пpолог. В программе требуется выполнить ряд запросов, объяснить выдаваемые Пролог&quot;=системой результаты.</p>
</section>
<section id="цель-работы." class="level5">
<h5><span class="header-section-number">2.5.0.0.2</span> Цель работы.</h5>
<p>Приобрести навыки формализации высказываний на естественном языке в виде фактов, правил и запросов языка Пролог.</p>
</section>
<section id="время-работы." class="level5">
<h5><span class="header-section-number">2.5.0.0.3</span> Время работы.</h5>
<p>На выполнение работы отводится два академических часа.</p>
</section>
<section id="индивидуальные-задания" class="level5">
<h5><span class="header-section-number">2.5.0.0.4</span> Индивидуальные задания</h5>
<ol>
<li><p>Флэш — собака. Pовеp — собака. Бутси — кошка. Стаp — лошадь. Флэш чеpная. Бутси коpичневая. Pевеp pыжая. Стаp белая. Домашнее животное — собака или кошка. Животное — домашнее животное или лошадь. У Тома есть собака не чеpного цвета. У Кейта есть лошадь или что-то чеpного цвета.<br />
<strong>Запросы</strong>:</p>
<ul>
<li><p>Pовеp рыжая?</p></li>
<li><p>Опpеделить клички всех собак.</p></li>
<li><p>Опpеделить владельцев чего-либо.</p></li>
<li><p>Опpеделить владельцев животных небелого цвета.</p></li>
</ul></li>
<li><p>Бутси — коpичневая кошка. Коpни — чеpная кошка. Мактэвити — pыжая кошка. Флэш, Pовеp и Спот — собаки; Pовеp — pыжая, а Спот — белая. Все животные, котоpыми владеют Том и Кейт, имеют pодословные. Том владеет всеми чеpными и коpичневыми животными. Кейт владеет всеми собаками небелого цвета, котоpые не являются собственностью Тома.</p>
<p>Алан владеет Мактэвити, если Кейт не владеет Бутси и если Спот не имеет pодословной. Флэш — пятнистая собака.<br />
<strong>Запросы</strong>:</p>
<ul>
<li><p>Какие животные не имеют хозяев?</p></li>
<li><p>Найдите всех собак и укажите их цвет.</p></li>
<li><p>Укажите всех животных, котоpыми владеет Том.</p></li>
<li><p>Пеpечислите всех собак Кейта.</p></li>
</ul></li>
<li><p>Опpеделить следующие отношения: СЫH, ДОЧЬ, ОТЕЦ, МАТЬ, МУЖЧИHА и ЖЕHЩИHА. Описать факты для некотоpых из них.<br />
<strong>Запросы</strong>:</p>
<ul>
<li><p>Опpеделить всех сыновей опpеделенной матеpи.</p></li>
<li><p>Опpеделить всех детей опpеделенной паpы pодителей.</p></li>
<li><p>Опpеделить pодителей опpеделенного человека.</p></li>
<li><p>Является ли опpеделенный человек женщиной?</p></li>
</ul></li>
<li><p>Мэpи любит пеpсики. Мэpи любит кукуpузу. Мэpи любит яблоки. Бет любит то, что любит Мэpи, если это — фpукт и если он кpасный. Бет любит то, что любит Мэpи, если это кукуpуза. Пеpсики — фpукт. Яблоки — фрукт. Цвет пеpсиков желтый. Цвет апельсинов оpанжевый. Цвет яблок кpасный. Цвет яблок желтый.<br />
<strong>Запросы</strong>:</p>
<ul>
<li><p>Что любит Бет?</p></li>
<li><p>Любит ли Мэpи кукуpузу?</p></li>
<li><p>Какие фpукты известны?</p></li>
<li><p>Какого цвета фpукты, котоpые любят Бет и Мэpи?</p></li>
</ul></li>
<li><p>Задано деpево pодственных связей.</p>
<p><embed src="pics/task_relatives.eps" /></p>
<p>Кpоме того, опpеделить отношения ПОЛ, PЕБЕHОК, PОДИТЕЛЬ_PОДИТЕЛЯ, ПРЕДОК и МАТЬ.<br />
<strong>Запросы</strong>:</p>
<ul>
<li><p>Кто pодитель Pat?</p></li>
<li><p>Есть ли у Lis pебенок?</p></li>
<li><p>Кто потомки Pat?</p></li>
<li><p>Является ли Pam матеpью Bob?</p></li>
</ul></li>
<li><p>Медведь большой. Слон большой. Кот маленький. Медведь коpичневый. Кот чеpный. Слон серый.</p>
<p>Любой черный или коричневый пpедмет является темным.<br />
<strong>Запросы</strong>:</p>
<ul>
<li><p>Кто одновpеменно большой и темный?</p></li>
<li><p>Есть ли коpичневые маленькие слоны?</p></li>
<li><p>Есть ли большие и темные медведи?</p></li>
<li><p>Есть ли чеpный кот?</p></li>
</ul></li>
<li><p>Мэpи, Сьюзи и Джейн pаботают в дневную смену. Сэм, Джейн, Боб и Патpиция pаботают в вечеpнюю смену. Знают дpуг дpуга те, кто pаботает в одну смену.<br />
<strong>Запросы</strong>:</p>
<ul>
<li><p>Знают ли дpуг дpуга Мэpи и Джейн?</p></li>
<li><p>Кто pаботает в дневную смену?</p></li>
<li><p>Есть ли кто-то, кто pаботает в обе смены?</p></li>
<li><p>Есть ли кто-то, кто не знает дpуг друга?</p></li>
</ul></li>
<li><p>Можно совеpшить путешествия, перечисленные в таблице [tbl:schedule]. Любые две тpанспоpтные компании являются конкуpентами, если они обслуживают один и тот же маршрут. Можно путешествовать из одного гоpода в дpугой, если можно добраться из одного гоpода в дpугой чеpез пpомежуточный город. <strong>Запросы</strong>:</p>
<ul>
<li><p>Являются ли Амтpак и Пиплз конкуpентами?</p></li>
<li><p>Какие компании дают возможность путешествовать из Hью-Йоpка в Вашингтон?</p></li>
<li><p>Можно ли путешествовать из Биpлингтона в Поpтленд?</p></li>
<li><p>Опpеделить всех конкуpентов.</p></li>
</ul>
<table>
<caption>Расписание рейсов<span data-label="tbl:schedule"></span></caption>
<thead>
<tr class="header">
<th style="text-align: left;">Компания</th>
<th style="text-align: left;">Из</th>
<th style="text-align: left;">В</th>
<th style="text-align: left;">Вид транспорта</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Амтpак</td>
<td style="text-align: left;">Hью-Йоpк</td>
<td style="text-align: left;">Бостон</td>
<td style="text-align: left;">Ж/д</td>
</tr>
<tr class="even">
<td style="text-align: left;">Тpанзит</td>
<td style="text-align: left;">Hью-Йоpк</td>
<td style="text-align: left;">Пpинстон</td>
<td style="text-align: left;">Ж/д</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Амтpак</td>
<td style="text-align: left;">Бостон</td>
<td style="text-align: left;">Поpтленд</td>
<td style="text-align: left;">Ж/д</td>
</tr>
<tr class="even">
<td style="text-align: left;">Гpейхаунд</td>
<td style="text-align: left;">Бостон</td>
<td style="text-align: left;">Поpтленд</td>
<td style="text-align: left;">Автобус</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Амтpак</td>
<td style="text-align: left;">Hью-Йоpк</td>
<td style="text-align: left;">Вашингтон</td>
<td style="text-align: left;">Ж/д</td>
</tr>
<tr class="even">
<td style="text-align: left;">Пиплз</td>
<td style="text-align: left;">Hью-Йоpк</td>
<td style="text-align: left;">Вашингтон</td>
<td style="text-align: left;">Самолет</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Пиплз</td>
<td style="text-align: left;">Биpлингтон</td>
<td style="text-align: left;">Hью-Йоpк</td>
<td style="text-align: left;">Самолет</td>
</tr>
</tbody>
</table></li>
<li><p>Опpеделить факты о пpинадлежности студента опpеделенной студенческой гpуппе. Считается, что два студента знают дpуг дpуга, если они учатся в одной группе.<br />
<strong>Запросы</strong>:</p>
<ul>
<li><p>Кого знает опpеделенный студент?</p></li>
<li><p>Опpеделить состав опpеделенной гpуппы.</p></li>
<li><p>В каких гpуппах учатся люди с опpеделенным именем?</p></li>
<li><p>Знает ли один студент другого?</p></li>
</ul></li>
<li><p>Заданы факты о маpшpутах движения автобусов между двумя pазными гоpодами, в котоpых указаны: номеp маpшpута, названия двух гоpодов, день и вpемя отпpавления и пpибытия. Известны также фамилии водителей, pаботающих на опpеделенных маpшpутах. Можно попасть из одного гоpода в дpугой, если существуют автобусные маpшpуты из пеpвого гоpода во втоpой или из пеpвого гоpода в пpомежуточный, и из пpомежуточного во втоpой. <strong>Запросы</strong>:</p>
<ul>
<li><p>Можно ли пpоехать из одного гоpода в дpугой?</p></li>
<li><p>Указать автобусы, выходящие из опpеделенного гоpода в опpеделенный день, и вpемя отпpавления.</p></li>
<li><p>Пеpечислить фамилии водителей опpеделенного маpшpута.</p></li>
<li><p>Указать дни и часы отпpавления опpеделенного маpшpута.</p></li>
</ul></li>
<li><p>Есть факты об отцах некотоpых людей и о бpатьях некотоpых людей. Опpеделить отношение ДЯДЯ.<br />
<strong>Запросы</strong>:</p>
<ul>
<li><p>Опpеделить бpатьев конкpетного человека.</p></li>
<li><p>Кто является отцом конкретного лица?</p></li>
<li><p>Связаны ли два человека отношением ОТЕЦ?</p></li>
<li><p>Опpеделить, является ли один человек дядей другого.</p></li>
</ul></li>
<li><p>Опpеделить отношения PОДИТЕЛЬ, ЖЕHЩИHА как набоp фактов, пpавило PАЗЛИЧHЫ, СЕСТPА (опpеделяемое чеpез PОДИТЕЛЬ, ЖЕНЩИНА и PАЗЛИЧHЫ) и ТЕТЯ (опpеделяемое чеpез PОДИТЕЛЬ и СЕСТРА).<br />
<strong>Запросы</strong>:</p>
<ul>
<li><p>Кто является pодителями опpеделенного человека?</p></li>
<li><p>Опpеделить всех детей опpеделенных pодителей.</p></li>
<li><p>Опpеделить, есть ли сестpы у опpеделенного человека.</p></li>
<li><p>Опpеделить, есть ли тетя у опpеделенного человека.</p></li>
</ul></li>
</ol>
</section>
<section id="методические-указания-к-лабораторной-работе" class="level4 unnumbered">
<h4>Методические указания к лабораторной работе</h4>
<p>Процесс построения некоторого формального представления высказываний естественного языка называется <span><em>формализацией</em></span>. Что это такое? Ответ на этот вопрос столь сложен, сколь сложен ответ на вопрос: Что такое модель? В научных кругах под формализацией понимается словосочетание &lt;&lt;дружеский шарж&gt;&gt;, т. е. формальное представление некоторого естественного объекта (например, высказывания) — это дружеский шарж.</p>
<p>Продемонстрируем на примерах, почему формализация — это именно <span><strong>шарж</strong></span>. Пусть дано высказывание: &lt;&lt;Лена любит кататься на велосипеде и на горных лыжах&gt;&gt;. Какая логическая связка будет соответствовать союзу &lt;&lt;и&gt;&gt;?…На самом деле это будет связка &lt;&lt;<span class="math inline">\(\vee\)</span>&gt;&gt;, потому, что с формально&quot;=логической точки зрения высказывание обозначает: &lt;&lt;Лена катается на велосипеде <span><strong>или</strong></span> горных лыжах&gt;&gt;. Второй пример: &lt;&lt;Я пойду домой, а моя жена на работу&gt;&gt;. Здесь союз &lt;&lt;а&gt;&gt; по смыслу соответствует логической связке &lt;&lt;&amp;&gt;&gt;. Таким образом, формализация естественного текста не может быть сделана &lt;&lt;в лоб&gt;&gt;, необходимо понять, что было сказано.</p>
<p>При выполнении лабораторной работы следует придерживаться следующих общих правил:</p>
<ol>
<li><p>Прочитать весь текст высказывания и определить, что будет <span><strong>объектами</strong></span>, а что <span><strong>свойствами</strong></span>, связывающими эти объекты. Например, пусть даны следующие высказывания: &lt;&lt;Аня любит Колю. Коля любит Лену. А Лена смотрит в светлое будущее.&gt;&gt; Тогда, объектами будут: Аня, Коля, Лена и &lt;&lt;светлое будущее&gt;&gt;, а свойствами — отношения &lt;&lt;любит&gt;&gt; и &lt;&lt;смотреть в&gt;&gt;, которые связывают два объекта (&lt;&lt;Кто&gt;&gt; &lt;&lt;любит&gt;&gt; &lt;&lt;Что&gt;&gt;, &lt;&lt;Кто&gt;&gt; &lt;&lt;смотрит в&gt;&gt; &lt;&lt;Что&gt;&gt;).</p></li>
<li><p>Свойства объектов могут быть заданы перечислением либо через другие известные свойства. В нашем примере свойство &lt;&lt;любит&gt;&gt; задается перечислением:</p>
<pre><code> be_in_love(ann, niko).
 be_in_love(niko, helen).</code></pre>
<p>Но высказывание, вроде &lt;&lt;любовного треугольника&gt;&gt;, можно задать через <span>be_in_love/2</span>:</p>
<pre><code> love_triangle(X, Y, Z) :- % любовный треугольник
    be_in_love(X, Y),   % первого рода, когда
    be_in_love(Z, Y).   % двое любят одного.
 love_triangle(X, Y, Z) :- % любовный треугольник
    be_in_love(X, Y),   % второго рода - без-
    be_in_love(Y, Z).   % ответная любовь.</code></pre></li>
</ol>
<p>Признаком хорошей формализации (дружественности шаржа) является, как и везде в программировании, хорошая гибкость и интерпретируемость программы: более сложные отношения формулируются через более простые; свойства в достаточной мере абстрактны.</p>
<p>Какие структурные единицы формируют программу на языке Пролог?</p>
<p>Перечислите простые структуры данных Пролога.</p>
<p>Что такое &lt;&lt;терм&gt;&gt;, в чем отличие переменной от символа?</p>
<p>Приведите пример унификации двух структур, представляющих логические выражения.</p>
<p>Какова будет унифицирующая подстановка <span class="math inline">\(\Theta\)</span> двух следующих термов: <code>X=fib(Y+1)</code> и <code>Y=fib(C+5+D)</code><a href="#fn29" class="footnoteRef" id="fnref29"><sup>29</sup></a>?</p>
</section>
</section>
</section>
<section id="списки-и-их-обработка" class="level1">
<h1><span class="header-section-number">3</span> Списки и их обработка</h1>
<p>Кроме описанных в разделе [sec:complex_data] структур данных, создаваемых с помощью функторов, в Прологе существует еще одна структура данных — <span><em>список</em></span> <span class="citation" data-cites="Bratko"></span>.</p>
<section id="списковая-форма-записи." class="level5">
<h5><span class="header-section-number">3.0.0.0.1</span> Списковая форма записи.</h5>
<p>Задачи, связанные с обработкой списков, на практике встречаются очень часто. Скажем, нам понадобилось составить список студентов, находящихся в аудитории. С помощью Пролога мы можем определить список как последовательность термов, заключенных в скобки. Приведем примеры правильно построенных списков Пролога:</p>
<pre><code>    [jack, john, fred, jill, john]
    [name(john, smith), age(jack, 24), X]
    [Х, У, date(12, january, 1986), Х]
    []</code></pre>
<p>В Turbo Prolog структура списков должна быть определена в явном виде в секции <span>Domains</span>. Например, список, состоящий из строковых значений, определяется в Turbo Prolog так:</p>
<pre><code>    Domains
        str_list = string *</code></pre>
<p>Символ &lt;&lt;&gt;&gt; определяет свойство нового типа <span>str_list</span> &lt;&lt;быть списком&gt;&gt; строк.</p>
<p>Запись определяет список, полученный добавлением элемента (терма) <span>Н</span> в начало списка <span>Т</span>. Говорят, что <span>Н</span> — голова, а <span>Т</span> — хвост списка . На запрос</p>
<pre><code>?- L = [a | [b, c, d]].</code></pre>
<p>будет получен ответ</p>
<pre><code>   L = [a, b, c, d],</code></pre>
<p>а на запрос</p>
<pre><code>?- L = [a, b, c, d], L2 = [2 | L].</code></pre>
<p>получим ответ</p>
<pre><code>   L = [a, b, c, d], L2 = [2, a, b, c, d].</code></pre>
<p>Запись используется для того, чтобы определить голову и хвост списка. Так, запрос</p>
<pre><code>   [X | Y] = [a, b, c].</code></pre>
<p>дает ответ</p>
<pre><code>   Х = а, Y = [b, c].</code></pre>
<p>Заметим, что употребление только имен переменных <span>Н</span> и <span>Т</span> необязательно. Кроме записи вида , для выборки термов используются переменные. Запрос</p>
<pre><code>?- [a, X, Y] = [a, b, c].</code></pre>
<p>определит значения</p>
<pre><code>   X=b, Y=c,</code></pre>
<p>а запрос</p>
<pre><code>?- [person(Х) | Т] = [person(john), а, b].</code></pre>
<p>значения</p>
<pre><code>   Х=john, Т=[а, b].</code></pre>
<p>Можно отделять в голове списка несколько элементов, соответствующая запись выглядит так: <span>L = [X1, X2, X3 | T]</span>.</p>
</section>
<section id="некоторые-стандартные-отношения-для-обработки-списков." class="level5">
<h5><span class="header-section-number">3.0.0.0.2</span> Некоторые стандартные отношения для обработки списков.</h5>
<p>Покажем на примерах использование записи вида вместе с рекурсией для определения некоторых полезных отношений над списками.</p>
<p><em>Принадлежность элемента списку</em>. Сформулируем задачу проверки принадлежности данного терма списку<a href="#fn30" class="footnoteRef" id="fnref30"><sup>30</sup></a>.</p>
<blockquote>
<p>Граничное условие (база индукции): Терм <span>R</span> содержится в списке , если <span>R = H</span>.<br />
Рекурсивное условие (индуктивный шаг): Терм <span>R</span> содержится в списке , если <span>R</span> содержится в <span>Т</span>.</p>
</blockquote>
<p>Первый вариант записи определения на Прологе имеет вид:</p>
<pre><code>    in(R, L) :-
        L=[H | T], H=R.
    in(R, L) :-
        L=[H | T], in(R, T).</code></pre>
<p>Цель <span>L = [H | T]</span> в теле обоих утверждений служит для того, чтобы разделить список <span>L</span> на голову и хвост.</p>
<p>Можно улучшить программу, если учесть тот факт, что Пролог сначала унифицирует с целью голову утверждения, а затем пытается унифицировать его тело. Новая процедура <span>in</span> определяется таким образом:</p>
<pre><code>    in(R, [R | Т]).
    in(R, [H | Т]) :- in(R, T).</code></pre>
<p>На запрос</p>
<pre><code>?- in(а, [а, b, с]).</code></pre>
<p>будет получен ответ <span>yes</span>. На запрос</p>
<pre><code>?- in(b, [a, b, с]).</code></pre>
<p>тоже ответ <span>yes</span>.</p>
<p>Существуют реализации Пролога, где предикат <span>принадлежит</span> (<span>in</span>) является встроенным, например, в ISO-Prolog этот предикат называется <code>member/2</code>.</p>
<p><em>Соединение двух списков</em>. Задача присоединения списка <span>Q</span> к списку <span>Р</span>, в результате чего получается список <span>R</span>, формулируется следующим образом:</p>
<blockquote>
<p>Граничное условие: Присоединение к списка <span>Q</span> дает <span>Q</span>. Рекурсивное условие: Присоединение к концу списка <span>Р</span> списка <span>Q</span> выполняется так: <span>Q</span> присоединяется к хвосту <span>Р</span>, а затем спереди добавляется голова <span>Р</span>.</p>
</blockquote>
<p>Определение (см. рис. [pic:list_descr]) можно непосредственно записать на Прологе:</p>
<pre><code>    conc([], Q, Q).
    conc(Р, Q, R) :- Р=[НР | ТР],
        conc(TP, Q, TR), R=[HP | TR].</code></pre>
<figure>
<embed src="pics/list_descr.eps" /><figcaption>Конкатенация списков , <span>Q</span>, <span data-label="pic:list_descr"></span></figcaption>
</figure>
<p>Однако, как и в предыдущем примере, воспользуемся тем, что Пролог унифицирует с целью голову утверждения, прежде чем пытаться согласовать тело:</p>
<pre><code>    conc([], Q, Q).
    conc([HP | TP], Q, [HP | TR]) :-
        conc(TP, Q, TR).</code></pre>
<p>На запрос</p>
<pre><code>?- conc([а, b, с], [d, e], L).</code></pre>
<p>будет получен ответ</p>
<pre><code>    L = [a, b, c, d],</code></pre>
<p>но на запрос</p>
<pre><code>?- conc([a, b], [c, d], [e, f]).</code></pre>
<p>ответом будет <span>no</span>.=-1</p>
<p>Часто процедура &lt;&lt;присоединить&gt;&gt; используется для получения списков, находящихся слева и справа от данного элемента:</p>
<pre><code>?- conc(L, [jim | R], [jack, bill, jim,
        tim, jim, bob]).
    L = [jack, bill], R = [tim, jim, bob];
    % далее идет еще одно решение
    L=[jack, bill, jim, tim], R=[bob].</code></pre>
<p>В командной строке GNU-Prolog при выполнении запроса и при наличии множества решений интерпретатор, выдав очередное решение, приостанавливает процесс решения задачи и ожидает реакцию пользователя на незримый вопрос &lt;&lt;Что делать дальше — остановить процесс поиска решения, вывести новое решение, вывести все решения?&gt;&gt; Если вам достаточно одного решения, то, нажимая клавишу &lt;&lt;Enter&gt;&gt;, вы вернетесь в командную строку запроса. Если вас интересует еще одно решение, то при нажатии клавиши &lt;&lt;;&gt;&gt; Пролог попытается найти это решение. GNU-Prolog позволяет вывести все решения, для этого предназначена клавиша &lt;&lt;a&gt;&gt;<a href="#fn31" class="footnoteRef" id="fnref31"><sup>31</sup></a> (all). Некоторые задачи могут порождать бесконечное количество решений. Остановка процесса бесконечного порождения решений и &lt;&lt;зациклившейся&gt;&gt; программы осуществляется нажатием комбинации &lt;&lt;Ctrl-C&gt;&gt; и выполнением команды отладчика &lt;&lt;a&gt;&gt; (abort).</p>
<p>Вот еще один пример использования процедуры &lt;&lt;присоединить&gt;&gt;. Здесь производится разрезание списка на два подсписка всеми возможными способами:</p>
<pre><code>?- conc(L, R, [jack, bill, jim, tim, jim, bob]).
    L = [], R = [jack, bill, jim, tim, jim, bob];
    L = [jack], R = [bill, jim, tim, jim, bob];
    L = [jack, bill], R = [jim, tim, jim, bob];
    L = [jack, bill, jim], R = [tim, jim, bob];
    L = [jack, bill, jim, tim], R = [jim, bob];
    L = [jack, bill, jim, tim, jim], R = [bob];
    L = [jack, bill, jim, tim, jim, bob], R = [].</code></pre>
<p>Необходимо заметить, что многие прологовские программы могут быть использованы как по прямому назначению, так и в обратном направлении. В этом, в частности, состоит сила логического программирования.</p>
<p><em>Индексирование списка</em>. Задача получения <span class="math inline">\(N\)</span>-гo терма в списке определяется следующим образом:</p>
<blockquote>
<p>Граничное условие: Первый терм в списке есть <span>Н</span>.</p>
<p>Рекурсивное условие: <span class="math inline">\(N\)</span>-й терм в списке является <span class="math inline">\((N-1)\)</span>-м термом в списке <span>Т</span>.</p>
</blockquote>
<p>Данному определению соответствует программа:</p>
<pre><code>    get([H | Т], 1, Н).   % Граничное условие
    get([Н | Т], N, Y) :- % Рекурсивное условие
        М is N - 1,
        get(Т, М, Y).</code></pre>
<p><em>Принадлежность одного списка другому</em> можно проверить с помощью разбиений:</p>
<blockquote>
<p>Список <span>S</span> является подсписком <span>L</span>, если <span>L</span> можно разбить на два списка <span>L1</span> и <span>L2</span>, и <span>L2</span> можно разбить на два списка <span>S</span> и <span>L3</span>.</p>
</blockquote>
<figure>
<embed src="pics/list_inc.eps" /><figcaption>Отношение &lt;&lt;подсписок&gt;&gt; <span>sublist/2</span>.<span data-label="pic:list_inc"></span></figcaption>
</figure>
<pre><code>    sublist(L, S) :-
        conc(L1, L2, L),
        conc(S, L3, L2).
            % Вместо L3 можно подставить &quot;_&quot;.</code></pre>
<p><em>Пеpестановки списка</em></p>
<blockquote>
<p>Если исходный список пуст, то и пеpестановка этого списка — пустой список. Если исходный список не пуст, то следует получить пеpестановку хвоста <span>L</span> этого списка, и затем добавить голову <span>X</span> списка к полученному списку.</p>
</blockquote>
<pre><code>    rep([], [])
    rep([X | L], R) :-
        rep(L, L1),
        intro(X, L1, R).
    intro(X, L, [X | L]). % вставка в голову
    intro(X, [Y | T], [Y | L]) :- % в хвост
        intro(X, T, L).</code></pre>
</section>
<section id="сортировка-списков." class="level5">
<h5><span class="header-section-number">3.0.0.0.3</span> Сортировка списков.</h5>
<p>Рассмотрим несколько методов сортировки списков.</p>
<p><em>Соpтиpовка списка методом пузыpька</em>. Для упоpядочения списка <span>С</span> необходимо:</p>
<blockquote>
<p>Hайти в <span>С</span> два смежных элемента <span>Х</span> и <span>Y</span> таких, что <span>Х &gt; Y</span>, и поменять их местами;</p>
<p>Если в <span>С</span> нет ни одной паpы смежных элементов <span>Х</span> и <span>Y</span> таких, что <span>Х &gt; Y</span>, то считать, что <span>С</span> уже отсоpтиpован.</p>
</blockquote>
<pre><code>    buble_sort(L1, L2) :-
        exchange_one(L1, L3), !,
        buble_sort(L3, L2).
    buble_sort(L, L).

    exchange_one([X, Y | T], [Y, X | T]) :-
        X &gt; Y.
    exchange_one([X, Y | T], [X | R]) :-
        \+ X &gt; Y,
        exchange_one([Y | T], R).</code></pre>
<p><em>Соpтиpовка списка методом вставки.</em> Для упоpядочения списка <span>С</span> необходимо:</p>
<blockquote>
<p>Пустой список считаем упорядоченным.</p>
<p>Упоpядочить хвост списка <span>С</span>.</p>
<p>Вставить голову списка <span>С</span> в упоpядоченный хвост, поместив ее в такое место, чтобы получившийся список остался упорядоченным.</p>
</blockquote>
<p>Программу приводить не будем, оставим это как упражнение.</p>
<p><em>Быстpая соpтиpовка списка</em></p>
<p>Для упоpядочения списка <span>С</span> необходимо:</p>
<blockquote>
<p>Пустой список считаем упорядоченным.</p>
<p>Удалить из списка пеpвый элемент <span>Х</span> и pазбить оставшуюся часть на два списка: <span>L</span> — с элементами, меньшими <span>X</span>, и <span>M</span> — со всеми остальными элементами.</p>
<p>Упоpядочить список <span>L</span> с получением списка <span>SL</span>.</p>
<p>Упоpядочить список <span>M</span> с получением списка <span>SM</span>.</p>
<p>Получить pезультиpующий упоpядоченный список <span>SC</span> как объединение <span>SL</span>, <span>Х</span> и <span>SM</span>.</p>
</blockquote>
<p>Hапpимеp, исходный список <span>С = [5, 3, 7, 8, 1, 4, 7, 6]</span>.<br />
Удаляем <span>Х = 5</span>.<br />
Список разбиваем на два:<br />
<span>L = [3, 1, 4]</span>; <span>M = [7, 8, 7, 6]</span>.<br />
Соpтиpуем последние списки, получаем:<br />
<span>SL = [1, 3, 4]</span>; <span>SM = [6, 7, 7, 8]</span>.<br />
Результат <span>SC</span> получаем объединением <span>SL</span> и .<br />
Итак, <span>SC = [1, 3, 4, 5, 6, 7, 7, 8]</span>.</p>
<pre><code>    quick_sort([], []).
    quick_sort([X | T], SC):-
        distrib(T, X, L, M),
        quick_sort(L, SL),
        quick_sort(M, SM),
        conc(SL, [X | SM],SC).
    distrib([], _, [], []).
    distrib([H | T], X, [H | T1], L) :-
        X &gt; H, distrib(T, T1, L).
    distrib([H | T], X, L, [H | T1]) :-
        \+ X &gt; H, distrib(T, L, T1).</code></pre>
</section>
<section id="построение-списков-из-фактов." class="level5">
<h5><span class="header-section-number">3.0.0.0.4</span> Построение списков из фактов.</h5>
<p>Иногда бывает полезно представить в виде списка информацию, содержащуюся в известных фактах. В большинстве реализаций Пролога есть необходимые для этого предикаты:</p>
<dl>
<dt>bagof(X, Y, L)</dt>
<dd><p>определяет список термов <span>L</span>, конкретизирующих переменную <span>Х</span> как аргумент предиката <span>Y</span>, которые делают истинным предикат <span>Y</span>.</p>
</dd>
<dt>setof(X, Y, L)</dt>
<dd><p>все сказанное о предикате <span>bagof</span> относится и к <span>setof</span>, за исключением того, что список <span>L</span> отсортирован и из него удалены все повторения.</p>
</dd>
<dt>findall(X, Y, L)</dt>
<dd><p>все сказанное о предикате <span>bagof</span> относится и к <span>findall</span>, за исключением того, что список <span>L</span> может быть пустым, если нет ни одного истинного предиката <span>Y</span>. Предикат <span>findall/3</span> всегда истинный.</p>
</dd>
</dl>
<p>Если имеются факты:</p>
<pre><code>    dog(rex).
    dog(goldy).
    dog(fido).
    dog(reke).
    dog(fido).</code></pre>
<p>то на запрос</p>
<pre><code>?- bagof(D, dog(D), L),</code></pre>
<p>так же как и для <span>findall/3</span>, будет получен ответ</p>
<pre><code>    L = [rex, goldy, fido, reke, fido],</code></pre>
<p>в то время как</p>
<pre><code>?- setof(D, dog(D), L)</code></pre>
<p>дает значение</p>
<pre><code>    L = [fido, goldy, reke, rex].</code></pre>
<p>На запрос</p>
<pre><code>    findall(D, cat(D), L)</code></pre>
<p>ответом будет</p>
<pre><code>    L = [],</code></pre>
<p>а подобные запросы <span>bagof/3</span> и <span>setof/3</span> завершаются неудачей.</p>
</section>
<section id="грамматический-разбор-текста" class="level2">
<h2><span class="header-section-number">3.1</span> Грамматический разбор текста</h2>
<p>Пролог обладает большими возможностями по сопоставлению объектов с эталоном<a href="#fn32" class="footnoteRef" id="fnref32"><sup>32</sup></a>, поэтому данный язык программирования хорошо подходит для обработки текстов <span class="citation" data-cites="Malpas"></span>. На Прологе можно с успехом реализовать генераторы отчетов, текстовые редакторы и трансляторы с различных языков. В данном разделе рассматриваются программы, предназначенные для обработки текстов. На примере этих программ демонстрируется непосредственное практическое применение систем Пролог.</p>
<p>Действия, выполняемые программой обработки текстов, разбиваются на две фазы. В течение первой фазы, называемой <em>лексическим анализом</em>, входной текст преобразуется из внешней формы в некоторое внутреннее представление. Во время второй фазы выполняется анализ или тот или иной вид обработки внутреннего представления текста. <em>Система грамматического разбора</em> — это процедура, которая распознает синтаксические структуры высокого уровня (объекты) во внутреннем представлении текста.</p>
<section id="стратегии-грамматического-разбора" class="level3">
<h3><span class="header-section-number">3.1.1</span> Стратегии грамматического разбора</h3>
<p>Одна из причин, по которой системы грамматического разбора вызывают столь большой интерес, заключается в существовании близкой аналогии между <em>стратегиями грамматического разбора</em> и <em>стратегиями решения задач</em> в целом. В интерпретаторе языка Пролог по умолчанию принята стратегия решения задач с <em>обратным ходом решения</em> . Решение начинается с гипотезы (т. е. с запроса), которая затем разбивается на субгипотезы (т. е. подцели правила), далее каждая субгипотеза делится на еще более мелкие составные части и т. д. Исходная гипотеза будет подтверждена, когда интерпретатор дойдет до субгипотез, которые уже нельзя разделить на составные части (т. е. до фактов). Альтернативой служит стратегия решения задач с <em>прямым ходом решения</em> . Такая стратегия применяется в языках OPS-5 и CLIPS. Решение начинается с фактов, а затем отыскиваются заключения, вытекающие из них. Далее на основании этих заключений делаются заключения более высокого уровня и т. д. Это происходит до тех пор, пока не будет достигнуто искомое заключение <span class="citation" data-cites="Malpas"></span>.</p>
<p>Система нисходящего грамматического разбора базируется (как и Пролог) на стратегии с обратным ходом решения, а система восходящего разбора — на стратегии с прямым ходом решения (как и язык OPS-5). Вообще говоря, нисходящий грамматический разбор более эффективен, чем восходящий: стратегия с обратным ходом решения вовлекает в процесс фактический материал только при необходимости. В классе задач построения трансляторов существуют некоторые грамматические конструкции, разбор которых можно реализовать только восходящим методом. Поскольку сам Пролог основывается на стратегии с обратным ходом решения, реализация на Прологе систем нисходящего грамматического разбора может быть осуществлена достаточно прямолинейным способом. Реализация восходящего грамматического разбора немного сложнее, так как для применения стратегии с прямым ходом решения требуется процедурная трактовка языка Пролог. Существует также ряд других задач, для которых более предпочтительно использование стратегии с прямым ходом решения.</p>
<p>=-1</p>
</section>
<section id="лексический-анализатор" class="level3">
<h3><span class="header-section-number">3.1.2</span> Лексический анализатор</h3>
<p>Лексический анализатор распознает сочетания символов, поступающих из входного потока, и вырабатывает поток лексем. Каждая лексема представляет одну из строк символов. Множество лексем, сгенерированных лексическим анализатором, образует внутреннее представление входного потока (рис. [pic:lex_anal]).</p>
<figure>
<embed src="pics/lex_anal.eps" /><figcaption>Лексический анализатор<span data-label="pic:lex_anal"></span></figcaption>
</figure>
<p>Реализация лексического анализатора проще всего представляется в Turbo-Prolog. В этой версии языка в стандартной библиотеке есть предикат <span>fronttoken/3</span>, который отделяет разделяет входную строку на некоторую лексему и оставшуюся часть строки. Лексемы — это либо числа, либо знаки, либо слова, разделенные пробелами.</p>
<pre><code>    lex(Str, [Tok | Tokens]) :-
        fronttoken(Str, Tok, RStr), !,
        lex(RStr, Tokens).
    lex(S, []).  % Для пустых строк.</code></pre>
<p>Теперь <span>lex/2</span> будет истинным по определению, если строка <span>Str</span> разбивается на список лексем по правилам предиката <span>fronttoken/3</span>.</p>
<p>В стандарте ISO есть предикат <code>read_token/2</code>, который считывает лексему из входного потока, например, файла или специальным образом ассоциированного с потоком атома (строки).</p>
<pre><code>    lex1(Stream, L) :-
        read_token(Stream, Term),!,
        (
            Term=punct(end_of_file), % Конец файла?
            L=[],!; % Да.
            !,      % Нет.
            conv_lex(Term, T), % Убрать разметку.
            lex1(Stream, Tail), % Следующая лексема.
            app(T, Tail, L)    %
        ).
    lex(Atom, L):-
        open_input_atom_stream(Atom, Stream),
        lex1(Stream, L),
        close_input_atom_stream(Stream).</code></pre>
<p>В этой версии предикат <code>lex1/2</code> — вспомогательный. Реализация <code>lex/2</code> в SWI-Prolog будет иной.</p>
<p>Проведем испытания нашего лексического анализатора в GNU-Prolog<a href="#fn33" class="footnoteRef" id="fnref33"><sup>33</sup></a>:</p>
<pre><code>?- lex(&#39;The cow shakes the tail&#39;, L).
    L = [&#39;The&#39;, &#39;cow&#39;, &#39;shakes&#39;, &#39;the&#39;, &#39;tail&#39;]

    lex(&#39;Slithy towes did gyre&#39;, L).
    L = [&#39;Slythy&#39;, &#39;towes&#39;, &#39;did&#39;, &#39;gyre&#39;]

    lex(&#39;The cow jumped over the Moon.&#39;, L).
    L = [&#39;The&#39;, &#39;cow&#39;, &#39;jumped&#39;, &#39;over&#39;, &#39;the&#39;,
        &#39;Moon&#39;, &#39;.&#39;]

    lex(&#39;FOR I:=1 TO 2013 DO BEGIN END ;&#39;, L).
    L = [&#39;FOR&#39;, &#39;I&#39;, &#39;:&#39;, &#39;=&#39;, &#39;1&#39;, &#39;TO&#39;, &#39;2013&#39;,
        &#39;DO&#39;, &#39;BEGIN&#39;, &#39;END&#39;, &#39;;&#39;]</code></pre>
<p>Видно, что лексический анализатор работает приемлемо.</p>
</section>
<section id="система-нисходящего-грамматического-разбора" class="level3">
<h3><span class="header-section-number">3.1.3</span> Система нисходящего грамматического разбора</h3>
<p>Система грамматического разбора — это программа, которая распознает синтаксические объекты в потоке лексем. Здесь описана программа нисходящего грамматического разбора <span>object/3</span>. На вход программы поступают список слов и название определенного синтаксического объекта более высокого уровня. Программа разбора добьется успеха, если в начале списка обнаружит слова, из которых формируется требуемый синтаксический объект. В противном случае программа потерпит неудачу. Грамматика для программы <span>object/3</span> — это несложное подмножество английского языка. Распознаваемые программой синтаксические объекты — это все части предложений английского языка, такие как &lt;&lt;предложение&gt;&gt;, &lt;&lt;глагольная группа&gt;&gt; или &lt;&lt;артикль&gt;&gt;. Программа <span>object/3</span> одновременно представляет собой и словарь, и грамматику <span class="citation" data-cites="Malpas"></span>.</p>
<p>Согласно терминологии грамматического разбора <em>терминальный символ</em> (или <em>терминал</em>) — это входная лексема, поступающая из блока синтаксического анализа, а <em>нетерминальный символ</em> (или <em>нетерминал)</em> — это синтаксический объект, образованный комбинацией терминальных или нетерминальных символов. Множество терминалов, известное системе разбора, называется ее <em>словарем</em>. Компоненты каждого нетерминального символа специфицируются при помощи <em>грамматического правила</em>, а множество грамматических правил, известных системе разбора, образует ее <em>грамматику</em>.</p>
<p>В описываемой системе используется простая грамматика, которая в форме Бэкуса—Наура представляется так:</p>
<pre><code>    &lt;предложение&gt; ::= &lt;глагольная группа&gt;
        &lt;группа существительного&gt;
    &lt;группа существительного&gt; ::= &lt;артикль&gt;
        &lt;существительное&gt;
    &lt;глагольная группа&gt; ::= &lt;глагол&gt;
        &lt;группа существительного&gt;</code></pre>
<p>В программе каждый терминал, входящий в состав словаря, представляется фактом <span>object</span>, а каждый нетерминал, входящий в грамматику, представляется правилом <span>object/3</span>.</p>
<pre><code>    % Принятые имена переменных
    % I - входной список лексем
    % О, R - выходной список лексем
    % нетерминалы:

    object(I, О, &#39;предложение&#39;) :-
        object(I, R, &#39;группа существительного&#39;),
        object(R, О, &#39;глагольная группа&#39;).

    object(I, О, &#39;группа существительного&#39;) :-
        object(I, R, &#39;артикль&#39;),
        object(R, О, &#39;существительное&#39;).

    object(I, О, &#39;глагольная группа&#39;) :-
        object(I, R, &#39;глагол&#39;),
        object(R, О, &#39;группа существительного&#39;).

    % терминалы:

    object([&#39;the&#39; | R], R, &#39;артикль&#39;).
    object([&#39;cow&#39; | R], R, &#39;существительное&#39;).
    object([&#39;tail&#39; | R], R, &#39;существительное&#39;).
    object([&#39;shakes&#39; | R], R, &#39;глагол&#39;).
    object([&#39;walks&#39; | R], R, &#39;глагол&#39;).</code></pre>
<p>Заметьте,что форма нетерминальных правил <span>object</span> в точности соответствует форме грамматических правил.</p>
<p>Современные реализации Пролога содержат в качестве подсистемы транслятор DCG (Definite clause grammars<a href="#fn34" class="footnoteRef" id="fnref34"><sup>34</sup></a>) <span class="citation" data-cites="WIKI-DCG"></span>. DCG удобна для представления грамматических правил при создании трансляторов. DCG не входит в стандарт ISO, и поэтому считается, что ее наличие и реализация зависит от системы программирования Пролог. Грамматические правила нашего примера в DCG будут представлены в следующем виде:</p>
<pre><code>    % Нетерминалы:
    &#39;предложение&#39; -&gt; &#39;группа существительного&#39;,
        &#39;глагольная группа&#39;.

    &#39;группа существительного&#39; -&gt;
        &#39;артикль&#39;, &#39;существительное&#39;.

    &#39;глагольная группа&#39; -&gt; &#39;глагол&#39;,
        &#39;группа существительного&#39;.

    % терминалы:
    &#39;артикль&#39; -&gt; [&#39;the&#39;].
    &#39;существительное&#39; -&gt; [&#39;cow&#39;, &#39;tail&#39;].
    &#39;глагол&#39; -&gt; [&#39;shakes&#39;, &#39;walks&#39;].</code></pre>
<p>Такая форма транслируется языком Пролог в представление, аналогичное представлению <code>object/3</code>, только имена правил преобразуются в такие же имена предикатов, добавятся два аргумента <code>I, O</code> (входной и выходной список лексем). Правила DCG могут включать дополнительные аргументы, которые при трансляции будут добавляться в заголовок к <code>I, O</code>. Дополнительные аргументы можно использовать для синтеза необходимых структур, например деревьев синтаксического разбора.</p>
<section id="использование-программы-object3." class="level5">
<h5><span class="header-section-number">3.1.3.0.1</span> Использование программы <span>object/3</span>.</h5>
<p>В качестве первого аргумента процедуры <span>object</span> передается входной список лексем. Третий аргумент — это название определяемого объекта. Второй аргумент образован частью списка, остающейся после того, как из начала списка будет взят терминал или нетерминал. Функции аргументов можно проиллюстрировать на примере запроса:</p>
<pre><code>  ?- object([&#39;cow&#39;, &#39;horse&#39;, &#39;goat&#39;], Rest,
           &#39;существительное&#39;).
       Rest = [&#39;horse&#39;, &#39;goat&#39;]</code></pre>
<p>Запрос обозначает: &lt;&lt;Можно ли взять <span>существительное</span> из начала списка , и если да, то какая часть списка останется?&gt;&gt; Ответ на данный запрос показывает, что это возможно и что остается список . Запрос подтверждает, что слово <span>cow</span> является существительным.</p>
<p>Подобным образом, запрос к процедуре <span>object/3</span> подтвердит или опровергнет предположение о том, что список слов образует нетерминальный символ:</p>
<pre><code>  ?- object([&#39;the&#39;, &#39;cow&#39;, &#39;.&#39; ], L,
           &#39;глагольная группа&#39;).
       no.

  ?- object([&#39;the&#39;, &#39;cow&#39;, &#39;.&#39; ], L,
         &#39;группа существительного&#39;).
       L = [&#39;.&#39;] % успех

  ?- object([&#39;the&#39;, &#39;cow&#39;, &#39;shakes&#39;, &#39;the&#39;,
           &#39;tail&#39;], L, &#39;предложение&#39;).
       L = [] % успех</code></pre>
</section>
<section id="использование-процедуры-object3-в-обратном-направлении." class="level5">
<h5><span class="header-section-number">3.1.3.0.2</span> Использование процедуры <span>object/3</span> в обратном направлении.</h5>
<p>Все аргументы процедуры <span>object/3</span> являются двунаправленными. Это означает, что при помощи запросов к процедуре <span>object</span> можно также сгенерировать любые синтаксические объекты, какие только можно построить по входному списку лексем, или даже сгенерировать все возможные предложения по заданным словарю и грамматике.</p>
<pre><code>    % проанализировать входной список:
?- object([&#39;the&#39;, &#39;tail&#39;], L, Object).    % (1)
     L = [&#39;tail&#39;],
     Object = &#39;артикль&#39;.
     L = [],
     Object = &#39;группа существительного&#39;

     % сгенерировать все предложения:
?- object(Х, [], &#39;предложение&#39;).          % (2)
     X = [&#39;the&#39;, &#39;cow&#39;, &#39;shakes&#39;, &#39;the&#39;, &#39;cow&#39;];
     X = [&#39;the&#39;, &#39;cow&#39;, &#39;shakes&#39;, &#39;the&#39;, &#39;tail&#39;];
     X = [&#39;the&#39;, &#39;cow&#39;, &#39;walks&#39;, &#39;the&#39;, &#39;cow&#39;];
     X = [&#39;the&#39;, &#39;cow&#39;, &#39;walks&#39;, &#39;the&#39;, &#39;tail&#39;];
     X = [&#39;the&#39;, &#39;tail&#39;, &#39;shakes&#39;, &#39;the&#39;, &#39;cow&#39;];
     X = [&#39;the&#39;, &#39;tail&#39;, &#39;shakes&#39;, &#39;the&#39;, &#39;tail&#39;];
     X = [&#39;the&#39;, &#39;tail&#39;, &#39;walks&#39;, &#39;the&#39;, &#39;cow&#39;];
     X = [&#39;the&#39;, &#39;tail&#39;, &#39;walks&#39;, &#39;the&#39;, &#39;tail&#39;].</code></pre>
<p>Обратите внимание, что во втором запросе второй аргумент &lt;&lt;&gt;&gt; указывает, что после окончания грамматического разбора должен остаться пустой список.</p>
<p>Предложения, сгенерированные программе разбора, синтаксически правильны, однако их <em>семантическая корректность</em> не гарантируется. Программа может вырабатывать бессмысленные предложения вроде , что переводится как &lt;&lt;Корова идет [по] хвост[у]&gt;&gt;.</p>
<p>Что можно ожидать получить от следующего запроса?</p>
<pre><code>?- object(А, В, С).</code></pre>
<p>Пусть <code>L=[1, 2, 3, 4]</code>, <code>L=[X1, X2 | Q]</code>. Каково будет значение <code>Q</code>?</p>
<p>Справедливо ли высказывание <code>[]=[_|[]]</code>?</p>
<p>Каков будет результат выполнения <code>findall(X, fail, L)</code>?</p>
<p>Дополните программу синтаксического анализа поддержкой неопределенного артикля английского языка.</p>
</section>
</section>
</section>
</section>
<section id="интерпретации-программ-пролога" class="level1">
<h1><span class="header-section-number">4</span> Интерпретации программ Пролога</h1>
<p>Интерпретация программы — предложение естественного языка, например русского, которое выражает смысл программы или части программы. Интерпретация, в некоторой степени, — процесс, обратный формализации модели. Интерпретации строятся, например, для того, чтобы объяснить другому человеку, не знакомому с языком Пролог, как работает программа, какие результаты она получает, что такое решение и т. д.</p>
<p>Различают два способа <span class="citation" data-cites="Bratko"></span> интерпретации (задания смысла) программы на Прологе, а именно:</p>
<ul>
<li><p><em>декларативная интерпретация</em>;</p></li>
<li><p><em>процедурная интерпретация.</em></p></li>
</ul>
<p>Декларативный смысл касается только <strong>отношений</strong>, определенных в программе. Таким образом, декларативный смысл определяет, <span><strong>что</strong></span> должно быть результатом работы программы. С другой стороны, процедурный смысл определяет еще и <span><strong>как</strong></span> этот <span><strong>результат был получен</strong></span>, т. е. как отношения реально обрабатываются Пролог&quot;=системой.</p>
<p>Способность Пролог“=системы прорабатывать многие процедурные детали самостоятельно считается одним из специфических преимуществ Пролога. Это свойство побуждает программиста рассматривать декларативный смысл программы относительно независимо от ее процедурного смысла. Поскольку результаты работы программы в принципе определяются ее декларативным смыслом, последнего (опять же в принципе) достаточно для написания программ. Этот факт имеет практическое значение, поскольку декларативные аспекты программы являются, обычно, более легкими для понимания, нежели процедурные детали. Чтобы извлечь из этого обстоятельства наибольшую пользу, программисту следует сосредоточиться, главным образом, на декларативном смысле и по возможности не отвлекаться на детали процесса вычислений. Последние следует в возможно большей мере предоставить самой Пролог”=системе.</p>
<p>Декларативный подход и в самом деле часто делает программирование на Прологе более легким, чем на таких типичных процедурно“=ориентированных языках, как Паскаль. К сожалению, однако, декларативного подхода не всегда оказывается достаточно. Далее станет ясно, что, особенно в больших программах, программист не может полностью игнорировать процедурные аспекты по соображениям эффективности вычислений. Тем не менее следует поощрять декларативный стиль мышления при написании Пролог”=программ, а процедурные аспекты игнорировать в тех пределах, которые устанавливаются практическими ограничениями.</p>
<p>Рассмотрим формальное определение декларативного и процедурного смыслов программ базисного Пролога. Но сначала давайте взглянем на различия между этими двумя семантиками. Рассмотрим предложение</p>
<pre><code>    Р :- Q, R.</code></pre>
<p>где <span>Р</span>, <span>Q</span> и <span>R</span> имеют синтаксис предикатов. Приведем некоторые способы декларативной интерпретации этого предложения:</p>
<blockquote>
<p><span>Р</span> — истинно, если <span>Q</span> и <span>R</span> истинны.<br />
Из <span>Q</span> и <span>R</span> следует <span>Р</span>.</p>
</blockquote>
<p>А вот два варианта его процедурного прочтения:</p>
<blockquote>
<p>Чтобы решить задачу <span>Р</span>, <strong>сначала</strong> реши подзадачу <span>Q</span>, а <span><strong>затем</strong></span> — подзадачу <span>R</span>.<br />
Чтобы достичь <span>Р</span>, <strong>сначала</strong> достигни <span>Q</span>, а <strong>затем</strong> <span>R</span>.</p>
</blockquote>
<p>Таким образом, различие между декларативной и процедурной интерпретациями заключается в том, что последняя определяет не только логические связи между головой предложения и целями в его теле, но еще и <span><strong>порядок</strong></span>, в котором эти цели обрабатываются.</p>
<section id="декларативная-интерпретация" class="level2">
<h2><span class="header-section-number">4.1</span> Декларативная интерпретация</h2>
<p>Декларативная интерпретация программы определяет, является ли данная цель истинной (достижимой), и если да, при каких значениях переменных она истинна. Для точного определения декларативной интерпретации нам потребуется понятие <em>конкретизации</em> предложения (факта, правила или запроса). Конкретизацией предложения <span>С</span> называется результат подстановки в него на место каждой переменной некоторого терма. <em>Вариантом</em> предложения <span>С</span> называется такая конкретизация <span>С</span>, при которой каждая переменная заменена на число, символ, другую переменную или структуру. Например, рассмотрим предложение:</p>
<pre><code>    has_a_child(X) :- parent(X,Y).</code></pre>
<p>Приведем два эквивалентных варианта этого предложения:</p>
<pre><code>    has_a_child(А) :- parent(А, В).
    has_a_child(X) :- parent(X, Y).</code></pre>
<p>Примеры конкретизации этого же предложения:</p>
<pre><code>    has_a_child(piter) :- parent(piter, Z).
    has_a_child(barry) :- parent(barry, caroline).</code></pre>
<p>Пусть дана некоторая программа и цель <span class="math inline">\(G\)</span>, тогда, в соответствии с декларативной семантикой, можно утверждать, что:</p>
<blockquote>
<p>цель <span class="math inline">\(G\)</span> истинна (т. е. достижима или логически следует из программы) тогда и только тогда, когда:</p>
<ol>
<li><p>в программе существует предложение <span class="math inline">\(G\)</span>, такое, что</p></li>
<li><p>существует такая его (<span class="math inline">\(G\)</span>) конкретизация <span class="math inline">\(I\)</span>, что</p>
<ol>
<li><p>голова <span class="math inline">\(I\)</span> совпадает с <span class="math inline">\(G\)</span> и</p></li>
<li><p>все цели в теле <span class="math inline">\(I\)</span> истинны.</p></li>
</ol></li>
</ol>
</blockquote>
<p>Это определение можно распространить на вопросы следующим образом. В общем случае вопрос к Пролог&quot;=системе представляет собой список целей, разделенных запятыми. Список целей называется истинным (достижимым), если все цели в этом списке истинны (достижимы) при одинаковых конкретизациях переменных. Значения переменных получаются в результате поиска наиболее общей конкретизации.</p>
<p>Таким образом, запятая между целями обозначает конъюнкцию целей: они <strong>все</strong> должны быть истинными. Однако в Прологе возможна и <strong>дизъюнкция</strong> целей: должна быть истинной <strong>по крайней мере одна</strong> из целей. Дизъюнкция обозначается точкой с запятой.</p>
<pre><code>    Р :- Q ; R, S.</code></pre>
<p>Это выражение читается так: <span>Р</span> — истинно, если истинно <span>Q</span> <strong>или</strong> истинны <span><strong>оба</strong></span> <span>R</span> <span><strong>и</strong></span><a href="#fn35" class="footnoteRef" id="fnref35"><sup>35</sup></a> <span>S</span>. То есть смысл такого предложения тот же, что и смысл следующей пары предложений:</p>
<pre><code>    Р :- Q.
    Р :- R, S.</code></pre>
</section>
<section id="процедурная-интерпретация" class="level2">
<h2><span class="header-section-number">4.2</span> Процедурная интерпретация</h2>
<p>Процедурная семантика определяет, <strong>как</strong> пролог&quot;=система отвечает на вопросы. Ответить на вопрос — это значит удовлетворить список целей. Этого можно добиться, приписав встречающимся переменным значения таким образом, чтобы цели логически следовали из программы. Можно сказать, что процедурная семантика Пролога — это процедура вычисления списка целей с учетом заданной программы. Вычислить цели — это значит попытаться достичь их.</p>
<p>Назовем эту процедуру <code>вычислить</code>. Как показано на рис. [pic:proc], входом и выходом этой процедуры являются:</p>
<ul>
<li><p>входом — программа и список целей,</p></li>
<li><p>выходом — признак &lt;&lt;успех&gt;&gt;/&lt;&lt;неуспех&gt;&gt; и подстановка переменных.</p></li>
</ul>
<figure>
<embed src="pics/imp_proc.eps" /><figcaption>Входы и выходы процедуры вычисления списка целей<span data-label="pic:proc"></span></figcaption>
</figure>
<p>Смысл двух составляющих выхода такой:</p>
<ul>
<li><p>Признак &lt;&lt;успех&gt;&gt;/&lt;&lt;неуспех&gt;&gt; принимает значение <span>да</span>, если цели достижимы, и <span>нет</span> — в противном случае. Будем говорить, что <span>да</span> сигнализирует об <span><strong>успешном</strong></span> завершении, и <span>нет</span> — о <span><strong>неуспехе</strong></span>.</p></li>
<li><p>Подстановка переменных порождается процедурой только в случае успешного завершения; в случае неуспеха подстановка отсутствует.</p></li>
</ul>
<p>[ex:bear] Пример, иллюстрирующий процедурную семантику Пролога: последовательность вычислений, выполняемых процедурой <span>вычислить</span>.</p>
<p>[ex:interp]</p>
<section id="программа." class="level5">
<h5><span class="header-section-number">4.2.0.0.1</span> ПРОГРАММА.</h5>
<p>Пусть дана следующая программа.</p>
<pre><code>    big(bear).      % Предложение 1
    big(elephant).  % Предложение 2
    big(cat).       % Предложение 3
    brown(bear).    % Предложение 4
    black(cat).     % Предложение 5
    gray(elephant). % Предложение 6
    dark(Z) :-      % Предложение 7:
        black(Z).   % Любой черный объект
                    %   является темным
    dark(Z) :-      % Предложение 8:
        brown(Z).   % Любой коричневый объект
                    %   является темным</code></pre>
</section>
<section id="запрос." class="level5">
<h5><span class="header-section-number">4.2.0.0.2</span> ЗАПРОС.</h5>
<p>Зададим следующий запрос.</p>
<pre><code>?- dark(X), big(X).
        % Кто одновременно темный и большой?</code></pre>
</section>
<section id="шаги-вычислений" class="level5">
<h5><span class="header-section-number">4.2.0.0.3</span> Шаги вычислений</h5>
<ul>
<li><p>Исходный список целевых утверждений:</p>
<pre><code>    dark(X), big(X).</code></pre></li>
<li><p>Просмотр всей программы от начала к концу и поиск предложения, у которого голова сопоставима с первым целевым утверждением</p>
<pre><code>    dark(X).</code></pre>
<p>Найдена формула 7:</p>
<pre><code>    dark(Z) :- black(Z).</code></pre>
<p>Замена первого целевого утверждения конкретизированным телом предложения 7 - порождение нового списка целевых утверждений.</p>
<pre><code>    black(X), big(X).</code></pre></li>
<li><p>Просмотр программы для нахождения предложения, сопоставимого с <code>black(X)</code>. Найдено предложение 5: <code>black(cat)</code>. У этого предложения нет тела, поэтому список целей при соответствующей конкретизации сокращается до</p>
<pre><code>    big(cat).</code></pre></li>
<li><p>Просмотр программы в поисках цели <code>big(cat).</code> Ни одно предложение не найдено. Поэтому происходит возврат к шагу (3) и отмена конкретизации <span>X = cat</span>. Список целей теперь снова</p>
<pre><code>    black(X), big(X).</code></pre>
<p>Продолжение просмотра программы ниже предложения 5. Ни одно предложение не найдено. Поэтому возврат к шагу (2) и продолжение просмотра ниже предложения 7. Найдено предложение 8:</p>
<pre><code>    dark(Z) :- brown(Z).</code></pre>
<p>Замена первой цели в списке на <code>brown(Х)</code>, что дает</p>
<pre><code>    brown(X), big(X)</code></pre></li>
<li><p>Просмотр программы для обнаружения предложения, сопоставимого <code>brown(X)</code>. Найдено предложение <code>brown(bear)</code>. У этого предложения нет тела, поэтому список целей уменьшается до</p>
<pre><code>    big(bear).</code></pre></li>
<li><p>Просмотр программы и обнаружение факта <code>big(bear)</code>. У него нет тела, поэтому список целей становится пустым. Это указывает на успешное завершение.</p></li>
</ul>
<p>В оставшейся части данного раздела приводится несколько более формальное и систематическое описание приведенного процесса. Конкретные операции, выполняемые в процессе вычисления целевых утверждений, показаны в приведенном примере [ex:bear]. Возможно, следует изучить этот рисунок прежде, чем знакомиться с последующим общим описанием.</p>
<p>Чтобы вычислить список целевых утверждений <span class="math display">\[G_1, G_2, \ldots, G_m,\]</span> процедура <strong>вычислить</strong> делает следующее:</p>
<ul>
<li><p>Если список целей пуст — завершает работу <strong>успешно</strong>.</p></li>
<li><p>Если список целей не пуст, продолжает работу, выполняя (описанную далее) операцию <span>просмотр</span>.</p></li>
<li><p>Операция <code>просмотр</code>: Просматривает предложения программы от начала к концу до обнаружения первого предложения <span class="math inline">\(C\)</span>, такого, что голова <span class="math inline">\(C\)</span> сопоставима с первой целью <span class="math inline">\(G_1\)</span>. Если такого предложения обнаружить не удается, то работа заканчивается <strong>неуспехом</strong>.</p>
<p>Если <span class="math inline">\(C\)</span> найдено и имеет вид<br />
<code>    </code><span class="math inline">\(H\)</span> <span>:-</span> <span class="math inline">\(B_1\)</span><span>,</span> …<span>,</span> <span class="math inline">\(B_n\)</span><span>,</span></p>
<p>то переменные в <span class="math inline">\(C\)</span> переименовываются, чтобы получить такой вариант <span class="math inline">\(C&#39;\)</span> предложения <span class="math inline">\(C\)</span>, в котором нет общих переменных со списком <span class="math inline">\(G_1, \ldots, G_m\)</span>. Пусть <span class="math inline">\(C&#39;\)</span> — это<br />
<code>    </code><span class="math inline">\(H&#39;\)</span> <span>:-</span> <span class="math inline">\(B&#39;_1\)</span><span>,</span> …<span>,</span> <span class="math inline">\(B&#39;_n\)</span><span>.</span></p>
<p>Сопоставляется <span class="math inline">\(G_1\)</span> с <span class="math inline">\(H&#39;\)</span>; пусть <span class="math inline">\(S\)</span> — результирующая конкретизация переменных. В списке целей <span class="math inline">\(G_1\)</span>, <span class="math inline">\(G_2\)</span>, …, <span class="math inline">\(G_m\)</span>, цель <span class="math inline">\(G_1\)</span> заменяется на список <span class="math inline">\(B_1&#39;\)</span><span>,</span> …<span>,</span> <span class="math inline">\(B&#39;_n\)</span>, что порождает новый список целей:<br />
<code>    </code><span class="math inline">\(B_1&#39;\)</span><span>,</span> …<span>,</span> <span class="math inline">\(B_n&#39;\)</span><span>,</span> <span class="math inline">\(G_2\)</span><span>,</span> …<span>,</span> <span class="math inline">\(G_m\)</span><span>.</span></p>
<p>Заметим, если <span class="math inline">\(C\)</span> — факт, тогда <span class="math inline">\(n = 0\)</span>, и в этом случае новый список целей оказывается короче, нежели исходный; такое уменьшение списка целей может в определенных случаях превратить его в пустой, а следовательно, — привести к успешному завершению.</p>
<p>Переменные в новом списке целей заменяются новыми значениями, как это предписывает конкретизация <span class="math inline">\(S\)</span>, что порождает еще один список целей<br />
<code>    </code><span class="math inline">\(B_1&#39;&#39;\)</span><span>,</span> …<span>,</span> <span class="math inline">\(B_n&#39;&#39;\)</span><span>,</span> <span class="math inline">\(G_2\)</span><span>,</span> …<span>,</span> <span class="math inline">\(G_m\)</span><span>.</span></p></li>
<li><p>Вычисляет (используя рекурсивно ту же самую процедуру) этот новый список целей. Если его вычисление завершается успешно, то и вычисление исходного списка целей тоже завершается успешно. Если же его вычисление порождает неуспех, тогда новый список целей отбрасывается и происходит возврат (backtrack) к просмотру программы. Этот просмотр продолжается, начиная с предложения, непосредственно следующего за ипользованным только-что предложением <span class="math inline">\(C\)</span>, и делается попытка достичь успешного завершения с помощью нового предложения.</p></li>
</ul>
</section>
<section id="примеры-интерпретаций-программ" class="level3">
<h3><span class="header-section-number">4.2.1</span> Примеры интерпретаций программ</h3>
<p>Для того чтобы продемонстрировать &lt;&lt;полярность&gt;&gt; декларативной и процедурной интерпретации, рассмотрим два примера:</p>
<p>Определить декларативную и процедурную семантику (смысл) следующего предложения языка Пролог.</p>
<pre><code>    P :- P.</code></pre>
<section id="декларативная-интерпретация." class="level5">
<h5><span class="header-section-number">4.2.1.0.1</span> Декларативная интерпретация.</h5>
<p>Семантика (смысл) предложения выражается фразой: &lt;&lt;<span>P</span> истинно, если истинно <span>P</span>&gt;&gt;. С декларативной точки зрения фраза совершенно корректна<a href="#fn36" class="footnoteRef" id="fnref36"><sup>36</sup></a> (эта фраза — тавтология), однако в процедурном смысле это предложение бесполезно. Более того, для Пролог&quot;=системы такое предложение порождает серьезную проблему. Рассмотрим запрос:</p>
<pre><code>    ?- P.</code></pre>
<p>При использовании вышеприведенного предложения <span>P</span> будет заменено на ту же самую цель <span>P</span>, она, в свою очередь, будет заменена снова на <span>P</span> и т. д. В этом случае система войдет в бесконечный цикл, не замечая, что никакого продвижения в вычислениях не происходит. Рассмотрим другой пример.</p>
<p>Определить декларативную и процедурную семантику следующего предложения языка Пролог.</p>
<pre><code>    P.
    P :- P.</code></pre>
<p>С точки зрения декларативного смысла добавление <span>P</span> как факта излишне, как излишне было бы добавление <span>P :- P</span> к факту <span>P</span>. В обоих случаях мы имеем дело с <span><strong>истинными</strong></span><a href="#fn37" class="footnoteRef" id="fnref37"><sup>37</sup></a> высказываниями. Однако с процедурной точки зрения программа представляет интерес. Пусть в Пролог&quot;=систему введен запрос:</p>
<pre><code>?- P.</code></pre>
<p>Цель <span>P</span> сопоставляется с фактом <span>P</span>, и при этом получается пустое множество — выполнение завершается <span><strong>удачно</strong></span>. Если <span>P</span> — это часть тела какого&quot;=либо правила <span class="math inline">\(C\)</span>, то в процессе доказательства <span class="math inline">\(C\)</span> возможны возвраты, в том числе и к <span>P</span>. В этом случае сопоставление цели (подцели правила <span class="math inline">\(C\)</span>) <span>P</span> с фактом <span>P</span> <span><strong>отменяется</strong></span> и производится замена цели <span>P</span> по правилу <span>P :- P</span> на &lt;&lt;новую&gt;&gt; цель <span>P</span>. Далее, для этой цели выполняются вычисления, начиная с сопоставления ее с фактом <span>P</span>. Всякий раз, отменяя предыдущее сопоставление цели <span>P</span> с фактом <span>P</span>, Пролог порождает новую (как правило, такую же) ветвь поиска сопоставлений для подцелей в <span class="math inline">\(C\)</span>, стоящих <span><strong>за</strong></span> подцелью <span>P</span>. Таким образом, возврат (backtrtack) из <span class="math inline">\(C\)</span> никогда не может быть сделан<a href="#fn38" class="footnoteRef" id="fnref38"><sup>38</sup></a>.</p>
<p>Описанный предикат <span>P</span> находит свое применение в подпрограммах пользовательских интерфейсов как способ организации бесконечного цикла. Более того, он имеет собственное имя:</p>
<pre><code>    Repeat.
    Repeat :- Repeat.</code></pre>
<p>Дайте определение декларативной (описательной) интерпретации Пролог&quot;=программы.</p>
<p>Дайте определение процедурной интерпретации Пролог&quot;=программы.</p>
<p>Как можно использовать предикат <code>repeat</code>?</p>
<p>Какова процедурная интерпретация следующего высказывания языка Пролог: <code>A :- Q,W,E;R,T,Y.</code>?</p>
</section>
</section>
</section>
</section>
<section id="управление-логическим-выводом" class="level1">
<h1><span class="header-section-number">5</span> Управление логическим выводом</h1>
<p>Прежде всего программист может управлять процессом вычислений по программе, располагая ее предложения и цели в том или ином порядке <span class="citation" data-cites="Bratko"></span>. В данной главе мы рассмотрим еще одно средство управления, получившее название <span><em>отсечение</em></span> (cut) и предназначенное для ограничения автоматического перебора в механизме вывода Пролога <span class="citation" data-cites="Bratko"></span>.</p>
<section id="ограничение-перебора" class="level2">
<h2><span class="header-section-number">5.1</span> Ограничение перебора</h2>
<p>В процессе достижения цели Пролог“=система осуществляет автоматический перебор вариантов, делая возврат при неуспехе какого”=либо из них. Такой перебор — полезный программный механизм, поскольку он освобождает пользователя от необходимости программировать его самому. С другой стороны, ничем не ограниченный перебор может стать источником <span><strong>неэффективности</strong></span> программы. Поэтому иногда требуется его ограничить или исключить вовсе. Для этого в Прологе предусмотрена конструкция &lt;&lt;отсечение&gt;&gt;.</p>
<p>Давайте сначала рассмотрим простую программу, процесс вычислений в которой содержит ненужный перебор. Мы выделим те точки этого процесса, где перебор бесполезен и ведет к неэффективности.</p>
<p>Рассмотрим двухступенчатую функцию на рис. [pic:func_step]. Связь между <span class="math inline">\(X\)</span> и <span class="math inline">\(Y\)</span> можно определить с помощью следующих правил:</p>
<p><em>Правило 1:</em> если <span class="math inline">\(X &lt; 3\)</span>, то <span class="math inline">\(Y = 0\)</span>.</p>
<p><em>Правило 2:</em> если <span class="math inline">\(3 \leqslant X &lt; 6\)</span>, то <span class="math inline">\(Y = 2\)</span>.</p>
<p><em>Правило 3:</em> если <span class="math inline">\(6 \leqslant X\)</span>, то <span class="math inline">\(Y = 4\)</span>.</p>
<figure>
<embed src="pics/func_step.eps" /><figcaption>Двухступенчатая функция<span data-label="pic:func_step"></span></figcaption>
</figure>
<p>На Прологе это можно выразить с помощью бинарного отношения <code>f(X, Y)</code> так:</p>
<pre><code>    f(X, 0) :- X &lt; 3.          % Правило 1
    f(X, 2) :- 3 =&lt; X, X &lt; 6.  % Правило 2
    f(X, 4) :- 6 =&lt; X.         % Правило 3</code></pre>
<p>В этой программе предполагается, конечно, что к моменту начала вычисления <span>f(X, Y)</span> <span>X</span> уже конкретизирован каким&quot;=либо числом; это необходимо для выполнения операторов сравнения.</p>
<p>Мы проделаем с этой программой два эксперимента. Каждый из них обнаружит в ней свой источник неэффективности, и мы устраним оба этих источника по очереди, применив отсечение.</p>
<section id="эксперимент-1." class="level5">
<h5><span class="header-section-number">5.1.0.0.1</span> Эксперимент 1.</h5>
<p>Проанализируем, что произойдет, если задать следующий запрос:</p>
<pre><code>    ?- f(1, Y), 2 &lt; Y.</code></pre>
<p>При вычислении первой цели <span>f(1,Y)</span> <span>Y</span> конкретизируется нулем. Поэтому вторая цель становится такой:</p>
<pre><code>    2 &lt; 0.</code></pre>
<p>Она терпит неудачу, и поэтому и весь список целей также терпит неудачу. Это очевидно, однако перед тем, как признать, что такому списку целей удовлетворить нельзя, Пролог&quot;=система при помощи возвратов попытается проверить еще две бесполезные в данном случае альтернативы.</p>
<p>Три правила, входящие в отношение <span>f</span>, являются взаимоисключающими, поэтому успех возможен, самое большее, в одном из них. Следовательно, мы (но не Пролог“=система) знаем, что как только успех наступил в одном из них, нет смысла проверять остальные, поскольку они все равно обречены на неудачу. Для предотвращения бессмысленного перебора мы должны явно указать Пролог”=системе, что <span><strong>не нужно</strong></span> осуществлять возврат из этой точки. Мы можем сделать это при помощи конструкции отсечения. Отсечение записывается в виде символа &lt;&lt;<span>!</span>&gt;&gt;, который вставляется между целями и играет роль некоторой псевдоцели. Вот наша программа, переписанная с использованием отсечения:</p>
<pre><code>    f(X, 0) :- X &lt; 3, !.
    f(X, 2) :- 3 =&lt; X, X &lt; 6, !.
    f(X, 4) :- 6 =&lt; X.</code></pre>
<p>Символ &lt;&lt;<span>!</span>&gt;&gt; предотвращает возврат из тех точек программы, в которых он поставлен. Зададим вопрос:</p>
<pre><code>    ?- f(1, Y), 2 &lt; Y.</code></pre>
<p>Пролог&quot;=система породит ветвь дерева. Эта ветвь потерпит неудачу на цели <span>2 &lt; 0</span>. Система попытается сделать возврат, но вернуться она сможет не далее точки, помеченной в программе символом &lt;&lt;<span>!</span>&gt;&gt;. Альтернативные ветви, соответствующие правилу 2 и правилу 3, порождены не будут.</p>
<p>Новая программа, снабженная отcечениями, во всех случаях более эффективна, чем первая версия, в которой они отсутствуют. Неудачные варианты новая программа распознает всегда быстрее, чем старая.</p>
<p>Вывод: добавив отсечения, мы повысили эффективность. Если их теперь убрать, программа породит тот же результат, только на его получение она потратит, скорее всего, больше времени. Можно сказать, что в нашем случае после введения отсечений мы <span><strong>изменили только процедурную семантику</strong></span> программы, оставив при этом ее декларативную семантику в неприкосновенности. В дальнейшем мы покажем, что использование отсечения может также затронуть и <span><strong>декларативную семантику</strong></span> Пролог&quot;=программы.</p>
</section>
<section id="эксперимент-2." class="level5">
<h5><span class="header-section-number">5.1.0.0.2</span> Эксперимент 2.</h5>
<p>Проделаем теперь еще один эксперимент со второй версией нашей программы. Предположим, мы задаем вопрос:</p>
<pre><code>    ?- f(7, Y), Y = 4.</code></pre>
<p>Проанализируем, что произошло. Перед тем, как был получен ответ, система пробовала применить все три правила. Эти попытки породили следующую последовательность целей:</p>
<p><em>попытка применить правило 1:</em> <span class="math inline">\(7 &lt; 3\)</span> терпит неудачу, происходит возврат и попытка применить правило 2 (точка отсечения достигнута не была);</p>
<p><em>попытка применить правило 2:</em> <span class="math inline">\(3\leqslant 7\)</span> &lt;&lt;успех&gt;&gt;, но <span class="math inline">\(7 &lt; 6\)</span> терпит неудачу; возврат и попытка применить правило 3 (точка отсечения снова не достигнута);</p>
<p><em>попытка применить правило 3:</em> <span><span class="math inline">\(6\leqslant 7\)</span></span> — &lt;&lt;успех&gt;&gt;.</p>
<p>Приведенные этапы вычисления обнаруживают еще один источник неэффективности. Вначале выясняется, что <span>X &lt; 3</span> не является истиной (<span class="math inline">\(7 &lt; 3\)</span> терпит неудачу). Следующая цель — <span>3 =&lt; X</span> (<span class="math inline">\(3 \leqslant 7\)</span> — &lt;&lt;успех&gt;&gt;). Но нам известно, что если первая проверка неуспешна, то вторая обязательно будет успешной, так как второе — целевое утверждение является отрицанием первого. Следовательно, <span><strong>вторая проверка лишняя</strong></span> и соответствующую цель можно опустить. То же самое верно и для цели <span>6 =&lt; X</span> в правиле 3. Все эти соображения приводят к следующей, более экономной формулировке наших трех правил:</p>
<p>если <span class="math inline">\(X &lt; 3\)</span>, то <span class="math inline">\(Y = 0\)</span>;</p>
<p>иначе, если <span class="math inline">\(X &lt; 6\)</span>, то <span class="math inline">\(Y = 2\)</span>;</p>
<p>иначе <span class="math inline">\(Y = 4\)</span>.</p>
<p>Теперь мы можем опустить в нашей программе те условия, которые обязательно выполняются при любом вычислении. Получается третья версия программы:</p>
<pre><code>    f(X, 0) :- X &lt; 3, !.
    f(X, 2) :- X &lt; 6, !.
    f(X, 4).</code></pre>
<p>Эта программа дает тот же результат, что и исходная, но более эффективна, чем обе предыдущие. Однако что будет, если мы теперь удалим отсечения? Программа станет такой:</p>
<pre><code>    f(X, 0) :- X &lt; 3.
    f(X, 2) :- X &lt; 6.
    f(X, 4).</code></pre>
<p>Она может порождать различные решения, часть из которых неверны. Например:</p>
<pre><code>    ?- f( 1, Y).
         Y = 0,
         Y = 2,
         Y = 4.
 </code></pre>
<p>Важно заметить, что в последней версии, в отличие от предыдущей, отсечения затрагивают не только процедурное поведение, но <span><strong>изменяют</strong></span> также и <span><strong>декларативную семантику</strong></span> Пролог&quot;=программы.</p>
<p>Более точный смысл механизма отсечений можно сформулировать следующим образом:</p>
<blockquote>
<p>Назовем &lt;&lt;целью“=родителем&gt;&gt; ту цель, которая сопоставилась с головой предложения, содержащего отсечение. Когда в качестве цели встречается отсечение, такая цель сразу же считается успешной и при этом заставляет систему принять те альтернативы, которые были выбраны с момента активизации цели”=родителя до момента, когда встретилось отсечение. Все оставшиеся в этом промежутке (от цели&quot;=родителя до отсечения) альтернативы не рассматриваются.</p>
</blockquote>
<p>Чтобы прояснить смысл этого определения, рассмотрим предложение вида<br />
<code>    </code><span class="math inline">\(H\)</span> <span>:-</span> <span class="math inline">\(B_1\)</span><span>,</span> <span class="math inline">\(B_2\)</span><span>,</span> …<span>,</span> <span class="math inline">\(B_m\)</span><span>,</span> <span>!,</span> …<span>,</span> <span class="math inline">\(B_n\)</span><span>.</span><br />
Будем считать, что это предложение активизировалось, когда некоторая цель <span class="math inline">\(G\)</span> сопоставилась с <span class="math inline">\(H\)</span>. Тогда <span class="math inline">\(G\)</span> является целью“=родителем. В момент, когда встретилось отсечение, успех уже наступил в целях <span class="math inline">\(B_1\)</span>, …, <span class="math inline">\(B_m\)</span>. При выполнении отсечения это (текущее) решение <span class="math inline">\(B_1\)</span>, …, <span class="math inline">\(B_m\)</span> <span><strong>замораживается</strong></span> и все возможные оставшиеся альтернативы (возможные решения) больше не рассматриваются. Далее, цель <span class="math inline">\(G\)</span> связывается теперь с этим предложением: любая попытка сопоставить <span class="math inline">\(G\)</span> с головой какого”=либо другого предложения пресекается.</p>
<p>Применим эти правила к следующему примеру:</p>
<pre><code>    С :- Р, Q, R, !, S, Т, U.
    С :- V.
    А :- В, С, D.

    ?- А.</code></pre>
<p>Здесь <span>А</span>, <span>В</span>, <span>С</span>, <span>D</span>, <span>P</span> и т. д. имеют синтаксис предикатов. Отсечение повлияет на вычисление цели <span>С</span> следующим образом. Перебор будет возможен в списке целей <span>Р</span>, <span>Q</span>, <span>R</span>; однако как только точка отсечения будет достигнута, все альтернативные решения для этого списка изымаются из рассмотрения. Альтернативное предложение, входящее в <span>С</span>:</p>
<pre><code>    С :- V.</code></pre>
<p>также не будет учитываться. Тем не менее, перебор будет возможен в списке целей <span>S</span>, <span>T</span>, <span>U</span>. Цель&quot;=родитель предложения, содержащего отсечения, — это цель <span class="math inline">\(C\)</span> в предложении</p>
<pre><code>    А :- В, С, D.</code></pre>
<p>Поэтому отсечение повлияет только на цель <span>С</span>. С другой стороны, оно будет невидимо из цели <span>А</span>. Таким образом, автоматический перебор все равно будет происходить в списке целей <span>В</span>, <span>С</span>, <span>D</span>, вне зависимости от наличия отсечения в предложении, которое используется для достижения <span>С</span>.</p>
</section>
<section id="примеры-использующие-отсечение" class="level3">
<h3><span class="header-section-number">5.1.1</span> Примеры, использующие отсечение</h3>
<section id="вычисление-максимума." class="level5">
<h5><span class="header-section-number">5.1.1.0.1</span> Вычисление максимума.</h5>
<p>Процедуру нахождения наибольшего из двух чисел можно запрограммировать в виде отношения <span>max(X, Y, М)</span>, где <span>М = X</span>, если <span>X</span> больше или равен <span>Y</span>, и <span>М</span> есть <span>Y</span>, если <span>X</span> меньше <span>Y</span>. Это соответствует двум таким предложениям:</p>
<pre><code>    max(X, Y, X) :- X &gt;= Y.
    max(X, Y, Y) :- X &lt; Y.</code></pre>
<p>Эти правила являются взаимно исключающими. Если выполняется первое, второе обязательно потерпит неудачу. Если неудачу терпит первое, второе обязательно должно выполниться. Поэтому возможна более экономная формулировка, использующая понятие иначе:</p>
<p>если <span class="math inline">\(X \geq Y\)</span>, то <span class="math inline">\(M = X\)</span>,</p>
<p>иначе <span class="math inline">\(M = Y\)</span>.</p>
<p>На Прологе это записывается при помощи отсечения:</p>
<pre><code>    max( X, Y, X) :- X &gt;= Y, !.
    max( X, Y, Y).</code></pre>
</section>
<section id="проверка-принадлежности-списку-порождающая-единственное-решение." class="level5">
<h5><span class="header-section-number">5.1.1.0.2</span> Проверка принадлежности списку, порождающая единственное решение.</h5>
<p>Для того чтобы узнать, принадлежит ли <span>X</span> списку <span>L</span>, использовано отношением <span>in/2</span>, и программа была следующей:</p>
<pre><code>    in(R, [R | Т]).
    in(R, [H | Т]) :- in(R, T).</code></pre>
<p>Эта программа дает &lt;&lt;недетерминированный&gt;&gt; ответ: если <span>R</span> встречается в списке несколько раз, то будет найдено <span><strong>каждое</strong></span> его вхождение. Следующая программа исправляет этот &lt;&lt;недостаток&gt;&gt; и выдает только одно решение.</p>
<pre><code>    in(R, [R | Т]) :- !.
    in(R, [H | Т]) :- in(R, T).</code></pre>
</section>
</section>
<section id="другие-предикаты-управления-выводом" class="level3">
<h3><span class="header-section-number">5.1.2</span> Другие предикаты управления выводом</h3>
<p>В языке программирования Пролог существуют еще несколько предикатов и логическая связка, используемые для управления процессом вывода.</p>
<dl>
<dt><span><span class="math inline">\(\backslash\)</span>+</span></dt>
<dd><p>Логическая операция отрицания &lt;&lt;<span class="math inline">\(\neg\)</span>&gt;&gt; имеет, с одной стороны, противоположное истинностное значение истинностному значению предиката, который следует за этой операцией, с другой стороны, <span><code>\+</code> G</span> ложен, если Пролог для <span>G</span> смог построить вывод.</p>
</dd>
<dt>fail/0</dt>
<dd><p>Этот предикат обозначает &lt;&lt;ложь&gt;&gt;, т. е. если он включен как подцель тела правила или запроса, то это правило и запрос никогда не будут доказаны. Предикат используется для организации перебора всех решений в части программы, где задана цель <code>init/0</code>, например, программа</p>
<pre><code>    number(1). number(2). number(3).
    number(4). number(5). number(6).

    init:-
        number(X), number(Y), write(X),
        write(Y), fail.
    :- initialization(init).</code></pre>
<p>выведет на экран все двузначные комбинации цифр от 1 до 6. Если убрать <span>fail</span> из запроса, то будет выведена только одна комбинация.</p>
</dd>
<dt>nonvar/1</dt>
<dd><p>В ISO-Prolog предикат <span>nonvar/1</span> истинный, если переменная&quot;=аргумент к этому моменту уже приобрела свое значение, и ложный — в обратном случае.</p>
</dd>
<dt>var/1</dt>
<dd><p>Предикат <span>var/1</span> истинный тогда и только тогда, когда предикат <span>nonvar/1</span> ложный.</p>
</dd>
</dl>
<p>Пусть дано уравнение <span class="math display">\[y=k\cdot x,\]</span> причем комбинации значений переменных и их отсутствия могут быть любыми. Предложить программу, определяющую значения переменных, которые неизвестны, либо выдать на экран сообщение о том, что решение найти невозможно. Равенство должно сохраняться.</p>
<p>Решение задачи (программа) будет строиться для каждого набора переменных, всего их <span class="math inline">\(2^3=8\)</span><a href="#fn39" class="footnoteRef" id="fnref39"><sup>39</sup></a>, но некоторые могут быть объединены.</p>
<pre><code>    solve(Y, K, X) :-
        nonvar(K), nonvar(X), !,
            % Y может быть как связанным, так и
            % свободным.
        Y is K * X.
    solve(Y, K, X) :-
        nonvar(Y), nonvar(X),
        X &lt;&gt; 0,
        K is Y / X.
    solve(Y, K, X) :-
        nonvar(Y), nonvar(X),
        X = 0,
        write(&#39;Нет решений&#39;), nl.
    solve(Y, K, X) :-
        nonvar(Y), nonvar(K),
            % сократим себе программу!
        solve(Y, X, K).
    solve(Y, K, X) :-
        var(X), var(K), nonvar(X)
        write(&#39;Множество решений&#39;), nl,
        format(&#39;X = Y / ~w&#39;, [K]), nl.
    ........% и т. д.</code></pre>
</section>
</section>
<section id="лабораторная-работа-2-списки" class="level2">
<h2><span class="header-section-number">5.2</span> Лабораторная работа 2: Списки</h2>
<section id="задание.-1" class="level5">
<h5><span class="header-section-number">5.2.0.0.1</span> Задание.</h5>
<p>В pаботе тpебуется реализовать <span><strong>по крайней мере два отношения</strong></span> из индивидуального задания в виде правил и фактов на языке Пpолог. К программе требуется выполнить ряд запросов, объяснить выдаваемые системой результаты: дать процедурную и декларативную интерпретацию определенных отношений.</p>
<section id="цель-работы.-1" class="level6">
<h6><span class="header-section-number">5.2.0.0.1.1</span> Цель работы.</h6>
<p>Приобрести навыки рекурсивной обработки рекурсивных структур данных; научиться интерпретировать (переводить на естественный язык) Пролог&quot;=программы.</p>
</section>
<section id="время-работы.-1" class="level6">
<h6><span class="header-section-number">5.2.0.0.1.2</span> Время работы.</h6>
<p>На выполнение работы отводится два академических часа.</p>
</section>
<section id="индивидуальные-задания-1" class="level6">
<h6><span class="header-section-number">5.2.0.0.1.3</span> Индивидуальные задания</h6>
<ol>
<li><p>Сформировать новый список из всех четных элементов исходного списка.</p></li>
<li><p>Опpеделить, является ли один список подсписком дpугого.</p></li>
<li><p>Удалить все вхождения заданного элемента из списка.</p></li>
<li><p>Hаписать пpогpамму пословного (подстрочного) пеpевода пpедложения, представленного в виде списка слов, с английского на фpанцузский (или любой другой) язык.</p></li>
<li><p>Сфоpмиpовать новый список, в котоpом каждый элемент исходного списка входит в новый список два pаза подряд.</p></li>
<li><p>Слить два упоpядоченных списка в один, сохpанив упоpядоченность.</p></li>
<li><p>Опpеделить, являются ли два заданных элемента соседними в списке.</p></li>
<li><p>Опpеделить последний элемент списка.</p></li>
<li><p>Подсчитать количество элементов списка.</p></li>
<li><p>Упорядочить список методом пузырька.</p></li>
<li><p>Упорядочить список методом вставки.</p></li>
<li><p>Упорядочить список методом быстрой сортировки.</p></li>
<li><p>Заменить элемент списка на заданное значение.</p></li>
<li><p>Определить все перестановки элементов списка.</p></li>
<li><p>Найти сумму элементов списка, стоящих на нечетных местах в списке.</p></li>
<li><p>Инвертировать список.</p></li>
<li><p>Добавить элемент в конец списка.</p></li>
<li><p>Удалить два последних элемента списка.</p></li>
<li><p>Найти максимальный элемент списка.</p></li>
<li><p>В заданном списке выделить подсписок, содержащий <span class="math inline">\(N\)</span> элементов с начала списка.</p></li>
<li><p>В заданном списке выделить подсписок, начиная с <span class="math inline">\(N\)</span>-го элемента списка и кончая <span class="math inline">\(K\)</span>-м элементом этого же списка.</p></li>
<li><p>Определить сумму отрицательных элементов списка, стоящих на четных местах.</p></li>
<li><p>Удалить из списка максимальный элемент.</p></li>
<li><p>Выполнить циклический сдвиг списка на заданное число элементов. Например, результат сдвига списка на два элемента есть список .</p></li>
<li><p>Определить предикат <span>code(Х, List)</span>, где <span>Х</span> — целое неотрицательное число <span>(0</span><span class="math inline">\(\leq\)</span><span>X</span><span class="math inline">\(\leq\)</span><span>9)</span>, а <span>List</span> — это последовательность единичек, число которых равно <span>Х</span>. Например, <span>code(3, L)</span> дает <span>L=[1, 1, 1]</span>, а <span>code(0, L)</span> дает <span>L=[]</span>.</p></li>
<li><p>Определить двуаргументный предикат <span>translate(С1, С2)</span> для перевода списка цифр в список соответствующих слов. Например, истинным будет следующее высказывание<br />
<span>translate([3, 4, 8], [’три’, ’четыре’, ’восемь’])</span>.</p></li>
</ol>
</section>
</section>
<section id="методические-указания-к-лабораторной-работе-1" class="level4 unnumbered">
<h4>Методические указания к лабораторной работе</h4>
<p>Сначала необходимо понять, между какими объектами задается отношение, его арность (все то же самое, как и в предыдущей лабораторной работе). Далее:</p>
<ol>
<li><p>Сначала определить частный случай (самый простой) отношения (в терминах доказательства теорем методом математической индукции) <span class="math inline">\(P(0, \ldots)\)</span>, базу индукции.</p></li>
<li><p>Затем в предположении, что условие базы индукции ложно, определить для остальных случаев <span class="math inline">\( P(n, \ldots) \to P(n+1, \ldots)\)</span>.</p></li>
</ol>
<p>Задача — определить последний элемент списка.</p>
<p>Отношение задается между списками и элементами списка. Арность отношения — 2.</p>
<p>Частный случай — одноэлементный список (пустой список не имеет последнего элемента). Предикат интерпретируется следующим образом: &lt;&lt;Последний элемент одноэлементного списка и есть этот единственный элемент&gt;&gt;.</p>
<pre><code>    last([X], X).</code></pre>
<p>Пусть список содержит не меньше одного элемента (отрицание предыдущего утверждения), тогда последний элемент списка — это последний элемент его хвоста.</p>
<pre><code>    last([_ | T], X) :- last(T, X).</code></pre>
<p><em>Декларативная интерпретация</em>: Последний элемент одноэлементного списка и есть требуемый элемент (решение). Если список содержит более одного элемента, то последний элемент этого списка — это последний элемент хвоста.</p>
<p><em>Процедурная интерпретация</em>: Чтобы найти последний элемент списка, нужно: если список содержит лишь один элемент, то предъявить в качестве второго аргумента отношения (результата) <span>last/2</span> первый элемент списка. Иначе, если в списке содержится более одного элемента, то: (a) найти последний элемент хвоста и (б) предъявить его как результат.</p>
<p>Что является причиной неэффективности системы программирования Пролог?</p>
<p>Какова семантика предиката &lt;&lt;отсечение&gt;&gt;?</p>
<p>Каково будет истинностное значение запроса <code>?- var(X).</code>?</p>
<p>Какова процедурная интерпретация правила <code>A :- Q,W,E,!, R,T,Y.</code>?</p>
<p>Возымеет ли действие отсечение в запросе <code>fail,!.</code>?</p>
</section>
</section>
</section>
<section id="предикаты-с-побочными-действиями" class="level1">
<h1><span class="header-section-number">6</span> Предикаты с побочными действиями</h1>
<p>Пролог обладает возможностью не только определять условия, когда значения предикатов истинны, но и выполнять некоторую &lt;&lt;полезную&gt;&gt; работу, такую как получать значение с клавиатуры, выводить сообщения на экран, складывать и вычитать и т. д. Предикаты, выполняющие эти действия, делятся на два класса: <span><em>арифметические</em></span> и так называемые <span><em>предикаты с побочными действиями</em></span>.</p>
<p>Для выполнения арифметических операций используется предикат &lt;&lt;<span>is/2</span>&gt;&gt;.</p>
<p>Решение квадратного уравнения &lt;&lt;по&quot;=прологовски&gt;&gt;. Пусть даны <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span>, <span class="math inline">\(c\)</span> такие, что <span class="math display">\[ax^2+bx+c=0.\]</span> Найти такие значения <span class="math inline">\(x\)</span>, чтобы равенство сохранялось<a href="#fn40" class="footnoteRef" id="fnref40"><sup>40</sup></a>.</p>
<pre><code>    sqeq(A, B, C, X) :-
        D is B * B - 4 * A * C,
        sd(A, B, C, D, X).
    sd(A, B, C, D, X) :-
        D &lt; 0,
        write(&#39;Решения в области&#39;), nl,
        write(&#39;комплексных чисел.&#39;), nl,
        !, fail.
    sd(A, B, C, D, X) :-
        D = 0,
        write(&#39;Четные корни&#39;), nl,
        X is - B / (2 * A).
    sd(A, B, C, D, X) :-
        D &gt; 0,
        X is ( -B + sqrt(D) ) / (2 * A).
    sd(A, B, C, D, X) :-
        D &gt; 0,
        X is ( -B - sqrt(D) ) / (2 * A).</code></pre>
<p>Кроме арифметических операций в программе использованы предикаты с побочными действиями <span>write/1</span> и <span>nl/0</span>. Кроме этих необходимо выделить следующие предикаты для ввода данных в GNU-Prolog:</p>
<dl>
<dt>read_token/1</dt>
<dd><p>вводит с клавиатуры лексическую единицу до нажатия клавиши &lt;&lt;Enter&gt;&gt;. Вариант лексической единицы выдается в виде атома. Например, если пользователь с клавиатуры вводит &lt;&lt;10&gt;&gt;, то переменная аргумента конкретизируется атомом &lt;&lt;10&gt;&gt;, если пользователь вводит &lt;&lt;F&gt;&gt;, то аргумент конкретизируется атомом &lt;&lt;<code>var(‘F‘)</code>&gt;&gt;.</p>
</dd>
<dt>read_term/1</dt>
<dd><p>или просто <code>read/1</code> позволяет вводить с клавиатуры терм: пользователь должен ввести синтаксически правильную конструкцию, заканчивающуюся точкой &lt;&lt;<code>.</code>&gt;&gt;. Пример:</p>
<pre><code>?- read(A).
a(s),b(k).    % Вводит пользователь.

A = (a(s),b(k))

yes.</code></pre>
</dd>
</dl>
<p>Для отображения результатов вывода удобно использовать предикат <code>format/2</code>. Предикат выполняет аналогичную функцию формирования сообщения из индивидуальных составляющих и вывода на экран (или в файл), что и функция <code>printf</code>. Спецификация предиката — <code>format(Format, Arguments)</code>, где <code>Format</code> — это форматная строка, <code>Arguments</code> — список аргументов, которые будут подставлены в форматную строку. Например, запрос</p>
<pre><code>  ?- A=8, B=c(Y), E=&#39;test&#39;,
      format(&#39;A=~w, B=~w, E=~w ~n !!! &#39;,
         [A,B,E]).
  A=8, B=c(_22), E=test
   !!!

  A = 8,
  B = c(Y),
  E = test.

  yes.</code></pre>
<p>Здесь <code>~w</code> обозначает печать аргумента при помощи средств предиката <code>write/1</code>, <code>~n</code> — перевод строки. В этом примере терм <code>B=c(Y)</code> распечатался как <code>B=C_22</code>: машине вывода Пролога все равно, как называются переменные, которые вводятся процедурой поиска логического вывода Пролог, имена порождаются последовательным перебором чисел.</p>
<section id="базы-данных-в-прологе" class="level2">
<h2><span class="header-section-number">6.1</span> Базы данных в Прологе</h2>
<p>Очень коротко рассмотрим возможности Пролога вести базу данных. <span><em>Базой данных</em></span> Пролога называется <span><strong>изменяемый</strong></span> набор фактов (а также правил)<a href="#fn41" class="footnoteRef" id="fnref41"><sup>41</sup></a>. Чтобы набор фактов был изменяемым, надо его таковым объявить:</p>
<pre><code>        % группа: обозначение, название
:- dynamic(group/2).
        % студент: номер зачетки, группа, Ф. И. О.
:- dynamic(student/3).</code></pre>
<p>Как нетрудно догадаться, запросы к базе данных в Прологе делаются так же, как и к другим правилам и фактам (предполагается, что база данных Прологу известна):</p>
<pre><code>     % в какой группе учится студент
     % Иванов Иван
?- group(X),
     student(_, X, &#39;Иванов Иван&#39;).
     X = &#39;02421&#39;,
     % Выдать всех студентов указанной группы
?- group(X, &#39;02421&#39;),
         student(_, X, Y).
     X = &#39;02421&#39;, Y = &#39;Иванов Иван&#39;;
     . . . . .
 </code></pre>
<p>Добавлять и удалять факты в базе данных можно с помощью предикатов с побочными действиями <span>assert/1</span> и <span>retract/1</span>:</p>
<pre><code>    add_student(Group, Num, Name) :-
        assert(student(Num, Group, Name)).</code></pre>
<p>Замечание: все аргументы предиката <span>assert/1</span> должны быть <span><strong>конкретизированными</strong></span> переменными.</p>
<pre><code>    del_student(Group, Num, Name) :-
        retract(student(Num, Group, Name)).</code></pre>
<p>Предыдущее замечание не имеет силы для <span>retract/1</span>, однако он будет истинным, если удалит первый попавшийся факт, удовлетворяющий ограничениям, указанным значениями переменных.</p>
<p>Существуют разновидности предиката добавления факта в базу данных: <span>asserta/1</span> и <span>assertz/1</span>, которые добавляют факты, соответственно, в начало или конец существующего списка фактов.</p>
<p>Базу данных можно загрузить из текстового файла при помощи предиката <span>consult/1</span>, причем выполнить его надо после объявления предиката динамическим.</p>
</section>
<section id="лабораторная-работа-3-базы-данных" class="level2">
<h2><span class="header-section-number">6.2</span> Лабораторная работа 3: Базы данных</h2>
<section id="задание.-2" class="level5">
<h5><span class="header-section-number">6.2.0.0.1</span> Задание.</h5>
<p>Необходимо разработать <span><strong>интерактивную</strong></span> программу ведения базы данных. База данных должна содержать <span><strong>по крайней мере одно</strong></span> отношение &lt;&lt;один“=ко”=многим&gt;&gt; (<span class="math inline">\(1\)</span>:<span class="math inline">\(N\)</span>) или &lt;&lt;многие“=ко”=многим&gt;&gt; (<span class="math inline">\(N\)</span>:<span class="math inline">\(M\)</span>). Кроме того, необходимо реализовать выполнение <span><strong>запроса</strong></span>, демонстрирующего эту связь, а также корректно реализовать функцию удаления записей.</p>
</section>
<section id="цель-работы.-2" class="level5">
<h5><span class="header-section-number">6.2.0.0.2</span> Цель работы.</h5>
<p>Ознакомиться с вариантом реализации принципа реляционных баз данных в виде Пролог“=программы. Научиться пользоваться предикатами с побочными действиями, а также управлять процессом поиска решения Пролог”=системой.</p>
</section>
<section id="время-работы.-2" class="level5">
<h5><span class="header-section-number">6.2.0.0.3</span> Время работы.</h5>
<p>На выполнение работы отводится четыре академических часа.</p>
</section>
<section id="методические-указания-к-лабораторной-работе-2" class="level4 unnumbered">
<h4>Методические указания к лабораторной работе</h4>
<p>Непривычному к логическому программированию студенту довольно трудно реализовать меню на Прологе, однако, это сделать легче, чем в каком&quot;=либо другом языке программирования. Внимательно разберите следующий пример:</p>
<pre><code>    menu_do(1) :-
        write(&#39;Приступим к добавлению записи...&#39;),
        .......
    menu_do(0).

    main :-
        repeat,
        write(&#39;Меню программы:&#39;), nl,
        write(&#39;1 - добавление ...), nl,
        .....
        write(&#39;0 - выход из программы&#39;), nl,
        write(&#39; &gt; &#39;), read_int(I),
        menu_do(I),
        I = 0, !; true.</code></pre>
<section id="индивидуальные-задания." class="level5">
<h5><span class="header-section-number">6.2.0.0.4</span> Индивидуальные задания.</h5>
<p>Разработайте программу управления базой данных в следующих предметных областях<a href="#fn42" class="footnoteRef" id="fnref42"><sup>42</sup></a>.</p>
<ol>
<li><p>Институт (деканаты, кафедры, учебный отдел).</p>
<ul>
<li><p>Студенты: паспортные данные, адрес, дата зачисления, номер приказа, факультет, группа, является ли старостой, кафедра (специализация), изучаемые (изученные) предметы, оценки, задолженности, стипендия.</p></li>
<li><p>Учебные курсы: название, факультет(ы), групп(ы), кафедра, семестр(ы), форма отчетности, число часов.</p></li>
<li><p>Преподаватели: паспортные данные, адрес, телефон, фотография, кафедра, должность, ученая степень, начальник (зав. кафедрой), предмет(ы), число ставок, зарплата.</p></li>
</ul></li>
<li><p>Библиотека института.</p>
<ul>
<li><p>Книги: авторы, название, раздел УДК, раздел (техническая, общественно&quot;=политическая и т. п.), место и год издания, издательство, количество страниц, иллюстрированность, цена, дата покупки, номер сопроводительного документа (чек, счет/накладная), вид издания (книги, учебники, брошюры, периодические издания), инвентарный номер (есть только для книг и некоторых учебников), длительность использования читателями (год, две недели, день), электронная версия книги или ее реферата (отсканированный текст).</p></li>
<li><p>Читатели: номер читательского билета, ФИО, год рождения, адрес, дата записи, вид (студент, аспирант, преподаватель, сотрудник), курс, номер группы, названия взятых книг и даты их выдачи.</p></li>
</ul></li>
<li><p>Отдел кадров и бухгалтерия некоторой компании.</p>
<ul>
<li><p>Сотрудники: ФИО, паспортные данные, фотография, дом. и моб. телефоны, отдел, комната, раб. телефоны (в том числе местный), подчиненные сотрудники, должность, тип(ы) работы, задание(я), проект(ы), размер зарплаты, форма зарплаты (почасовая, фиксированная).</p></li>
<li><p>Отделы: название, комната, телефон(ы), начальник, размер финансирования, число сотрудников.</p></li>
<li><p>Проекты: название, дата начала, дата окончания, размер финансирования, тип финансирования (периодический, разовый), задачи и их исполнители, структура затрат и статьи расходов.</p></li>
</ul></li>
<li><p>Отдел поставок некоторого предприятия:</p>
<ul>
<li><p>Поставщики: название компании, ФИО контактного лица, расчетный счет в банке, телефон, факс, поставляемое оборудование (материалы), даты поставок (по договорам и реальные), метод и стоимость доставки.</p></li>
<li><p>Сырье: тип, марка, минимальный запас на складе, время задержки, цена, продукты, при производстве которых используется, потребляемые объемы (необходимый, реальный, на единицу продукции).</p></li>
</ul></li>
<li><p>Технологический отдел некоторого предприятия:</p>
<ul>
<li><p>Производственные процессы: продукты, объемы их производства, необходимые материалы, количества разных видов материалов на единицу продукции, отходы производства; используемое оборудование и его тип, даты ввода оборудования в строй, сроки амортизации, производительность оборудования; человеческие ресурсы (сколько всего и сколько по производству единицы продукции — сколько необходимо и сколько реально).</p></li>
<li><p>Материалы: тип (категория), марка, является ли сырьем (или производится на предприятии), потребляемые объемы (в том числе на единицу конечной продукции), в рамках каких технологических процессов используется, цена.</p></li>
</ul></li>
<li><p>Отдел продаж некоторой фирмы.</p>
<ul>
<li><p>Клиенты: название компании, ФИО контактного лица, адрес выставления счета, адрес доставки, телефон, факс.</p></li>
<li><p>Заказы: тип заказа (покупка, гарантийный ремонт, негарантийный ремонт), общая стоимость, скидка, товар(ы), их изготовители, модели (марки), серийные номера, описание неисправностей, необходимые ресурсы, клиент, дата получения заказа, срок завершения, дата выставления счета и его оплаты, метод оплаты, дата поставки, метод и стоимость доставки.</p></li>
<li><p>Ресурсы: ФИО, отдел(ы) и телефон(ы) исполнителя(ей), число рабочих часов для выполнения заказа, ставка зарплаты, ответственный за выполнение заказа, необходимое оборудование и расходные материалы, их количество и стоимость, а также наличие материалов.</p></li>
</ul></li>
<li><p>Магазин (внутренний учет).</p>
<ul>
<li><p>Клиенты: юридическое или физическое лицо, ФИО, адрес, телефон, адрес выставления счета, вид и номер карточки, факс.</p></li>
<li><p>Продажи: наименования, модели (марки) и серийные номера товаров, поставка из магазина или со склада, количество и общая стоимость товаров, размер скидки, тип скидки, форма оплаты (наличными, оплата счета, по карточке), необходимость доставки, стоимость и тип доставки, адрес доставки.</p></li>
<li><p>Товары: категория, модель, название производителя, адрес производителя, цена, количество в магазине и на складе.</p></li>
</ul></li>
<li><p>Электронный магазин (информация для клиентов).</p>
<ul>
<li><p>Товары: категория, модель, производитель, цены (в том числе средняя и минимальная), есть ли в наличии, описание, характеристики, внешний вид; магазины, где можно купить товар, их телефоны и адреса; аксессуары, их цены и где их купить.</p></li>
<li><p>Магазины: название, компания&quot;=владелец, ее юридический адрес и home-site, контактные телефоны, адрес, схема проезда, эмблема; товары и цены на них; рекламная информация: некоторые товары с фотографиями, описаниями и ценами, основные отделы.</p></li>
</ul></li>
<li><p>Пункт проката видеозаписей (внутренний учет).</p>
<ul>
<li><p>Видеокассеты: идентификационный номер видеокассеты, тип видеокассет, дата его создания, компания&quot;=поставщик, число штук данного типа (общее, в магазине, выдано в настоящее время, выдано всего, выдано в среднем за месяц), общая длительность записей; записи видеокассет: название, длительность, категория, год выпуска и производитель (оригинала).</p></li>
<li><p>Клиенты: ФИО, паспортные данные, адрес, телефон; заказы, т. е. взятые видеокассеты (сейчас и в прошлом): номер, дата выдачи, дата возвращения, общая стоимость заказа.</p></li>
</ul></li>
<li><p>Пункт проката видеозаписей (информация для клиентов).</p>
<ul>
<li><p>Видеокассеты: краткое описание, внешний вид (этикетка), марка (пустой) видеокассеты, цена за единицу прокатного времени (например: 1 день, 3 дня, неделя), есть ли в наличии, общая длительность записей; записи на видеокассете: название, длительность, жанр (категория), тема, год и страна выпуска (оригинала), кинокомпания, описание, актеры, режиссер.</p></li>
<li><p>Заказы: идентификационные номера и названия выданных видеокассет, дата выдачи, дата возвращения (продления), общая стоимость заказа, возвращены ли кассеты заказа.</p></li>
</ul></li>
<li><p>Кинотеатры (информация для зрителей).</p>
<ul>
<li><p>Фильмы: название, описание, жанр (категория), длительность, популярность (рейтинг, число проданных билетов в России и в мире), показывается ли сейчас (сегодня, на текущей неделе), в каких кинотеатрах показывается, цены на билеты (в том числе средние).</p></li>
<li><p>Кинотеатры: название, адрес, схема проезда, описание, число мест (в разных залах, если их несколько), акустическая система, широкоэкранность, фильмы и цены на них: детские и взрослые билеты в зависимости от сеанса (дневной, вечерний и т. п.) и от категории мест (передние, задние и т. п.); сеансы показа фильмов (дата и время начала).</p></li>
</ul></li>
<li><p>Ресторан (информация для посетителей).</p>
<ul>
<li><p>Меню: дневное/вечернее, список блюд по категориям.</p></li>
<li><p>Блюда: цена, название, вид кухни, категории (первое, второе и т. п.; мясное, рыбное, салат и т. п.), является ли вегетарианским, компоненты блюда, время приготовления, есть ли в наличии.</p></li>
<li><p>Компоненты блюд: тип (гарнир, соус, мясо и т. п.), калорийность, цена, рецепт, время приготовления, есть ли в наличии, ингредиенты (продукты) и их расходы на одну порцию.</p></li>
</ul></li>
<li><p>Аналитический отдел некоторой компании (поиск и анализ публикаций).</p>
<ul>
<li><p>Категории: название, тип (область исследований, область приложений и т. п.), родительская категория, дочерние категории, связанные по смыслу категории (с пояснениями о связях), найденные публикации.</p></li>
<li><p>Публикации: название, тип (газетная, книжная, веб и т. п.), название, тип, адрес и телефон источника (газета, книга, сайт и т. п.), выходные данные (date-line), язык, реферат, ключевые слова, категории (с указанием степени уверенности отнесения к ним), текст и его тип (обычный, DOC, HTML, отсканированные картинки и т. п.), обзор.</p></li>
<li><p>Задачи: тип задачи (классификация или поиск), сотрудник (создавший категорию или нашедший публикацию, ответственный за категорию или публикацию и т. п.), завершена ли работа над задачей.</p></li>
</ul></li>
<li><p>Аналитический отдел некоторой компании (анализ рынка технологий, например по публикациям, см. п.13).</p>
<ul>
<li><p>Организация: название, тип (промышленная, финансовая, торговая, исследовательская и т. п.), категория(и), организация&quot;=владелец (акционеры), страна, контактная информация; договорные отношения с другими организациями.</p></li>
<li><p>Технология (продукт): название, категория(и), организация&quot;=разработчик и производитель(и), использующие организации.</p></li>
<li><p>Человек: фамилия, имя, тип (начальник, менеджер, создатель технологии и т. п.), организация(и), в которой работает, контактная информация.</p></li>
</ul></li>
</ol>
<p>В чем основное отличие предикатов &lt;&lt;<code>is</code>&gt;&gt; и &lt;&lt;<code>=</code>&gt;&gt;?</p>
<p>Какая директива объявляет предикат динамическим?</p>
<p>В каком случае выполнение <code>retract(_)</code> будет успешным?</p>
<p>Дайте декларативную интерпретацию запроса <code>retract(_), fail.</code></p>
</section>
</section>
</section>
</section>
<section id="поиск-решения-на-основе-перебора" class="level1">
<h1><span class="header-section-number">7</span> Поиск решения на основе перебора</h1>
<p>Иногда приходится сталкиваться с задачами, эффективный алгоритм решения которых очевидным образом реализовать не удается, либо нет достаточно времени на анализ свойств задачи и поиск подходящего алгоритма. К таким задачам относятся, например, <em>задачи с удовлетворением ограничений</em><a href="#fn43" class="footnoteRef" id="fnref43"><sup>43</sup></a>. Такие задачи являются математическими проблемами, определенными на конечном наборе объектов, чьи значения должны удовлетворять ряду ограничений, выраженных в виде неравенств и логических выражений. Исследования в области решения задач CSP ведутся достаточно давно, и по сей день актуальность этих исследований только повышается.</p>
<p>К задачам CSP сводятся многие задачи искусственного интеллекта, в частности планирование действий. Задачи удовлетворения ограничений довольно часто демонстрируют большую комбинаторную сложность, и практически для каждой индивидуальной задачи строятся собственные варианты эвристических алгоритмов<a href="#fn44" class="footnoteRef" id="fnref44"><sup>44</sup></a> их решения. Примеры известных задач — &lt;&lt;Восемь ферзей&gt;&gt;, &lt;&lt;Раскраска карты&gt;&gt;, &lt;&lt;Судоку&gt;&gt;, &lt;&lt;Поиск выполняющего набора&gt;&gt;, &lt;&lt;Составление расписания вуза&gt;&gt;.</p>
<p>Формально задачи CSP определяются следующим образом. Заданы вектор переменных <span class="math inline">\(\vec{V}=\langle v_1, v_2, \ldots, v_n\rangle\)</span>, где <span class="math inline">\(n\)</span> — количество переменных (натуральное); множество множеств <span class="math inline">\(D=\{ d_1, d_2, \ldots,\)</span> <span class="math inline">\(d_n\}\)</span>, где <span class="math inline">\(d_i\)</span> — непустое множество значений (домен), которые может принимать переменная <span class="math inline">\(v_i\)</span>, <span class="math inline">\(i=1,2,\ldots,n\)</span>. Задается также логическое условие <span class="math inline">\(P(\vec{V})=P(v_1,v_2,\ldots,v_n)\)</span>, которое истинно, если значения, присвоенные переменным <span class="math inline">\(v_i\)</span>, соответствуют условиям правильной комбинации. Например, для задачи &lt;&lt;Восемь ферзей&gt;&gt; <span class="math inline">\(P(\vec{V})\)</span> истинно, если все ферзи, расставленные на доске, не бьют друг друга. Иногда говорят о системе ограничений и о таких значениях переменных, при которых все ограничения выполняются (истинны). Систему ограничений можно записать как конъюнкцию индивидуальных ограничений, т. е. свести опять же к единому логическому условию <span class="math inline">\(P(\vec{V})\)</span>.</p>
<section id="алгоритм-британского-музея" class="level2">
<h2><span class="header-section-number">7.1</span> Алгоритм &lt;&lt;Британского музея&gt;&gt;</h2>
<p>Одним из простых алгоритмов, решающих задачи CSP, является алгоритм &lt;&lt;Британского музея&gt;&gt;<a href="#fn45" class="footnoteRef" id="fnref45"><sup>45</sup></a>. Алгоритм реализует самый общий подход в задачах поиска решения на основе последовательной проверки всех возможностей (одну за одной), начиная с самых простых решений.</p>
<p>Алгоритм реализует концептуальный, а не практический подход, оперируя огромным количеством возможных альтернатив. В частности, в теории он представляет способ найти самую короткую программу, которая решает конкретную задачу. Например, можно сгенерировать все возможные программы длиной в один символ. Проверить каждую программу, решает ли она эту задачу<a href="#fn46" class="footnoteRef" id="fnref46"><sup>46</sup></a>. Если среди односимвольных программ не найдено программы, решающей задачу, перейти к просмотру программ длиной в два символа, затем в три и т. д. В теории такой подход позволяет найти самую короткую программу, однако на практике такой перебор занимает недопустимо большое время вычислений (для многих задач больше, чем возраст Вселенной).</p>
<p>Название данный алгоритм получил ввиду высказывания Аллена Ньювэлла, Дж. С. Шоу и Герберта А. Симона в 1958 году: &lt;&lt;... Вполне уместно предположить, что если посадить обезьян за печатные машинки, можно через некоторое время воспроизвести все книги в известном Британском музее&gt;&gt; в Лондоне.</p>
<p>Несмотря на всю идеалистичность подхода для задач небольшой размерности, алгоритм вполне пригоден. Для начала, конечно, нет необходимости порождать программы, достаточно порождать варианты значений переменных <span class="math inline">\(v_i\)</span>, затем проверять выполнимость <span class="math inline">\(P(\vec{V})\)</span>. Рассмотрим пример задачи:</p>
<p>Разработать программу поиска списка счастливых билетов, состоящих из шести цифр. Подсчитать их количество.</p>
<pre><code>    num(X) :- member(X, [0,1,2,3,4,5,6,7,8,9]).
    gen([]).
    gen([X|T]) :- num(X), gen(T).

    p([A,B,C, D,E,F]) :-
            A + B + C =:= D + E + F.

    lucky([A,B,C, D,E,F]) :-
            gen([A,B,C, D,E,F]),
            p([A,B,C, D,E,F]).</code></pre>
<p>Программа при помощи предиката <code>gen/1</code> порождает идентификаторы билетов. Предикат <code>p/1</code> проверяет, является ли билет счастливым. Процедура порождения списка счастливых билетов оформлена в виде предиката <code>lucky/1</code> и в комментариях не нуждается. Для запуска программы порождения списка надо выполнить команду:</p>
<pre><code>?- lucky(L).

L = [0,0,0,0,0,0] ? ;
L = [0,0,1,0,0,1] ? ;
L = [0,0,1,0,1,0] ? ;
L = [0,0,1,1,0,0] ? ;
L = [0,0,2,0,0,2] ?

yes.</code></pre>
<p>Для подсчета количества счастливых билетов создадим еще одно вспомогательное правило:</p>
<pre><code>    count(N) :- findall(Ticket, lucky(Ticket),
        Tickets), length(Tickets, N).</code></pre>
<p>Данное правило позволяет подсчитывать количество счастливых билетов, но не выводить их полный список на экран.</p>
<p>Выполним запрос (GNU-Prolog):</p>
<pre><code>?- count(N).
N = 55252

(630 ms) yes.</code></pre>
<p>Приведенные программы являются также примерами использования стандартных <code>member/2</code> и <code>length/2</code> предикатов обработки списков.</p>
<section id="ускорение-решения-задачи." class="level5">
<h5><span class="header-section-number">7.1.0.0.1</span> Ускорение решения задачи.</h5>
<p>Программа перебирает <span class="math inline">\(10^6\)</span> вариантов, из которых, как мы только что увидели, только около <span class="math inline">\(5.5\cdot 10^4\)</span> относятся к решению задачи. То есть примерно один из двадцати билетов — счастливый. Возникает вопрос: Можно ли усовершенствовать программу, чтобы уменьшить количество неправильных вариантов<a href="#fn47" class="footnoteRef" id="fnref47"><sup>47</sup></a> и сэкономить время решения задачи на проверке этих неправильных вариантов?</p>
<p>Первым делом давайте попробуем вычислить значение переменной <code>F is A+B+C-D-E</code>. Добавим к программе следующий код:</p>
<pre><code>    lucky2([A,B,C, D,E,F]) :-
            gen([A,B,C, D,E]),
            F is A+B+C-D-E,
            num(F),
            p([A,B,C, D,E,F]).

    count2(N) :- findall(Ticket, lucky2(Ticket),
            Tickets), length(Tickets, N).</code></pre>
<pre><code>?- count2(N).
N = 55252

(133 ms) yes.</code></pre>
<p>Получено такое же количество решений, но за время в пять раз меньшее. Вычисленное значение <code>F</code> может быть отрицательным и больше 9, что противоречит условиям задачи, поэтому в новую процедуру порождения билетов необходимо добавить дополнительную проверку <code>num(F)</code>, которая выполняется, если <code>F</code> находится в требуемом диапазоне. Теперь порождается в 10 раз меньше билетов, даже с учетом тех, где <code>F</code> находится вне диапазона. То есть каждый второй сгенерированный билет — счастливый. Если убрать уже ненужную повторную проверку <code>p/1</code>, то скорость исполнения программы увеличится еще на 30% до 106 микросекунд, т. е. уже более, чем в 6 раз быстрее первоначальной.</p>
<pre><code>?- count2(N).
N = 55252

(103 ms) yes.</code></pre>
</section>
<section id="дополнительное-ускорение." class="level5">
<h5><span class="header-section-number">7.1.0.0.2</span> Дополнительное ускорение.</h5>
<p>Теперь попробуем найти <strong>два</strong> последних числа. Выражение <code>A+B+C-D</code> изменяется в пределах <span class="math inline">\(-9,\)</span> <span class="math inline">\(-8,\)</span> <span class="math inline">\(\ldots,0,1,\ldots,26,27\)</span>: от <code>0+0+0-9</code> до <code>9+9+9-0</code>. Варианты, кода результат выражения — отрицательный заведомо, неподходящие, так же как если этот результат больше <span class="math inline">\(18\)</span>, <code>9+9+9-9</code>. Можно еще усовершенствовать алгоритм, но оставим это в качестве упражнения. Теперь надо разработать подпрограммы, которые будут для диапазона <span class="math inline">\(0,1,\ldots,18\)</span>. Будем решать просто отдельную переборную задачу: Задано число <span class="math inline">\(S \in 0,1,\ldots,18\)</span>, найти два слагаемых <code>E</code> и <code>F</code>, дающих в сумме <span class="math inline">\(N\)</span>. Дополним программу следующим кодом:</p>
<pre><code>    lucky3([A,B,C, D,E,F]) :-
            gen([A,B,C, D]),
            S is A+B+C-D,
            S &gt;= 0, S=&lt;18,
            gen2(S, E,F).

    count3(N) :- findall(Ticket, lucky3(Ticket),
            Tickets), length(Tickets, N).

    gen2(0,0,0):-!.  % Выделим отдельно наглядные
    gen2(18,9,9):-!. % тривиальные варианты.
    gen2(N,A,B):-N&lt;10, !, igen(N,A), B is N - A.
    gen2(N,A,B):-D is N - 9, Z is 9 - D,
            igen(Z, A1), A is A1 + D, B is N - A.

    % igen(N, A) для A порождает последовательности
    % 0,1,2,...,N
    igen(N, A) :- N&gt;=1, M is N - 1, igen(M, A).
    igen(N, N).</code></pre>
<p>Запускаем запрос:</p>
<pre><code>?- count3(N).
N = 55252

(47 ms) yes.</code></pre>
<p>Теперь программа работает в 13 с лишним раз быстрее первоначальной и в 2 раза быстрее предыдущей, т. е. примерно один из трех билетов не является счастливым. Конечно, программу можно совершенствовать дальше: перейти к порождению первых трех цифр, и, отталкиваясь от полученной суммы трех первых цифр, по аналогии с последним примером порождать соответствующие последовательности. Однако необходимо заметить, что программа<a href="#fn48" class="footnoteRef" id="fnref48"><sup>48</sup></a> постепенно становится сложной, а текст все меньше и меньше воспринимаемым. Многие задачи требуют с каждым усовершенствованием увеличения программы в 2 раза для сокращения перебора ненужных вариантов также в 2 раза. Поэтому важно вовремя остановиться, либо искать какой&quot;=либо новый подход.</p>
</section>
</section>
<section id="лабораторная-работа-4-перебор" class="level2">
<h2><span class="header-section-number">7.2</span> Лабораторная работа 4: Перебор</h2>
<section id="задание.-3" class="level5">
<h5><span class="header-section-number">7.2.0.0.1</span> Задание.</h5>
<p>В pаботе тpебуется реализовать и, по возможности, усовершенствовать переборный алгоритм для <span><strong>одной из задач</strong></span> из списка индивидуальных заданий. В процессе усовершенствования программы анализируйте трудоемкость очередного этапа и полученное ускорение алгоритма. Отметим, что к категории переборных и оптимизационных относятся большинство олимпиадных задач, несколько из них приведены в качестве варианта задания.</p>
</section>
<section id="цель-работы.-3" class="level5">
<h5><span class="header-section-number">7.2.0.0.2</span> Цель работы.</h5>
<p>Приобрести навыки поиска решений задач с удовлетворением ограничений при помощи полного и частичного перебора; приобрести навыки анализа алгоритма и сокращения пространства поиска.</p>
</section>
<section id="время-работы.-3" class="level5">
<h5><span class="header-section-number">7.2.0.0.3</span> Время работы.</h5>
<p>На выполнение работы отводится четыре академических часа.</p>
</section>
<section id="индивидуальные-задания-2" class="level5">
<h5><span class="header-section-number">7.2.0.0.4</span> Индивидуальные задания</h5>
<ol>
<li><p>Реализовать программу поиска счастливых билетов из материалов лекций и провести дальнейшее усовершенствование переборного алгоритма.</p></li>
<li><p>Решение диофантова уравнения <span class="math inline">\(4x+5y=0\)</span> для значений переменных <span class="math inline">\(x\)</span> и <span class="math inline">\(y\)</span> из некоторого диапазона, значения переменных — целые числа.</p></li>
<li><p>Сгенерировать списки&quot;=палиндромы, состоящие из чисел из заданного диапазона.</p></li>
<li><p>Реализовать процедуру упорядочения списка методом перебора перестановок.</p></li>
<li><p>Решить задачу о выполнимости функции <span class="math inline">\(x_1x_2\bar{x}_3\vee \bar{x}_1x_2x_3\)</span>, подсчитать количество выполняющих наборов.</p></li>
<li><p>Решить задачу о восьми ферзях полным перебором.</p></li>
<li><p>Решить задачу о раскраске планарного графа (карты). Провести эксперименты со временем решения задачи в зависимости от количества доступных цветов для раскраски.</p></li>
<li><p>Известно, что пароль состоит из трех букв и цифр, в системе хранится хэш“=номер как сумма ASCII-кодов пароля. Сгенерировать возможные пароли. Можно усложнить задачу: в системе хранится MD5”=хэш паролей.</p></li>
<li><p>Задан набор из <span class="math inline">\(N\)</span> слов, из которых требуется составить связный кроссворд. Слова в кроссворде должны располагаться либо вертикально, либо горизонтально, причем каждое слово, записанное по вертикали, должно пересекаться с каждым словом, записанным по горизонтали. Слова, записанные в одном направлении, отделяются друг от друга как минимум одним пустым рядом. Каждое слово в кроссворде должно встречаться в точности столько раз, сколько раз оно присутствует в наборе.</p></li>
<li><p>Заданы <span class="math inline">\(N\)</span> различных точек плоскости и натуральное число <span class="math inline">\(M\)</span>. Требуется найти максимальный по площади невырожденный <span class="math inline">\(M\)</span>-угольник без самопересечений и самокасаний, вершинами которого являются некоторые из этих <span class="math inline">\(N\)</span> точек.</p></li>
<li><p>Троллейбусы одного маршрута проходят через остановку каждые <span class="math inline">\(k\)</span> (<span class="math inline">\(1\leq{}k\leq{}500\)</span>) минут. Известны времена прихода пассажиров на эту остановку. Если пассажир приходит на остановку в момент прихода троллейбуса, то он успевает уехать на нем.</p>
<p>Напишите программу, которая бы определяла, во сколько должен пройти первый троллейбус (это время от <span class="math inline">\(0\)</span> до <span class="math inline">\(k-1\)</span>), чтобы: 1) суммарное время ожидания троллейбуса для всех пассажиров было минимально; 2) максимальное из времен ожидания троллейбуса было минимально.</p></li>
<li><p>Расшифровать ребус, полученный в результате замены одинаковых букв одинаковыми цифрами: <code>БЛОК\times 7=СТЕНА</code>.</p></li>
<li><p>Найти гамильтонов путь в графе.</p></li>
<li><p>Найти эйлеров путь в графе.</p></li>
<li><p>Расставить минимальное число белых коней, чтобы пробивались все свободные позиции.</p></li>
<li><p>Расставить минимальное число белых ладей, чтобы пробивались все свободные позиции.</p></li>
<li><p>Расставить минимальное число белых ферзей, чтобы пробивались все свободные позиции.</p></li>
<li><p>Расставить минимальное число белых слонов, чтобы пробивались все свободные позиции.</p></li>
<li><p>Расставить максимальное число белых коней, чтобы они не били друг друга.</p></li>
<li><p>Расставить максимальное число белых ладей, чтобы они не били друг друга.</p></li>
<li><p>Расставить максимальное число белых ферзей, чтобы они не били друг друга.</p></li>
<li><p>Расставить максимальное число белых слонов, чтобы они не били друг друга.</p></li>
<li><p>Найти все кратчайшие маршруты коня между двумя заданными позициями.</p></li>
<li><p>Найти все кратчайшие маршруты ладьи между двумя заданными позициями.</p></li>
<li><p>Найти все кратчайшие маршруты ферзя между двумя заданными позициями.</p></li>
<li><p>Составить из костяшек набора домино все магические квадраты размера <span class="math inline">\(4\times 4\)</span>. Костяшки можно класть только горизонтально, костяшка занимает 2 позиции.</p></li>
<li><p>Расставить на клеточном поле всеми возможными способами фишки таким образом, чтобы в каждой линии (горизонтальной, вертикальной, диагональной) располагалось четное число фишек.</p></li>
<li><p>Имеется n деталей и m станков. Каждая деталь характеризуется временем обработки. Станок обрабатывает любую деталь сразу, все станки одинаковы. Определить порядок обработки деталей на станках, когда все детали будут обработаны за минимальное время.</p></li>
</ol>
</section>
<section id="методические-указания-к-лабораторной-работе-3" class="level4 unnumbered">
<h4>Методические указания к лабораторной работе</h4>
<p>Выполняйте аналогично примеру в материалах лекции, начиная с формальной постановки задачи как задачи CSP. Для задачи о счастливых билетах вектор переменных <span class="math inline">\(\vec{V}\)</span> — это набор переменных <code>[A,B,C,D,E,F]</code>, Области значений всех переменных в первоначальной постановке — числа из диапазона <code>[0,1,2,…,9]</code>, поэтому достаточно было запрограммировать всего один генератор <code>gen/1</code>. В процессе совершенствования нами получены зависимости возможных диапазонов изменения значений от состояния назначения переменных <code>A,B,C,D</code>.</p>
<p>В чем суть алгоритма &lt;&lt;Британского музея&gt;&gt;? Насколько он эффективен?</p>
<p>Как организуется генератор данных на проверку?</p>
<p>Приведите общую схему алгоритма решения диофантова уравнения.</p>
<p>Какова общая математическая постановка задач на удовлетворение ограничений?</p>
<p>Разработайте генератор чисел от 1 до 100 без использования списка значений.</p>
</section>
</section>
</section>
<section id="заключение" class="level1 unnumbered">
<h1>Заключение</h1>
<p>Изучение логического программирования полезно для понимания того, что любая правильная<a href="#fn49" class="footnoteRef" id="fnref49"><sup>49</sup></a> программа &lt;&lt;устроена логично&gt;&gt;. Исследование правильности программы позволяет создавать логичный (т. к. изучение, как правило, всегда позволяет найти &lt;&lt;дыры в логике&gt;&gt; в плохой программе), короткий (чем длиннее код программы, тем длиннее его доказательство) и эффективный (изучение способствует пониманию того, как функционируют реализованные в программе алгоритмы) программный код.</p>
<p>В книге <span class="citation" data-cites="DDWII"></span> дан пример классификации языков (точнее принципов) программирования (таблица [tbl:reflang]) по соотношению признаков &lt;&lt;условие&gt;&gt; и &lt;&lt;действие&gt;&gt;. Таким образом, вы только что ознакомились с новым принципом программирования, где программирование представляет собой одновременную обработку некоторого набора объектов, обладающих заданным свойством, в различных объектах данных.</p>
<table>
<caption>Классификация языков программирования<span data-label="tbl:reflang"></span></caption>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: left;">Условие локально</th>
<th style="text-align: left;">Условие глобально</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<p><span>99</span> plus 0.3pt Андерсон Р. : пер. с англ./ Р. Андерсон. – М.:Мир, 1982. – 168 c.: ил. Братко И. : пер. с англ./ И. Братко. – М.: Мир, 1990. – 560 c.: ил. Васильев С. Н. / С. Н. Васильев, А. К. Жерлов, Е. А. Федосов, Б. Е. Федунов. – М.: Физматлит, 2000. – 352 с: ил. / под ред. Э. В. Попова. – М.: Радио и связь, 1990. – 464 c.:ил. Лорьер. Ж.-Л. / Ж.-Л. Лорьер. – М.: Мир, 1991. – 568 с.: ил. Малпас Дж. / Дж. Малпас. – М.: Наука, 1990. – 464 с. / гл. ред. Ю. В. Прохоров. – М.: Сов. энциклопедия, 1988. – 847 c. Непейвода Н. Н. / Н. Н. Непейвода. – 2-е изд. – Новосибирск: Изд-во Новосиб. ун-та, 2000. – 521 c.: ил. Непейвода Н. Н. / Н. Н. Непейвода, И. Н. Скопин. – Москва; Ижевск: Институт компьютерных исследований, 2003 – 880 c.: ил. Рассел С. <a href="http://www.aiportal.ru/downloads/books/ai-modern-approach-2-edition-by-rassel-norvig.html">Искусственный интеллект: современный подход</a>: пер. с англ./ С. Рассел, П. Новриг. 2-е изд. – М.: Изд. дом &lt;&lt;Вильямс&gt;&gt;, 2006. – 1408 c.: ил. [Электронный ресурс]// Wikipedia, The Free Encyclopedia: сайт. – URL:<code>https://en.wikipedia.org/wiki/Definite_clause_grammar</code>. (дата обращения: 28.11.2013). . URL:<a href="http://www.gprolog.org/" class="uri">http://www.gprolog.org/</a>. (дата обращения: 28.11.2013). . URL:<a href="http://www.swi-prolog.org/" class="uri">http://www.swi-prolog.org/</a>. (дата обращения: 28.11.2013).</p>
<p>[lastpage]</p>
<p><span><strong>Черкашин</strong> Евгений Александрович<br />
</span> <span><strong>Рекурсивно&quot;=логическое программирование</strong></span><br />
ISBN 978-5-9624-0938-2</p>
<p>Редактор <em>Г. А. Борисова</em><br />
Верстка <em>Е. А. Черкашин</em></p>
<p>Темплан 2013г. Поз.186</p>
<p>Подписано в печать 28.12.2013. Формат 60<span class="math inline">\(\times\)</span>90 1/16.<br />
Уч.-изд.л.6,4. Усл.печ.л. 6,8. Тираж 100 экз. Заказ 170</p>
<p>Издательство ИГУ<br />
664003, г.Иркутск, бульвар Гагарина, 36</p>
</section>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>В англоязычной литературе данный термин называется <em>Artifical Inelligence, AI</em>.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p><em>Англ.</em> — Knowledge Acquisition.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>Например, математическое моделирование, базы данных.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>Интуитивное определение алгоритма: <em>алгоритм</em> — это конечная последовательность действий, каждое из которых выполняется за конечное время, приводящая к определенному результату.<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>Данное определение задает термин в достаточно узком смысле.<a href="#fnref5">↩</a></p></li>
<li id="fn6"><p>На самом деле это определение не охватывает такую важную отрасль ИИ, как нейронные сети.<a href="#fnref6">↩</a></p></li>
<li id="fn7"><p>С научной точки зрения данное предложение не является определением, оно неконструктивно, т. е. не задает логических связей с известными объектами и терминами. В частности, термин &lt;&lt;навык&gt;&gt; тоже подходит под это же определение.<a href="#fnref7">↩</a></p></li>
<li id="fn8"><p>Одно из последних, найденных автором пособия в <span class="citation" data-cites="DDWII"></span>, определений.<a href="#fnref8">↩</a></p></li>
<li id="fn9"><p>Некоторый формальный способ записи чего&quot;=либо.<a href="#fnref9">↩</a></p></li>
<li id="fn10"><p>В разделе рассматривается только представление знаний. Тот факт, что Сократ смертен, нас не интересует…пока.<a href="#fnref10">↩</a></p></li>
<li id="fn11"><p>…Могут быть и животные, однако это нас не интересует, так как знания связывают только свойства <span class="math inline">\(H\)</span> и <span class="math inline">\(M\)</span>.<a href="#fnref11">↩</a></p></li>
<li id="fn12"><p>Скорей всего, это слово образовано от англ. &lt;&lt;case&gt;&gt;, что значит &lt;&lt;случай&gt;&gt;. Здесь имеется в виду различение некоторых типовых ситуаций и осуществление некоторого действия в этой ситуации.<a href="#fnref12">↩</a></p></li>
<li id="fn13"><p>Если брать аналогию с объектно&quot;=ориентированным программированием (ООП), то протофрейму соответствует описание класса объектов.<a href="#fnref13">↩</a></p></li>
<li id="fn14"><p>Аналог конкретизации в ООП — это создание экземпляра класса (конкретного объекта).<a href="#fnref14">↩</a></p></li>
<li id="fn15"><p>Аналог связи наследования в ООП.<a href="#fnref15">↩</a></p></li>
<li id="fn16"><p>Всякий формализм предоставляет несколько уровней (языков) выражения знаний, например, логические формулы можно выражать с помощью исчисления высказываний и исчисления предикатов первого порядка. Исчисление предикатов первого порядка выразительнее исчисления высказываний.<a href="#fnref16">↩</a></p></li>
<li id="fn17"><p>От англ. слова <em>sentence</em> (фраза, предложение).<a href="#fnref17">↩</a></p></li>
<li id="fn18"><p>В операционной системе Windows удобнее использовать графическую оболочку системы SWI-Prolog со своим интерпретатором <span class="citation" data-cites="SWIP"></span>.<a href="#fnref18">↩</a></p></li>
<li id="fn19"><p>Внутри утверждения.<a href="#fnref19">↩</a></p></li>
<li id="fn20"><p>В англ. языке — Predicate, происходит от соответствующего латинского слова, обозначающего слово &lt;&lt;свойство&gt;&gt;.<a href="#fnref20">↩</a></p></li>
<li id="fn21"><p>Мы помним, что символы начинаются с маленькой английской буквы.<a href="#fnref21">↩</a></p></li>
<li id="fn22"><p>Англ. &lt;&lt;Application Programming Interface&gt;&gt;, API.<a href="#fnref22">↩</a></p></li>
<li id="fn23"><p>Точнее, <code>nil/0</code>.<a href="#fnref23">↩</a></p></li>
<li id="fn24"><p>Наши эксперименты с GNU-Prolog показали, что единственный способ задания запроса над предикатом пользователя — это использование предиката <code>initialization/1</code>.<a href="#fnref24">↩</a></p></li>
<li id="fn25"><p>Фактически производится добавление новых знаний и фактов из загружаемого файла. Если в файле содержатся определения предикатов, которые уже имеются в рабочей памяти системы, то происходит обновление этих предикатов. Это может стать причиной неработоспособности программы. Рекомендуется иногда выходить из интерпретатора и очищать рабочую память.<a href="#fnref25">↩</a></p></li>
<li id="fn26"><p>Англ. unification, русскоязычные неточные смысловые эквиваленты: &lt;&lt;сравнение&gt;&gt;, &lt;&lt;согласование&gt;&gt;, &lt;&lt;сверка&gt;&gt;.<a href="#fnref26">↩</a></p></li>
<li id="fn27"><p>Унификация без проверки вхождения терма имеет сложность <span class="math inline">\(O(n)\)</span>, тогда как строгая — <span class="math inline">\(O(n^2)\)</span>.<a href="#fnref27">↩</a></p></li>
<li id="fn28"><p>Задание на лабораторную работу 1 разработано преподавателем кафедры вычислительной техники Института кибернетики НИ ИрГТУ, доцентом, канд. техн. наук С. С. Сосинской.<a href="#fnref28">↩</a></p></li>
<li id="fn29"><p><code>Y=fib((C+5)+D)</code>.<a href="#fnref29">↩</a></p></li>
<li id="fn30"><p>Используется методика рассуждения, представленная в книге <span class="citation" data-cites="Bratko"></span>. Сначала рассматриваются самые простые варианты входных данных, затем сложные.<a href="#fnref30">↩</a></p></li>
<li id="fn31"><p>Латинская маленькая буква &lt;&lt;a&gt;&gt;.<a href="#fnref31">↩</a></p></li>
<li id="fn32"><p>Англоязычный вариант термина — pattern matching.<a href="#fnref32">↩</a></p></li>
<li id="fn33"><p>В Visual-Prolog запрос остается таким же, но одинарные кавычки надо заменить на двойные.<a href="#fnref33">↩</a></p></li>
<li id="fn34"><p>Грамматика, построенная на определенных предложениях.<a href="#fnref34">↩</a></p></li>
<li id="fn35"><p>Запятая имеет приоритет перед точкой с запятой.<a href="#fnref35">↩</a></p></li>
<li id="fn36"><p>Нетрудно доказать ее истинность при любых истинностных значениях <span>P</span>, например при помощи метода &lt;&lt;от противного&gt;&gt;.<a href="#fnref36">↩</a></p></li>
<li id="fn37"><p>Факт <span>P</span> истинен по определению, а <span>P :- P</span> истинно, так как это тавтология (теорема).<a href="#fnref37">↩</a></p></li>
<li id="fn38"><p>За исключением случая, если в теле <span class="math inline">\(C\)</span> есть предикат &lt;&lt;отсечение&gt;&gt; (&lt;&lt;<span>!</span>&gt;&gt;), и этот предикат будет достигнут.<a href="#fnref38">↩</a></p></li>
<li id="fn39"><p>Надо учесть также комбинации нулевых значений.<a href="#fnref39">↩</a></p></li>
<li id="fn40"><p>Предполагаем, что <span>A, B, C</span> заданы (конкретизированы).<a href="#fnref40">↩</a></p></li>
<li id="fn41"><p>Вы уже знакомы с предикатами <span>consult/1</span> и <span>reconsult</span>.<a href="#fnref41">↩</a></p></li>
<li id="fn42"><p>Взято с <a href="http://crec.mipt.ru/study/materials/db/DBvariants.doc" class="uri">http://crec.mipt.ru/study/materials/db/DBvariants.doc</a>.<a href="#fnref42">↩</a></p></li>
<li id="fn43"><p>Англ. <em>, CSP.</em><a href="#fnref43">↩</a></p></li>
<li id="fn44"><p>Алгоритмов, где на этапах выбора очередного направления поиска решения из нескольких альтернатив используется дополнительная (по отношению к исходной) информация для задания этим альтернативам некоторого предпочтения.<a href="#fnref44">↩</a></p></li>
<li id="fn45"><p>В советской литературе вариант этого подхода известен как метод &lt;&lt;Отобразить и проверить&gt;&gt; (источник информации, к сожалению, потерян). В настоящее время широко используется термин &lt;&lt;Метод грубой силы&gt;&gt; (Brute Force Approach) для обозначения данного подхода.<a href="#fnref45">↩</a></p></li>
<li id="fn46"><p>Существует фундаментальная проблема остановки, которая делает такую проверку, в общем случае, невозможной.<a href="#fnref46">↩</a></p></li>
<li id="fn47"><p>Часто требуется как можно быстрее найти первое решение или самое короткое решение. В этом случае можно рассматривать и сокращение перебора и в области решений.<a href="#fnref47">↩</a></p></li>
<li id="fn48"><p>Автор пособия не ставил целью <strong>найти</strong> эффективную и короткую программу для решения этой задачи. Задача — продемонстрировать ход рассуждений.<a href="#fnref48">↩</a></p></li>
<li id="fn49"><p>Под <span><em>правильностью</em></span> программы подразумевается, что (а) будучи запущенной, программа рано или поздно остановится, и (б) что для всех корректных входных данных выходные данные будут тоже корректны. Ознакомиться с основными принципами <span><strong>доказательства правильности</strong></span> программ можно в книге <span class="citation" data-cites="Anderson"></span>.<a href="#fnref49">↩</a></p></li>
</ol>
</section>
</body>
</html>
